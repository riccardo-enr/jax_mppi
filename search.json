[
  {
    "objectID": "autotuning.html",
    "href": "autotuning.html",
    "title": "Autotuning Guide",
    "section": "",
    "text": "JAX-MPPI includes a robust autotuning framework to optimize MPPI hyperparameters (like temperature \\(\\lambda\\), noise covariance \\(\\Sigma\\), and planning horizon). The framework supports multiple optimization strategies, including CMA-ES, Ray Tune, and Quality Diversity (QD) methods.\n\n\nThe autotuning process involves three main components:\n\nTunable Parameters: Parameters you want to optimize (e.g., LambdaParameter, NoiseSigmaParameter).\nEvaluation Function: A function that runs MPPI with a specific configuration and returns a cost (and optionally other metrics).\nOptimizer: The algorithm used to search for the best parameters (e.g., CMAESOpt).\n\n\n\n\nThe autotune module provides a simple interface for CMA-ES optimization.\nimport jax.numpy as jnp\nfrom jax_mppi import mppi, autotune\n\n# 1. Setup MPPI\nconfig, state = mppi.create(...)\nholder = autotune.ConfigStateHolder(config, state)\n\n# 2. Define evaluation\ndef evaluate():\n    # Run simulation with holder.config and holder.state\n    # Calculate performance cost\n    return autotune.EvaluationResult(mean_cost=cost, ...)\n\n# 3. Create Tuner\ntuner = autotune.Autotune(\n    params_to_tune=[\n        autotune.LambdaParameter(holder, min_value=0.1),\n        autotune.NoiseSigmaParameter(holder, min_value=0.1),\n    ],\n    evaluate_fn=evaluate,\n    optimizer=autotune.CMAESOpt(population=10),\n)\n\n# 4. Optimize\nbest_result = tuner.optimize_all(iterations=30)\nprint(f\"Best parameters: {best_result.params}\")\nSee examples/autotuning/basic.py and examples/autotuning/pendulum.py for complete running examples.\n\n\n\n\n\nFor more complex search spaces or when you want to use advanced schedulers and search algorithms (like HyperOpt or Bayesian Optimization), use autotune_global.\n\nNote: Requires ray[tune], hyperopt, and bayesian-optimization.\n\nfrom ray import tune\nfrom jax_mppi import autotune_global as autog\n\n# Define search space using Ray Tune's API\nparams = [\n    autog.GlobalLambdaParameter(holder, search_space=tune.loguniform(0.1, 10.0)),\n    autog.GlobalNoiseSigmaParameter(holder, search_space=tune.uniform(0.1, 2.0)),\n]\n\ntuner = autog.AutotuneGlobal(\n    params_to_tune=params,\n    evaluate_fn=evaluate,\n    optimizer=autog.RayOptimizer(),\n)\n\nbest = tuner.optimize_all(iterations=100)\n\n\n\nTo find a diverse set of high-performing parameters (e.g., finding parameters that work well for different environments or behavioral descriptors), use autotune_qd.\nfrom jax_mppi import autotune_qd\n\ntuner = autotune.Autotune(\n    params_to_tune=[...],\n    evaluate_fn=evaluate,\n    optimizer=autotune_qd.CMAMEOpt(population=20, bins=10),\n)\n\n\n\n\nThe framework supports tuning the following parameters out-of-the-box:\n\nLambdaParameter: MPPI temperature (\\(\\lambda\\)).\nNoiseSigmaParameter: Exploration noise covariance diagonal.\nMuParameter: Exploration noise mean.\nHorizonParameter: Planning horizon length (resizes internal buffers automatically).\n\nYou can also define custom parameters by subclassing TunableParameter.\n\n\n\nThis section details the mathematical foundations of the autotuning algorithms available in jax_mppi.\n\n\nThe goal of autotuning is to find the optimal set of hyperparameters \\(\\theta\\) (e.g., temperature \\(\\lambda\\), noise covariance \\(\\Sigma\\), horizon \\(H\\)) that minimizes the expected cost of the control task. We formulate this as an optimization problem:\n[ ^* = _{} () ]\nwhere \\(\\Theta\\) is the admissible hyperparameter space, and the objective function \\(\\mathcal{J}(\\theta)\\) is the expected cumulative cost of the closed-loop system under the MPPI controller parameterized by \\(\\theta\\):\n[ () = {{}()} ]\nHere, \\(\\tau = \\{(\\mathbf{x}_0, \\mathbf{u}_0), \\dots \\}\\) represents a trajectory rollout, and \\(c(\\mathbf{x}, \\mathbf{u})\\) is the task cost function. Since \\(\\mathcal{J}(\\theta)\\) is typically non-convex and noisy (due to the stochastic nature of MPPI and the environment), we employ derivative-free optimization methods.\n\n\n\nCMA-ES is a state-of-the-art evolutionary algorithm for continuous optimization. It models the population of candidate solutions using a multivariate normal distribution \\(\\mathcal{N}(\\mathbf{m}, \\sigma^2 \\mathbf{C})\\).\nThe algorithm proceeds in generations \\(g\\). At each generation:\n\nSampling: We sample \\(\\lambda_{pop}\\) candidate parameters \\(\\theta_i\\) (offspring): [ i ^{(g)} + ^{(g)} (, ^{(g)}) i = 1, , {pop} ]\nEvaluation: Each candidate \\(\\theta_i\\) is evaluated by running an MPPI simulation to estimate \\(\\mathcal{J}(\\theta_i)\\).\nSelection and Recombination: The candidates are sorted by their cost \\(\\mathcal{J}(\\theta_i)\\). The top \\(\\mu\\) candidates (parents) are selected to update the mean: [ ^{(g+1)} = {i=1}^{} w_i {i:_{pop}} ] where \\(w_i\\) are positive weights summing to 1, and \\(\\theta_{i:\\lambda_{pop}}\\) denotes the \\(i\\)-th best candidate.\nCovariance Adaptation: The covariance matrix \\(\\mathbf{C}^{(g)}\\) is updated to increase the likelihood of successful steps. This involves two paths:\n\nRank-1 Update: Uses the evolution path \\(\\mathbf{p}_c\\) to exploit correlations between consecutive steps.\nRank-\\(\\mu\\) Update: Uses the variance of the successful steps. [ ^{(g+1)} = (1 - c_1 - c_) ^{(g)} + c_1 c c^T + c{i=1}^{} w_i ({i:{pop}} - ^{(g)})({i:{pop}} - {(g)})T / ^{(g)2} ]\n\nStep Size Control: The global step size \\(\\sigma^{(g)}\\) is updated using the conjugate evolution path \\(\\mathbf{p}_\\sigma\\) to control the overall scale of the distribution.\n\n\n\n\nQuality Diversity (QD) algorithms optimize for a set of high-performing solutions that are diverse with respect to a user-defined measure. jax_mppi uses CMA-ME (Covariance Matrix Adaptation MAP-Elites), which combines the search power of CMA-ES with the archive maintenance of MAP-Elites.\n\n\nWe seek to find a collection of parameters \\(P = \\{\\theta_1, \\dots, \\theta_N\\}\\) that maximize the quality function \\(f(\\theta) = -\\mathcal{J}(\\theta)\\) while covering the behavior space \\(\\mathcal{B}\\).\nLet \\(\\mathbf{b}(\\theta): \\Theta \\to \\mathcal{B}\\) be a function mapping parameters to a behavior descriptor (e.g., control smoothness, risk sensitivity).\n\n\n\nThe behavior space \\(\\mathcal{B}\\) is discretized into a grid of cells (the archive \\(\\mathcal{A}\\)). Each cell \\(\\mathcal{A}_{\\mathbf{z}}\\) stores the best solution found so far that maps to that cell index \\(\\mathbf{z}\\):\n[ {} = {: (()) = } f() ]\n\n\n\nCMA-ME maintains a set of emitters, which are instances of CMA-ES optimizing for improvement in the archive.\n\nEmission: An emitter samples a candidate \\(\\theta\\) from its distribution \\(\\mathcal{N}(\\mathbf{m}, \\sigma^2 \\mathbf{C})\\).\nEvaluation: Calculate quality \\(f(\\theta)\\) and behavior \\(\\mathbf{b}(\\theta)\\).\nArchive Update:\n\nDetermine the cell index \\(\\mathbf{z} = \\text{index}(\\mathbf{b}(\\theta))\\).\nIf cell \\(\\mathcal{A}_{\\mathbf{z}}\\) is empty or \\(f(\\theta) &gt; f(\\mathcal{A}_{\\mathbf{z}})\\), replace the occupant with \\(\\theta\\).\nCalculate the â€œimprovementâ€ value \\(\\Delta\\) (e.g., \\(f(\\theta) - f(\\mathcal{A}_{\\mathbf{z}}^{old})\\)).\n\nEmitter Update: The CMA-ES emitter updates its mean and covariance based on the improvement \\(\\Delta\\), guiding the search toward regions of the behavior space where quality can be improved or new cells can be discovered.\n\n\n\n\n\nFor global search over large, potentially non-convex spaces with complex constraints, we utilize Ray Tune. The problem is formulated as:\n[ {{global}} () ]\nwhere \\(\\Theta_{global}\\) can be defined by complex distributions (e.g., Log-Uniform, Categorical).\nRay Tune orchestrates the search using algorithms like:\n\nBayesian Optimization: Uses a Gaussian Process surrogate model \\(P(f \\mid \\mathcal{D})\\) to approximate the objective and an acquisition function \\(a(\\theta)\\) (e.g., Expected Improvement) to select the next sample: [ {next} = {} a() ]\nHyperOpt (TPE): Models \\(p(\\theta \\mid y)\\) using Tree-structured Parzen Estimators to sample promising candidates.\n\nThese methods are particularly useful for â€œwarm-startingâ€ the local search (CMA-ES) or finding the best family of parameters (e.g., finding the right order of magnitude for \\(\\lambda\\)).",
    "crumbs": [
      "Home",
      "Algorithms",
      "Autotuning Guide"
    ]
  },
  {
    "objectID": "autotuning.html#overview",
    "href": "autotuning.html#overview",
    "title": "Autotuning Guide",
    "section": "",
    "text": "The autotuning process involves three main components:\n\nTunable Parameters: Parameters you want to optimize (e.g., LambdaParameter, NoiseSigmaParameter).\nEvaluation Function: A function that runs MPPI with a specific configuration and returns a cost (and optionally other metrics).\nOptimizer: The algorithm used to search for the best parameters (e.g., CMAESOpt).",
    "crumbs": [
      "Home",
      "Algorithms",
      "Autotuning Guide"
    ]
  },
  {
    "objectID": "autotuning.html#basic-usage-cma-es",
    "href": "autotuning.html#basic-usage-cma-es",
    "title": "Autotuning Guide",
    "section": "",
    "text": "The autotune module provides a simple interface for CMA-ES optimization.\nimport jax.numpy as jnp\nfrom jax_mppi import mppi, autotune\n\n# 1. Setup MPPI\nconfig, state = mppi.create(...)\nholder = autotune.ConfigStateHolder(config, state)\n\n# 2. Define evaluation\ndef evaluate():\n    # Run simulation with holder.config and holder.state\n    # Calculate performance cost\n    return autotune.EvaluationResult(mean_cost=cost, ...)\n\n# 3. Create Tuner\ntuner = autotune.Autotune(\n    params_to_tune=[\n        autotune.LambdaParameter(holder, min_value=0.1),\n        autotune.NoiseSigmaParameter(holder, min_value=0.1),\n    ],\n    evaluate_fn=evaluate,\n    optimizer=autotune.CMAESOpt(population=10),\n)\n\n# 4. Optimize\nbest_result = tuner.optimize_all(iterations=30)\nprint(f\"Best parameters: {best_result.params}\")\nSee examples/autotuning/basic.py and examples/autotuning/pendulum.py for complete running examples.",
    "crumbs": [
      "Home",
      "Algorithms",
      "Autotuning Guide"
    ]
  },
  {
    "objectID": "autotuning.html#advanced-usage",
    "href": "autotuning.html#advanced-usage",
    "title": "Autotuning Guide",
    "section": "",
    "text": "For more complex search spaces or when you want to use advanced schedulers and search algorithms (like HyperOpt or Bayesian Optimization), use autotune_global.\n\nNote: Requires ray[tune], hyperopt, and bayesian-optimization.\n\nfrom ray import tune\nfrom jax_mppi import autotune_global as autog\n\n# Define search space using Ray Tune's API\nparams = [\n    autog.GlobalLambdaParameter(holder, search_space=tune.loguniform(0.1, 10.0)),\n    autog.GlobalNoiseSigmaParameter(holder, search_space=tune.uniform(0.1, 2.0)),\n]\n\ntuner = autog.AutotuneGlobal(\n    params_to_tune=params,\n    evaluate_fn=evaluate,\n    optimizer=autog.RayOptimizer(),\n)\n\nbest = tuner.optimize_all(iterations=100)\n\n\n\nTo find a diverse set of high-performing parameters (e.g., finding parameters that work well for different environments or behavioral descriptors), use autotune_qd.\nfrom jax_mppi import autotune_qd\n\ntuner = autotune.Autotune(\n    params_to_tune=[...],\n    evaluate_fn=evaluate,\n    optimizer=autotune_qd.CMAMEOpt(population=20, bins=10),\n)",
    "crumbs": [
      "Home",
      "Algorithms",
      "Autotuning Guide"
    ]
  },
  {
    "objectID": "autotuning.html#tunable-parameters",
    "href": "autotuning.html#tunable-parameters",
    "title": "Autotuning Guide",
    "section": "",
    "text": "The framework supports tuning the following parameters out-of-the-box:\n\nLambdaParameter: MPPI temperature (\\(\\lambda\\)).\nNoiseSigmaParameter: Exploration noise covariance diagonal.\nMuParameter: Exploration noise mean.\nHorizonParameter: Planning horizon length (resizes internal buffers automatically).\n\nYou can also define custom parameters by subclassing TunableParameter.",
    "crumbs": [
      "Home",
      "Algorithms",
      "Autotuning Guide"
    ]
  },
  {
    "objectID": "autotuning.html#mathematical-formulation",
    "href": "autotuning.html#mathematical-formulation",
    "title": "Autotuning Guide",
    "section": "",
    "text": "This section details the mathematical foundations of the autotuning algorithms available in jax_mppi.\n\n\nThe goal of autotuning is to find the optimal set of hyperparameters \\(\\theta\\) (e.g., temperature \\(\\lambda\\), noise covariance \\(\\Sigma\\), horizon \\(H\\)) that minimizes the expected cost of the control task. We formulate this as an optimization problem:\n[ ^* = _{} () ]\nwhere \\(\\Theta\\) is the admissible hyperparameter space, and the objective function \\(\\mathcal{J}(\\theta)\\) is the expected cumulative cost of the closed-loop system under the MPPI controller parameterized by \\(\\theta\\):\n[ () = {{}()} ]\nHere, \\(\\tau = \\{(\\mathbf{x}_0, \\mathbf{u}_0), \\dots \\}\\) represents a trajectory rollout, and \\(c(\\mathbf{x}, \\mathbf{u})\\) is the task cost function. Since \\(\\mathcal{J}(\\theta)\\) is typically non-convex and noisy (due to the stochastic nature of MPPI and the environment), we employ derivative-free optimization methods.\n\n\n\nCMA-ES is a state-of-the-art evolutionary algorithm for continuous optimization. It models the population of candidate solutions using a multivariate normal distribution \\(\\mathcal{N}(\\mathbf{m}, \\sigma^2 \\mathbf{C})\\).\nThe algorithm proceeds in generations \\(g\\). At each generation:\n\nSampling: We sample \\(\\lambda_{pop}\\) candidate parameters \\(\\theta_i\\) (offspring): [ i ^{(g)} + ^{(g)} (, ^{(g)}) i = 1, , {pop} ]\nEvaluation: Each candidate \\(\\theta_i\\) is evaluated by running an MPPI simulation to estimate \\(\\mathcal{J}(\\theta_i)\\).\nSelection and Recombination: The candidates are sorted by their cost \\(\\mathcal{J}(\\theta_i)\\). The top \\(\\mu\\) candidates (parents) are selected to update the mean: [ ^{(g+1)} = {i=1}^{} w_i {i:_{pop}} ] where \\(w_i\\) are positive weights summing to 1, and \\(\\theta_{i:\\lambda_{pop}}\\) denotes the \\(i\\)-th best candidate.\nCovariance Adaptation: The covariance matrix \\(\\mathbf{C}^{(g)}\\) is updated to increase the likelihood of successful steps. This involves two paths:\n\nRank-1 Update: Uses the evolution path \\(\\mathbf{p}_c\\) to exploit correlations between consecutive steps.\nRank-\\(\\mu\\) Update: Uses the variance of the successful steps. [ ^{(g+1)} = (1 - c_1 - c_) ^{(g)} + c_1 c c^T + c{i=1}^{} w_i ({i:{pop}} - ^{(g)})({i:{pop}} - {(g)})T / ^{(g)2} ]\n\nStep Size Control: The global step size \\(\\sigma^{(g)}\\) is updated using the conjugate evolution path \\(\\mathbf{p}_\\sigma\\) to control the overall scale of the distribution.\n\n\n\n\nQuality Diversity (QD) algorithms optimize for a set of high-performing solutions that are diverse with respect to a user-defined measure. jax_mppi uses CMA-ME (Covariance Matrix Adaptation MAP-Elites), which combines the search power of CMA-ES with the archive maintenance of MAP-Elites.\n\n\nWe seek to find a collection of parameters \\(P = \\{\\theta_1, \\dots, \\theta_N\\}\\) that maximize the quality function \\(f(\\theta) = -\\mathcal{J}(\\theta)\\) while covering the behavior space \\(\\mathcal{B}\\).\nLet \\(\\mathbf{b}(\\theta): \\Theta \\to \\mathcal{B}\\) be a function mapping parameters to a behavior descriptor (e.g., control smoothness, risk sensitivity).\n\n\n\nThe behavior space \\(\\mathcal{B}\\) is discretized into a grid of cells (the archive \\(\\mathcal{A}\\)). Each cell \\(\\mathcal{A}_{\\mathbf{z}}\\) stores the best solution found so far that maps to that cell index \\(\\mathbf{z}\\):\n[ {} = {: (()) = } f() ]\n\n\n\nCMA-ME maintains a set of emitters, which are instances of CMA-ES optimizing for improvement in the archive.\n\nEmission: An emitter samples a candidate \\(\\theta\\) from its distribution \\(\\mathcal{N}(\\mathbf{m}, \\sigma^2 \\mathbf{C})\\).\nEvaluation: Calculate quality \\(f(\\theta)\\) and behavior \\(\\mathbf{b}(\\theta)\\).\nArchive Update:\n\nDetermine the cell index \\(\\mathbf{z} = \\text{index}(\\mathbf{b}(\\theta))\\).\nIf cell \\(\\mathcal{A}_{\\mathbf{z}}\\) is empty or \\(f(\\theta) &gt; f(\\mathcal{A}_{\\mathbf{z}})\\), replace the occupant with \\(\\theta\\).\nCalculate the â€œimprovementâ€ value \\(\\Delta\\) (e.g., \\(f(\\theta) - f(\\mathcal{A}_{\\mathbf{z}}^{old})\\)).\n\nEmitter Update: The CMA-ES emitter updates its mean and covariance based on the improvement \\(\\Delta\\), guiding the search toward regions of the behavior space where quality can be improved or new cells can be discovered.\n\n\n\n\n\nFor global search over large, potentially non-convex spaces with complex constraints, we utilize Ray Tune. The problem is formulated as:\n[ {{global}} () ]\nwhere \\(\\Theta_{global}\\) can be defined by complex distributions (e.g., Log-Uniform, Categorical).\nRay Tune orchestrates the search using algorithms like:\n\nBayesian Optimization: Uses a Gaussian Process surrogate model \\(P(f \\mid \\mathcal{D})\\) to approximate the objective and an acquisition function \\(a(\\theta)\\) (e.g., Expected Improvement) to select the next sample: [ {next} = {} a() ]\nHyperOpt (TPE): Models \\(p(\\theta \\mid y)\\) using Tree-structured Parzen Estimators to sample promising candidates.\n\nThese methods are particularly useful for â€œwarm-startingâ€ the local search (CMA-ES) or finding the best family of parameters (e.g., finding the right order of magnitude for \\(\\lambda\\)).",
    "crumbs": [
      "Home",
      "Algorithms",
      "Autotuning Guide"
    ]
  },
  {
    "objectID": "plan/index.html",
    "href": "plan/index.html",
    "title": "Development Plans",
    "section": "",
    "text": "This section contains various development plans and investigations for the jax-mppi project.\n\n\n\nPerformance Analysis\nExample Performance Investigation\nFSMI Exploration\nQuadrotor Trajectory Following\nI-MPPI Architecture Alignment\n\n\n\n\n\nFSMI Grid-Based Implementation\nI-MPPI Flavors Comparison\nPorting from PyTorch to JAX\nEvosax Integration\nCUDA MPPI Implementation\nCUDA MPPI Submodule Plan"
  },
  {
    "objectID": "plan/index.html#active-plans",
    "href": "plan/index.html#active-plans",
    "title": "Development Plans",
    "section": "",
    "text": "Performance Analysis\nExample Performance Investigation\nFSMI Exploration\nQuadrotor Trajectory Following\nI-MPPI Architecture Alignment"
  },
  {
    "objectID": "plan/index.html#completed-plans",
    "href": "plan/index.html#completed-plans",
    "title": "Development Plans",
    "section": "",
    "text": "FSMI Grid-Based Implementation\nI-MPPI Flavors Comparison\nPorting from PyTorch to JAX\nEvosax Integration\nCUDA MPPI Implementation\nCUDA MPPI Submodule Plan"
  },
  {
    "objectID": "plan/completed/porting_pytorch_jax.html",
    "href": "plan/completed/porting_pytorch_jax.html",
    "title": "JAX MPPI Implementation Plan",
    "section": "",
    "text": "Port pytorch_mppi to JAX, producing a functional, JIT-compilable MPPI library.\n\n\nOverall Progress: Phase 6 complete (Autotuning system fully implemented with CMA-ES, Ray Tune, and CMA-ME support).\n\n\n\nPhase 1: Core MPPI âœ… COMPLETE\n\n353 lines implemented in src/jax_mppi/mppi.py\nAll core features from pytorch_mppi ported\n115 lines of unit tests in tests/test_mppi.py\n\nPhase 2: Pendulum Integration âœ… COMPLETE\n\n270 lines in examples/pendulum.py (full-featured example with CLI)\n282 lines in tests/test_pendulum.py (8 comprehensive integration tests)\nAll tests passing, swing-up and stabilization verified\n\nPhase 3: Smooth MPPI (SMPPI) âœ… COMPLETE\n\n634 lines implemented in src/jax_mppi/smppi.py\nAll SMPPI features: action_sequence, smoothness cost, dual bounds, integration\n580 lines in tests/test_smppi.py (18 comprehensive tests)\nAll tests passing\n\nPhase 4: Kernel MPPI (KMPPI) âœ… COMPLETE\n\n660 lines implemented in src/jax_mppi/kmppi.py\nRBFKernel, kernel interpolation, control point optimization\n595 lines in tests/test_kmppi.py (23 comprehensive tests)\nAll tests passing (53/53 total tests pass)\n\nPhase 5: Smooth Comparison Example âœ… COMPLETE\n\n442 lines in examples/smooth_comparison.py\nCompares MPPI, SMPPI, and KMPPI on 2D navigation with obstacle avoidance\nIncludes visualization with 4 subplots: trajectories, costs, controls, smoothness\nSupporting modules: src/jax_mppi/costs/ and src/jax_mppi/dynamics/\n\nPhase 6: Autotuning âœ… COMPLETE\n\n656 lines in src/jax_mppi/autotune.py - Core CMA-ES autotuning\n375 lines in src/jax_mppi/autotune_global.py - Ray Tune global search\n218 lines in src/jax_mppi/autotune_qd.py - CMA-ME quality diversity\n305 lines in tests/test_autotune.py (21 unit tests)\n247 lines in tests/test_autotune_integration.py (4 integration tests)\n321 lines in examples/autotune_pendulum.py - Full demonstration\n90 lines in examples/autotune_basic.py - Minimal example\nAll 25 tests passing\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPackage\nCore Code\nTests\nExamples\nTotal\n\n\n\n\npytorch_mppi\n1214 lines\n~500 lines\n~800 lines\n~2500 lines\n\n\njax_mppi (current)\n2919 lines\n2124 lines\n681 lines\n5724 lines\n\n\nCompletion %\n240%\n425%\n85%\n229%\n\n\n\nCore code now includes: mppi.py (353), smppi.py (634), kmppi.py (660), autotune.py (656), autotune_global.py (375), autotune_qd.py (218), plus supporting modules.\n\n\n\n\n\n\nFeature\npytorch_mppi\njax_mppi\nStatus\n\n\n\n\nCore MPPI Algorithm\nâœ“\nâœ“\nâœ… Complete\n\n\nBasic sampling & weighting\nâœ“\nâœ“\nâœ…\n\n\nControl bounds (u_min/u_max)\nâœ“\nâœ“\nâœ…\n\n\nControl scaling (u_scale)\nâœ“\nâœ“\nâœ…\n\n\nPartial updates (u_per_command)\nâœ“\nâœ“\nâœ…\n\n\nStep-dependent dynamics\nâœ“\nâœ“\nâœ…\n\n\nStochastic dynamics (rollout_samples)\nâœ“\nâœ“\nâœ…\n\n\nSample null action\nâœ“\nâœ“\nâœ…\n\n\nNoise absolute cost\nâœ“\nâœ“\nâœ…\n\n\nTerminal cost function\nâœ“\nâœ“\nâœ…\n\n\nShift nominal trajectory\nâœ“\nâœ“\nâœ…\n\n\nGet rollouts (visualization)\nâœ“\nâœ“\nâœ…\n\n\nReset controller\nâœ“\nâœ“\nâœ…\n\n\nSmooth MPPI (SMPPI)\nâœ“\nâœ“\nâœ… Complete\n\n\nAction sequence tracking\nâœ“\nâœ“\nâœ…\n\n\nSmoothness penalty\nâœ“\nâœ“\nâœ…\n\n\nSeparate action/control bounds\nâœ“\nâœ“\nâœ…\n\n\nDelta_t integration\nâœ“\nâœ“\nâœ…\n\n\nShift with continuity\nâœ“\nâœ“\nâœ…\n\n\nKernel MPPI (KMPPI)\nâœ“\nâœ“\nâœ… Complete\n\n\nKernel interpolation\nâœ“\nâœ“\nâœ…\n\n\nRBF kernel\nâœ“\nâœ“\nâœ…\n\n\nSupport point optimization\nâœ“\nâœ“\nâœ…\n\n\nTime grid management (Tk/Hs)\nâœ“\nâœ“\nâœ…\n\n\nSolve-based interpolation\nâœ“\nâœ“\nâœ…\n\n\nAutotuning\nâœ“\nâœ“\nâœ… Complete\n\n\nCMA-ES local tuning\nâœ“\nâœ“\nâœ…\n\n\nRay Tune global search\nâœ“\nâœ“\nâœ…\n\n\nCMA-ME quality diversity\nâœ“\nâœ“\nâœ…\n\n\nParameter types (lambda, sigma, mu, horizon)\nâœ“\nâœ“\nâœ…\n\n\nAll MPPI variants support\nâœ“\nâœ“\nâœ…\n\n\nExamples\n\n\n\n\n\nPendulum swing-up\nâœ“\nâœ“\nâœ… Complete\n\n\nSmooth MPPI comparison\nâœ“\nâœ“\nâœ… Complete\n\n\nAutotuning example\nâœ“\nâœ“\nâœ… Complete\n\n\nPendulum with learned dynamics\nâœ“\nâœ—\nğŸ”´ Not planned\n\n\n\n\n\n\njax_mppi/\nâ”œâ”€â”€ pyproject.toml              âœ… Exists\nâ”œâ”€â”€ README.md                   âœ… Exists\nâ”œâ”€â”€ LICENSE                     âœ… Exists  \nâ”œâ”€â”€ src/jax_mppi/\nâ”‚   â”œâ”€â”€ __init__.py            âœ… Exists (updated for autotune)\nâ”‚   â”œâ”€â”€ types.py               âœ… Exists (9 lines)\nâ”‚   â”œâ”€â”€ mppi.py                âœ… Exists (353 lines) - COMPLETE\nâ”‚   â”œâ”€â”€ smppi.py               âœ… Exists (634 lines) - COMPLETE\nâ”‚   â”œâ”€â”€ kmppi.py               âœ… Exists (660 lines) - COMPLETE\nâ”‚   â”œâ”€â”€ autotune.py            âœ… Exists (656 lines) - COMPLETE\nâ”‚   â”œâ”€â”€ autotune_global.py     âœ… Exists (375 lines) - COMPLETE\nâ”‚   â”œâ”€â”€ autotune_qd.py         âœ… Exists (218 lines) - COMPLETE\nâ”‚   â”œâ”€â”€ costs/                 âœ… Exists (supporting modules)\nâ”‚   â””â”€â”€ dynamics/              âœ… Exists (supporting modules)\nâ”œâ”€â”€ tests/\nâ”‚   â”œâ”€â”€ test_mppi.py           âœ… Exists (115 lines) - COMPLETE\nâ”‚   â”œâ”€â”€ test_pendulum.py       âœ… Exists (282 lines) - COMPLETE\nâ”‚   â”œâ”€â”€ test_smppi.py          âœ… Exists (580 lines) - COMPLETE\nâ”‚   â”œâ”€â”€ test_autotune.py       âœ… Exists (305 lines, 21 tests) - COMPLETE\nâ”‚   â””â”€â”€ test_autotune_integration.py âœ… Exists (247 lines, 4 tests) - COMPLETE\nâ”‚   â””â”€â”€ test_kmppi.py          âœ… Exists (595 lines) - COMPLETE\nâ”œâ”€â”€ examples/\nâ”‚   â”œâ”€â”€ pendulum.py            âœ… Exists (270 lines) - COMPLETE\nâ”‚   â”œâ”€â”€ smooth_comparison.py   âœ… Exists (442 lines) - COMPLETE\nâ”‚   â”œâ”€â”€ autotune_pendulum.py   âœ… Exists (321 lines) - COMPLETE\nâ”‚   â””â”€â”€ autotune_basic.py      âœ… Exists (90 lines) - COMPLETE\nâ””â”€â”€ docs/\n    â””â”€â”€ plan/\n        â””â”€â”€ porting_pytorch_jax.md âœ… This file\n\n\n\nPriority Order:\n\nPhase 3: SMPPI Implementation (High Priority)\n\nCore functionality that adds smoothness to control\nEstimated ~250-300 lines for smppi.py\nEstimated ~150-200 lines for tests\nReference: ../pytorch_mppi/src/pytorch_mppi/mppi.py (SMPPI class)\n\nPhase 4: KMPPI Implementation (High Priority)\n\nNovel contribution with kernel interpolation\nEstimated ~300-350 lines for kmppi.py\nEstimated ~150-200 lines for tests\nReference: ../pytorch_mppi/src/pytorch_mppi/mppi.py (KMPPI class)\n\nPhase 5: Smooth Comparison Example (Medium Priority)\n\nDemonstrates value of SMPPI and KMPPI\nEstimated ~200-250 lines\nReference: ../pytorch_mppi/tests/smooth_mppi.py\n\nAdditional Examples (Low Priority)\n\nPendulum with learned dynamics\nMore complex environments\n\nPhase 6: Autotuning (Optional/Stretch)\n\nAdvanced feature for hyperparameter optimization\nEstimated ~300-400 lines\nReference: ../pytorch_mppi/src/pytorch_mppi/autotune.py\n\n\n\n\n\n\n\n\nUse @jax.tree_util.register_dataclass (or flax.struct.dataclass) to hold MPPI state (nominal trajectory U, PRNG key, config). All core functions are pure: command(state, mppi_state) -&gt; (action, mppi_state).\nRationale: Idiomatic JAX â€” pure functions compose with jit, vmap, grad. No mutable self. Avoids heavyweight dependencies like Equinox for what is fundamentally a numerical algorithm.\n\n\n\n\n\n\n\n\n\n\nPyTorch\nJAX\n\n\n\n\ntorch.distributions.MultivariateNormal\njax.random.multivariate_normal\n\n\ntensor.to(device)\njax.device_put / automatic\n\n\nPython for-loop over horizon\njax.lax.scan\n\n\n@handle_batch_input decorator\njax.vmap\n\n\ntorch.roll\njnp.roll\n\n\ntorch.linalg.solve\njnp.linalg.solve\n\n\nIn-place mutation (self.U = ...)\nReturn new state (pytree)\n\n\n\n\n\n\n\n\nActionable parity items to carry over:\n\nSMPPI semantics: maintains action_sequence separately from lifted control U; integrates with delta_t; smoothness cost from diff(action_sequence).\nSMPPI bounds: support action_min/action_max distinct from u_min/u_max (control-derivative bounds).\nKMPPI internals: keep theta as control points; build Tk/Hs time grids; kernel interpolation via solve(Ktktk, K); batch interpolation with vmap.\nSampling options: rollout_samples (M), sample_null_action, noise_abs_cost (abs(noise) in action cost).\nRollouts: get_rollouts handles state batch and dynamics that may augment state (take first nx).\n\n\n\n\n\njax_mppi/\nâ”œâ”€â”€ pyproject.toml\nâ”œâ”€â”€ README.md\nâ”œâ”€â”€ LICENSE\nâ”œâ”€â”€ src/jax_mppi/\nâ”‚   â”œâ”€â”€ __init__.py          # Public API exports\nâ”‚   â”œâ”€â”€ mppi.py              # Core MPPI (MPPIConfig, MPPIState, command, reset, etc.)\nâ”‚   â”œâ”€â”€ smppi.py             # Smooth MPPI variant\nâ”‚   â”œâ”€â”€ kmppi.py             # Kernel MPPI variant + TimeKernel / RBFKernel\nâ”‚   â”œâ”€â”€ types.py             # Type aliases, protocols for Dynamics/Cost callables\nâ”‚   â””â”€â”€ autotune.py          # Autotuning (CMA-ES wrapper, parameter search)\nâ”œâ”€â”€ tests/\nâ”‚   â”œâ”€â”€ test_mppi.py         # Unit tests for core MPPI\nâ”‚   â”œâ”€â”€ test_smppi.py        # Unit tests for SMPPI\nâ”‚   â”œâ”€â”€ test_kmppi.py        # Unit tests for KMPPI\nâ”‚   â””â”€â”€ test_pendulum.py     # Integration test with pendulum env\nâ”œâ”€â”€ examples/\nâ”‚   â”œâ”€â”€ pendulum.py          # Gym pendulum with true dynamics\nâ”‚   â”œâ”€â”€ pendulum_approximate.py  # Learned dynamics\nâ”‚   â””â”€â”€ smooth_comparison.py # MPPI vs SMPPI vs KMPPI\nâ””â”€â”€ docs/\n    â””â”€â”€ plan/\n\n\n\n\n\n\nFiles: pyproject.toml, src/jax_mppi/types.py, src/jax_mppi/mppi.py, src/jax_mppi/__init__.py\n\npyproject.toml â€” project metadata, deps: jax[cuda13], jaxlib, optional gymnasium for examples.\ntypes.py â€” Type definitions:\n# Dynamics: (state, action) -&gt; next_state  or  (state, action, t) -&gt; next_state\nDynamicsFn = Callable[..., jax.Array]\n# Cost: (state, action) -&gt; scalar_cost  or  (state, action, t) -&gt; scalar_cost\nRunningCostFn = Callable[..., jax.Array]\n# Terminal: (states, actions) -&gt; scalar_cost\nTerminalCostFn = Callable[[jax.Array, jax.Array], jax.Array]\nmppi.py â€” Core implementation:\nData structures (registered as JAX pytrees):\n@dataclass\nclass MPPIConfig:\n    # Static config (not traced through JAX)\n    num_samples: int       # K\n    horizon: int           # T\n    nx: int\n    nu: int\n    lambda_: float\n    u_scale: float\n    u_per_command: int\n    step_dependent_dynamics: bool\n    rollout_samples: int   # M\n    rollout_var_cost: float\n    rollout_var_discount: float\n    sample_null_action: bool\n    noise_abs_cost: bool\n\n@dataclass\nclass MPPIState:\n    # Dynamic state (carried through JAX transforms)\n    U: jax.Array           # (T, nu) nominal trajectory\n    u_init: jax.Array      # (nu,) default action for shift\n    noise_mu: jax.Array    # (nu,)\n    noise_sigma: jax.Array # (nu, nu)\n    noise_sigma_inv: jax.Array\n    u_min: jax.Array | None\n    u_max: jax.Array | None\n    key: jax.Array         # PRNG key\nFunctions:\ndef create(\n    nx, nu, noise_sigma, num_samples=100, horizon=15, lambda_=1.0,\n    noise_mu=None, u_min=None, u_max=None, u_init=None, U_init=None,\n    u_scale=1, u_per_command=1, step_dependent_dynamics=False,\n    rollout_samples=1, rollout_var_cost=0., rollout_var_discount=0.95,\n    sample_null_action=False, noise_abs_cost=False, key=None,\n) -&gt; tuple[MPPIConfig, MPPIState]:\n    \"\"\"Factory: create config + initial state.\"\"\"\n\ndef command(\n    config: MPPIConfig,\n    mppi_state: MPPIState,\n    current_obs: jax.Array,\n    dynamics: DynamicsFn,\n    running_cost: RunningCostFn,\n    terminal_cost: TerminalCostFn | None = None,\n    shift: bool = True,\n) -&gt; tuple[jax.Array, MPPIState]:\n    \"\"\"Compute optimal action and return updated state.\"\"\"\n\ndef reset(config: MPPIConfig, mppi_state: MPPIState, key: jax.Array) -&gt; MPPIState:\n    \"\"\"Reset nominal trajectory.\"\"\"\n\ndef get_rollouts(\n    config: MPPIConfig, mppi_state: MPPIState,\n    current_obs: jax.Array, dynamics: DynamicsFn,\n    num_rollouts: int = 1,\n) -&gt; jax.Array:\n    \"\"\"Forward-simulate trajectories for visualization.\"\"\"\nInternal functions (all JIT-compatible):\n\n_shift_nominal(mppi_state) -&gt; MPPIState â€” jnp.roll + set last to u_init\n_sample_noise(key, K, T, noise_mu, noise_sigma) -&gt; (noise, new_key) â€” sample from multivariate normal\n_compute_rollout_costs(config, current_obs, perturbed_actions, dynamics, running_cost, terminal_cost) â€” uses jax.lax.scan over horizon, jax.vmap over K samples\n_compute_weights(costs, lambda_) â€” softmax importance weighting\n_bound_action(action, u_min, u_max) â€” jnp.clip\n\nKey JAX patterns:\n\nRollout loop: jax.lax.scan with carry = (state,), xs = actions[t]\nBatch over K samples: jax.vmap(_single_rollout, in_axes=(0, None, ...))\nBatch over M rollout samples (stochastic dynamics): nested vmap or scan\nAll internal functions decorated with @jax.jit or called inside a top-level jitted command\n\nUnit test: tests/test_mppi.py\n\nTest create() produces valid config/state\nTest command() returns correct shape\nTest cost reduction over iterations on simple 1D problem\nTest bounds are respected\n\n\n\n\n\nFiles: examples/pendulum.py, tests/test_pendulum.py\n\nImplement pendulum dynamics as a pure JAX function (no gym dependency for core test)\nRun MPPI loop, verify convergence (swing-up or stabilization)\nOptional: gym rendering wrapper for visualization\n\n\n\n\nFiles: src/jax_mppi/smppi.py, tests/test_smppi.py\n\nData structures:\n@dataclass\nclass SMPPIState(MPPIState):\n    action_sequence: jax.Array  # (T, nu) actual actions\n    w_action_seq_cost: float\n    delta_t: float\n    action_min: jax.Array | None\n    action_max: jax.Array | None\nFunctions: Same API as mppi.py but with:\n\n_shift_nominal shifts both U (velocity) and action_sequence\n_compute_perturbed_actions integrates velocity to get actions\n_compute_total_cost adds smoothness penalty: ||diff(actions)||^2\nreset() zeros both U and action_sequence\nchange_horizon() keeps both U and action_sequence in sync (truncate/extend)\n\nTest: Verify smoother trajectories than base MPPI on 2D navigation\n\n\n\n\nFiles: src/jax_mppi/kmppi.py, tests/test_kmppi.py\n\nKernel abstractions:\ndef rbf_kernel(t, tk, sigma=1.0):\n    d = jnp.sum((t[:, None] - tk) ** 2, axis=-1)\n    return jnp.exp(-d / (2 * sigma ** 2 + 1e-8))\n\ndef kernel_interpolate(t, tk, coeffs, kernel_fn):\n    K_t_tk = kernel_fn(t, tk)\n    K_tk_tk = kernel_fn(tk, tk)\n    weights = jnp.linalg.solve(K_tk_tk, K_t_tk.T).T\n    return weights @ coeffs\nData structures:\n@dataclass\nclass KMPPIState(MPPIState):\n    theta: jax.Array         # (num_support_pts, nu)\n    num_support_pts: int\nFunctions: Override _compute_perturbed_actions to sample sparse + interpolate. Update theta instead of U.\n\nBuild Tk and Hs time grids on init and on horizon changes\nUse kernel_interpolate() with solve(Ktktk, K) (avoid explicit inverse)\nBatch interpolate with jax.vmap for K samples\n\nTest: Verify fewer parameters produce smooth trajectories\n\n\n\n\nFiles: examples/smooth_comparison.py\n\nSide-by-side MPPI vs SMPPI vs KMPPI on 2D navigation\nPlot trajectories and control signals\n\n\n\n\nFiles: src/jax_mppi/autotune.py\n\nWrap CMA-ES (cmaes or evosax for JAX-native) for sigma/lambda/horizon tuning\nSimpler than pytorch_mppiâ€™s framework â€” skip Ray Tune and QD initially\nFunctional API: tune_step(eval_fn, params, optimizer_state) -&gt; (params, optimizer_state)\n\n\n\n\n\n\n\nUnit tests (per phase): pytest tests/ â€” shape checks, cost reduction, bounds\nPendulum benchmark: Compare convergence (total reward) against pytorch_mppi on same scenario\nJIT correctness: Ensure jax.jit(command) produces identical results to non-jitted version\nPerformance: Benchmark command() latency vs pytorch_mppi (JAX should win after warmup due to XLA compilation)\nSmooth variants: Visual comparison of trajectory smoothness\n\n\n\nIMPORTANT: You should always use the virtual environment. To run the tests and all of the other python files.\n\nOption A: add a tests/conftest.py to insert src into sys.path.\nOption B: run tests after uv pip install -e . (editable install).\n\n\n\n\n\nCore: jax[cuda13], jaxlib, numpy Testing: pytest, gymnasium[classic_control] Autotuning (optional): cmaes or evosax Examples (optional): matplotlib, gymnasium\n\n\n\n\n\n\n\nMirror pytorch_mppi signature flags: rollout_samples, sample_null_action, noise_abs_cost.\nImplement get_rollouts handling: accept single or batched state; allow dynamics that augment state (take :nx).\nAdd shift_nominal_trajectory via jnp.roll + u_init fill.\nImplement action cost with optional abs(noise) branch.\nAdd u_per_command slicing and u_scale application in command.\n\n\n\n\n\nCarry action_sequence in state and integrate U with delta_t.\nImplement distinct action bounds (action_min/action_max) vs control bounds (u_min/u_max).\nAdd smoothness cost from diff(action_sequence) and weight w_action_seq_cost.\nEnsure reset() updates both U and action_sequence.\nImplement proper shift with action continuity (hold last value).\nImplement dual bounding system (_bound_control and _bound_action).\nRecompute effective noise after bounding for accurate cost.\n\n\n\n\n\nImplement theta control points + interpolation kernel (RBF by default).\nBuild Tk/Hs grids and re-build on horizon changes.\nUse solve(Ktktk, K) for interpolation weights (no explicit inverse).\nShift theta via interpolation when shifting nominal trajectory.\nImplement RBFKernel with configurable sigma.\nNoise sampling in control point space.\nBatched interpolation with vmap.\n\n\n\n\n\nMirror autotune interface from pytorch_mppi/autotune*.py at a minimal level (evaluation fn + optimizer loop).\nPort tests/auto_tune_parameters.py logic into a JAX-friendly example."
  },
  {
    "objectID": "plan/completed/porting_pytorch_jax.html#status-jan-31-2026",
    "href": "plan/completed/porting_pytorch_jax.html#status-jan-31-2026",
    "title": "JAX MPPI Implementation Plan",
    "section": "",
    "text": "Overall Progress: Phase 6 complete (Autotuning system fully implemented with CMA-ES, Ray Tune, and CMA-ME support).\n\n\n\nPhase 1: Core MPPI âœ… COMPLETE\n\n353 lines implemented in src/jax_mppi/mppi.py\nAll core features from pytorch_mppi ported\n115 lines of unit tests in tests/test_mppi.py\n\nPhase 2: Pendulum Integration âœ… COMPLETE\n\n270 lines in examples/pendulum.py (full-featured example with CLI)\n282 lines in tests/test_pendulum.py (8 comprehensive integration tests)\nAll tests passing, swing-up and stabilization verified\n\nPhase 3: Smooth MPPI (SMPPI) âœ… COMPLETE\n\n634 lines implemented in src/jax_mppi/smppi.py\nAll SMPPI features: action_sequence, smoothness cost, dual bounds, integration\n580 lines in tests/test_smppi.py (18 comprehensive tests)\nAll tests passing\n\nPhase 4: Kernel MPPI (KMPPI) âœ… COMPLETE\n\n660 lines implemented in src/jax_mppi/kmppi.py\nRBFKernel, kernel interpolation, control point optimization\n595 lines in tests/test_kmppi.py (23 comprehensive tests)\nAll tests passing (53/53 total tests pass)\n\nPhase 5: Smooth Comparison Example âœ… COMPLETE\n\n442 lines in examples/smooth_comparison.py\nCompares MPPI, SMPPI, and KMPPI on 2D navigation with obstacle avoidance\nIncludes visualization with 4 subplots: trajectories, costs, controls, smoothness\nSupporting modules: src/jax_mppi/costs/ and src/jax_mppi/dynamics/\n\nPhase 6: Autotuning âœ… COMPLETE\n\n656 lines in src/jax_mppi/autotune.py - Core CMA-ES autotuning\n375 lines in src/jax_mppi/autotune_global.py - Ray Tune global search\n218 lines in src/jax_mppi/autotune_qd.py - CMA-ME quality diversity\n305 lines in tests/test_autotune.py (21 unit tests)\n247 lines in tests/test_autotune_integration.py (4 integration tests)\n321 lines in examples/autotune_pendulum.py - Full demonstration\n90 lines in examples/autotune_basic.py - Minimal example\nAll 25 tests passing\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPackage\nCore Code\nTests\nExamples\nTotal\n\n\n\n\npytorch_mppi\n1214 lines\n~500 lines\n~800 lines\n~2500 lines\n\n\njax_mppi (current)\n2919 lines\n2124 lines\n681 lines\n5724 lines\n\n\nCompletion %\n240%\n425%\n85%\n229%\n\n\n\nCore code now includes: mppi.py (353), smppi.py (634), kmppi.py (660), autotune.py (656), autotune_global.py (375), autotune_qd.py (218), plus supporting modules.\n\n\n\n\n\n\nFeature\npytorch_mppi\njax_mppi\nStatus\n\n\n\n\nCore MPPI Algorithm\nâœ“\nâœ“\nâœ… Complete\n\n\nBasic sampling & weighting\nâœ“\nâœ“\nâœ…\n\n\nControl bounds (u_min/u_max)\nâœ“\nâœ“\nâœ…\n\n\nControl scaling (u_scale)\nâœ“\nâœ“\nâœ…\n\n\nPartial updates (u_per_command)\nâœ“\nâœ“\nâœ…\n\n\nStep-dependent dynamics\nâœ“\nâœ“\nâœ…\n\n\nStochastic dynamics (rollout_samples)\nâœ“\nâœ“\nâœ…\n\n\nSample null action\nâœ“\nâœ“\nâœ…\n\n\nNoise absolute cost\nâœ“\nâœ“\nâœ…\n\n\nTerminal cost function\nâœ“\nâœ“\nâœ…\n\n\nShift nominal trajectory\nâœ“\nâœ“\nâœ…\n\n\nGet rollouts (visualization)\nâœ“\nâœ“\nâœ…\n\n\nReset controller\nâœ“\nâœ“\nâœ…\n\n\nSmooth MPPI (SMPPI)\nâœ“\nâœ“\nâœ… Complete\n\n\nAction sequence tracking\nâœ“\nâœ“\nâœ…\n\n\nSmoothness penalty\nâœ“\nâœ“\nâœ…\n\n\nSeparate action/control bounds\nâœ“\nâœ“\nâœ…\n\n\nDelta_t integration\nâœ“\nâœ“\nâœ…\n\n\nShift with continuity\nâœ“\nâœ“\nâœ…\n\n\nKernel MPPI (KMPPI)\nâœ“\nâœ“\nâœ… Complete\n\n\nKernel interpolation\nâœ“\nâœ“\nâœ…\n\n\nRBF kernel\nâœ“\nâœ“\nâœ…\n\n\nSupport point optimization\nâœ“\nâœ“\nâœ…\n\n\nTime grid management (Tk/Hs)\nâœ“\nâœ“\nâœ…\n\n\nSolve-based interpolation\nâœ“\nâœ“\nâœ…\n\n\nAutotuning\nâœ“\nâœ“\nâœ… Complete\n\n\nCMA-ES local tuning\nâœ“\nâœ“\nâœ…\n\n\nRay Tune global search\nâœ“\nâœ“\nâœ…\n\n\nCMA-ME quality diversity\nâœ“\nâœ“\nâœ…\n\n\nParameter types (lambda, sigma, mu, horizon)\nâœ“\nâœ“\nâœ…\n\n\nAll MPPI variants support\nâœ“\nâœ“\nâœ…\n\n\nExamples\n\n\n\n\n\nPendulum swing-up\nâœ“\nâœ“\nâœ… Complete\n\n\nSmooth MPPI comparison\nâœ“\nâœ“\nâœ… Complete\n\n\nAutotuning example\nâœ“\nâœ“\nâœ… Complete\n\n\nPendulum with learned dynamics\nâœ“\nâœ—\nğŸ”´ Not planned\n\n\n\n\n\n\njax_mppi/\nâ”œâ”€â”€ pyproject.toml              âœ… Exists\nâ”œâ”€â”€ README.md                   âœ… Exists\nâ”œâ”€â”€ LICENSE                     âœ… Exists  \nâ”œâ”€â”€ src/jax_mppi/\nâ”‚   â”œâ”€â”€ __init__.py            âœ… Exists (updated for autotune)\nâ”‚   â”œâ”€â”€ types.py               âœ… Exists (9 lines)\nâ”‚   â”œâ”€â”€ mppi.py                âœ… Exists (353 lines) - COMPLETE\nâ”‚   â”œâ”€â”€ smppi.py               âœ… Exists (634 lines) - COMPLETE\nâ”‚   â”œâ”€â”€ kmppi.py               âœ… Exists (660 lines) - COMPLETE\nâ”‚   â”œâ”€â”€ autotune.py            âœ… Exists (656 lines) - COMPLETE\nâ”‚   â”œâ”€â”€ autotune_global.py     âœ… Exists (375 lines) - COMPLETE\nâ”‚   â”œâ”€â”€ autotune_qd.py         âœ… Exists (218 lines) - COMPLETE\nâ”‚   â”œâ”€â”€ costs/                 âœ… Exists (supporting modules)\nâ”‚   â””â”€â”€ dynamics/              âœ… Exists (supporting modules)\nâ”œâ”€â”€ tests/\nâ”‚   â”œâ”€â”€ test_mppi.py           âœ… Exists (115 lines) - COMPLETE\nâ”‚   â”œâ”€â”€ test_pendulum.py       âœ… Exists (282 lines) - COMPLETE\nâ”‚   â”œâ”€â”€ test_smppi.py          âœ… Exists (580 lines) - COMPLETE\nâ”‚   â”œâ”€â”€ test_autotune.py       âœ… Exists (305 lines, 21 tests) - COMPLETE\nâ”‚   â””â”€â”€ test_autotune_integration.py âœ… Exists (247 lines, 4 tests) - COMPLETE\nâ”‚   â””â”€â”€ test_kmppi.py          âœ… Exists (595 lines) - COMPLETE\nâ”œâ”€â”€ examples/\nâ”‚   â”œâ”€â”€ pendulum.py            âœ… Exists (270 lines) - COMPLETE\nâ”‚   â”œâ”€â”€ smooth_comparison.py   âœ… Exists (442 lines) - COMPLETE\nâ”‚   â”œâ”€â”€ autotune_pendulum.py   âœ… Exists (321 lines) - COMPLETE\nâ”‚   â””â”€â”€ autotune_basic.py      âœ… Exists (90 lines) - COMPLETE\nâ””â”€â”€ docs/\n    â””â”€â”€ plan/\n        â””â”€â”€ porting_pytorch_jax.md âœ… This file\n\n\n\nPriority Order:\n\nPhase 3: SMPPI Implementation (High Priority)\n\nCore functionality that adds smoothness to control\nEstimated ~250-300 lines for smppi.py\nEstimated ~150-200 lines for tests\nReference: ../pytorch_mppi/src/pytorch_mppi/mppi.py (SMPPI class)\n\nPhase 4: KMPPI Implementation (High Priority)\n\nNovel contribution with kernel interpolation\nEstimated ~300-350 lines for kmppi.py\nEstimated ~150-200 lines for tests\nReference: ../pytorch_mppi/src/pytorch_mppi/mppi.py (KMPPI class)\n\nPhase 5: Smooth Comparison Example (Medium Priority)\n\nDemonstrates value of SMPPI and KMPPI\nEstimated ~200-250 lines\nReference: ../pytorch_mppi/tests/smooth_mppi.py\n\nAdditional Examples (Low Priority)\n\nPendulum with learned dynamics\nMore complex environments\n\nPhase 6: Autotuning (Optional/Stretch)\n\nAdvanced feature for hyperparameter optimization\nEstimated ~300-400 lines\nReference: ../pytorch_mppi/src/pytorch_mppi/autotune.py"
  },
  {
    "objectID": "plan/completed/porting_pytorch_jax.html#design-decisions",
    "href": "plan/completed/porting_pytorch_jax.html#design-decisions",
    "title": "JAX MPPI Implementation Plan",
    "section": "",
    "text": "Use @jax.tree_util.register_dataclass (or flax.struct.dataclass) to hold MPPI state (nominal trajectory U, PRNG key, config). All core functions are pure: command(state, mppi_state) -&gt; (action, mppi_state).\nRationale: Idiomatic JAX â€” pure functions compose with jit, vmap, grad. No mutable self. Avoids heavyweight dependencies like Equinox for what is fundamentally a numerical algorithm.\n\n\n\n\n\n\n\n\n\n\nPyTorch\nJAX\n\n\n\n\ntorch.distributions.MultivariateNormal\njax.random.multivariate_normal\n\n\ntensor.to(device)\njax.device_put / automatic\n\n\nPython for-loop over horizon\njax.lax.scan\n\n\n@handle_batch_input decorator\njax.vmap\n\n\ntorch.roll\njnp.roll\n\n\ntorch.linalg.solve\njnp.linalg.solve\n\n\nIn-place mutation (self.U = ...)\nReturn new state (pytree)"
  },
  {
    "objectID": "plan/completed/porting_pytorch_jax.html#notes-from-..pytorch_mppi-review-jan-2026",
    "href": "plan/completed/porting_pytorch_jax.html#notes-from-..pytorch_mppi-review-jan-2026",
    "title": "JAX MPPI Implementation Plan",
    "section": "",
    "text": "Actionable parity items to carry over:\n\nSMPPI semantics: maintains action_sequence separately from lifted control U; integrates with delta_t; smoothness cost from diff(action_sequence).\nSMPPI bounds: support action_min/action_max distinct from u_min/u_max (control-derivative bounds).\nKMPPI internals: keep theta as control points; build Tk/Hs time grids; kernel interpolation via solve(Ktktk, K); batch interpolation with vmap.\nSampling options: rollout_samples (M), sample_null_action, noise_abs_cost (abs(noise) in action cost).\nRollouts: get_rollouts handles state batch and dynamics that may augment state (take first nx)."
  },
  {
    "objectID": "plan/completed/porting_pytorch_jax.html#package-structure",
    "href": "plan/completed/porting_pytorch_jax.html#package-structure",
    "title": "JAX MPPI Implementation Plan",
    "section": "",
    "text": "jax_mppi/\nâ”œâ”€â”€ pyproject.toml\nâ”œâ”€â”€ README.md\nâ”œâ”€â”€ LICENSE\nâ”œâ”€â”€ src/jax_mppi/\nâ”‚   â”œâ”€â”€ __init__.py          # Public API exports\nâ”‚   â”œâ”€â”€ mppi.py              # Core MPPI (MPPIConfig, MPPIState, command, reset, etc.)\nâ”‚   â”œâ”€â”€ smppi.py             # Smooth MPPI variant\nâ”‚   â”œâ”€â”€ kmppi.py             # Kernel MPPI variant + TimeKernel / RBFKernel\nâ”‚   â”œâ”€â”€ types.py             # Type aliases, protocols for Dynamics/Cost callables\nâ”‚   â””â”€â”€ autotune.py          # Autotuning (CMA-ES wrapper, parameter search)\nâ”œâ”€â”€ tests/\nâ”‚   â”œâ”€â”€ test_mppi.py         # Unit tests for core MPPI\nâ”‚   â”œâ”€â”€ test_smppi.py        # Unit tests for SMPPI\nâ”‚   â”œâ”€â”€ test_kmppi.py        # Unit tests for KMPPI\nâ”‚   â””â”€â”€ test_pendulum.py     # Integration test with pendulum env\nâ”œâ”€â”€ examples/\nâ”‚   â”œâ”€â”€ pendulum.py          # Gym pendulum with true dynamics\nâ”‚   â”œâ”€â”€ pendulum_approximate.py  # Learned dynamics\nâ”‚   â””â”€â”€ smooth_comparison.py # MPPI vs SMPPI vs KMPPI\nâ””â”€â”€ docs/\n    â””â”€â”€ plan/"
  },
  {
    "objectID": "plan/completed/porting_pytorch_jax.html#phased-implementation",
    "href": "plan/completed/porting_pytorch_jax.html#phased-implementation",
    "title": "JAX MPPI Implementation Plan",
    "section": "",
    "text": "Files: pyproject.toml, src/jax_mppi/types.py, src/jax_mppi/mppi.py, src/jax_mppi/__init__.py\n\npyproject.toml â€” project metadata, deps: jax[cuda13], jaxlib, optional gymnasium for examples.\ntypes.py â€” Type definitions:\n# Dynamics: (state, action) -&gt; next_state  or  (state, action, t) -&gt; next_state\nDynamicsFn = Callable[..., jax.Array]\n# Cost: (state, action) -&gt; scalar_cost  or  (state, action, t) -&gt; scalar_cost\nRunningCostFn = Callable[..., jax.Array]\n# Terminal: (states, actions) -&gt; scalar_cost\nTerminalCostFn = Callable[[jax.Array, jax.Array], jax.Array]\nmppi.py â€” Core implementation:\nData structures (registered as JAX pytrees):\n@dataclass\nclass MPPIConfig:\n    # Static config (not traced through JAX)\n    num_samples: int       # K\n    horizon: int           # T\n    nx: int\n    nu: int\n    lambda_: float\n    u_scale: float\n    u_per_command: int\n    step_dependent_dynamics: bool\n    rollout_samples: int   # M\n    rollout_var_cost: float\n    rollout_var_discount: float\n    sample_null_action: bool\n    noise_abs_cost: bool\n\n@dataclass\nclass MPPIState:\n    # Dynamic state (carried through JAX transforms)\n    U: jax.Array           # (T, nu) nominal trajectory\n    u_init: jax.Array      # (nu,) default action for shift\n    noise_mu: jax.Array    # (nu,)\n    noise_sigma: jax.Array # (nu, nu)\n    noise_sigma_inv: jax.Array\n    u_min: jax.Array | None\n    u_max: jax.Array | None\n    key: jax.Array         # PRNG key\nFunctions:\ndef create(\n    nx, nu, noise_sigma, num_samples=100, horizon=15, lambda_=1.0,\n    noise_mu=None, u_min=None, u_max=None, u_init=None, U_init=None,\n    u_scale=1, u_per_command=1, step_dependent_dynamics=False,\n    rollout_samples=1, rollout_var_cost=0., rollout_var_discount=0.95,\n    sample_null_action=False, noise_abs_cost=False, key=None,\n) -&gt; tuple[MPPIConfig, MPPIState]:\n    \"\"\"Factory: create config + initial state.\"\"\"\n\ndef command(\n    config: MPPIConfig,\n    mppi_state: MPPIState,\n    current_obs: jax.Array,\n    dynamics: DynamicsFn,\n    running_cost: RunningCostFn,\n    terminal_cost: TerminalCostFn | None = None,\n    shift: bool = True,\n) -&gt; tuple[jax.Array, MPPIState]:\n    \"\"\"Compute optimal action and return updated state.\"\"\"\n\ndef reset(config: MPPIConfig, mppi_state: MPPIState, key: jax.Array) -&gt; MPPIState:\n    \"\"\"Reset nominal trajectory.\"\"\"\n\ndef get_rollouts(\n    config: MPPIConfig, mppi_state: MPPIState,\n    current_obs: jax.Array, dynamics: DynamicsFn,\n    num_rollouts: int = 1,\n) -&gt; jax.Array:\n    \"\"\"Forward-simulate trajectories for visualization.\"\"\"\nInternal functions (all JIT-compatible):\n\n_shift_nominal(mppi_state) -&gt; MPPIState â€” jnp.roll + set last to u_init\n_sample_noise(key, K, T, noise_mu, noise_sigma) -&gt; (noise, new_key) â€” sample from multivariate normal\n_compute_rollout_costs(config, current_obs, perturbed_actions, dynamics, running_cost, terminal_cost) â€” uses jax.lax.scan over horizon, jax.vmap over K samples\n_compute_weights(costs, lambda_) â€” softmax importance weighting\n_bound_action(action, u_min, u_max) â€” jnp.clip\n\nKey JAX patterns:\n\nRollout loop: jax.lax.scan with carry = (state,), xs = actions[t]\nBatch over K samples: jax.vmap(_single_rollout, in_axes=(0, None, ...))\nBatch over M rollout samples (stochastic dynamics): nested vmap or scan\nAll internal functions decorated with @jax.jit or called inside a top-level jitted command\n\nUnit test: tests/test_mppi.py\n\nTest create() produces valid config/state\nTest command() returns correct shape\nTest cost reduction over iterations on simple 1D problem\nTest bounds are respected\n\n\n\n\n\nFiles: examples/pendulum.py, tests/test_pendulum.py\n\nImplement pendulum dynamics as a pure JAX function (no gym dependency for core test)\nRun MPPI loop, verify convergence (swing-up or stabilization)\nOptional: gym rendering wrapper for visualization\n\n\n\n\nFiles: src/jax_mppi/smppi.py, tests/test_smppi.py\n\nData structures:\n@dataclass\nclass SMPPIState(MPPIState):\n    action_sequence: jax.Array  # (T, nu) actual actions\n    w_action_seq_cost: float\n    delta_t: float\n    action_min: jax.Array | None\n    action_max: jax.Array | None\nFunctions: Same API as mppi.py but with:\n\n_shift_nominal shifts both U (velocity) and action_sequence\n_compute_perturbed_actions integrates velocity to get actions\n_compute_total_cost adds smoothness penalty: ||diff(actions)||^2\nreset() zeros both U and action_sequence\nchange_horizon() keeps both U and action_sequence in sync (truncate/extend)\n\nTest: Verify smoother trajectories than base MPPI on 2D navigation\n\n\n\n\nFiles: src/jax_mppi/kmppi.py, tests/test_kmppi.py\n\nKernel abstractions:\ndef rbf_kernel(t, tk, sigma=1.0):\n    d = jnp.sum((t[:, None] - tk) ** 2, axis=-1)\n    return jnp.exp(-d / (2 * sigma ** 2 + 1e-8))\n\ndef kernel_interpolate(t, tk, coeffs, kernel_fn):\n    K_t_tk = kernel_fn(t, tk)\n    K_tk_tk = kernel_fn(tk, tk)\n    weights = jnp.linalg.solve(K_tk_tk, K_t_tk.T).T\n    return weights @ coeffs\nData structures:\n@dataclass\nclass KMPPIState(MPPIState):\n    theta: jax.Array         # (num_support_pts, nu)\n    num_support_pts: int\nFunctions: Override _compute_perturbed_actions to sample sparse + interpolate. Update theta instead of U.\n\nBuild Tk and Hs time grids on init and on horizon changes\nUse kernel_interpolate() with solve(Ktktk, K) (avoid explicit inverse)\nBatch interpolate with jax.vmap for K samples\n\nTest: Verify fewer parameters produce smooth trajectories\n\n\n\n\nFiles: examples/smooth_comparison.py\n\nSide-by-side MPPI vs SMPPI vs KMPPI on 2D navigation\nPlot trajectories and control signals\n\n\n\n\nFiles: src/jax_mppi/autotune.py\n\nWrap CMA-ES (cmaes or evosax for JAX-native) for sigma/lambda/horizon tuning\nSimpler than pytorch_mppiâ€™s framework â€” skip Ray Tune and QD initially\nFunctional API: tune_step(eval_fn, params, optimizer_state) -&gt; (params, optimizer_state)"
  },
  {
    "objectID": "plan/completed/porting_pytorch_jax.html#verification-strategy",
    "href": "plan/completed/porting_pytorch_jax.html#verification-strategy",
    "title": "JAX MPPI Implementation Plan",
    "section": "",
    "text": "Unit tests (per phase): pytest tests/ â€” shape checks, cost reduction, bounds\nPendulum benchmark: Compare convergence (total reward) against pytorch_mppi on same scenario\nJIT correctness: Ensure jax.jit(command) produces identical results to non-jitted version\nPerformance: Benchmark command() latency vs pytorch_mppi (JAX should win after warmup due to XLA compilation)\nSmooth variants: Visual comparison of trajectory smoothness\n\n\n\nIMPORTANT: You should always use the virtual environment. To run the tests and all of the other python files.\n\nOption A: add a tests/conftest.py to insert src into sys.path.\nOption B: run tests after uv pip install -e . (editable install)."
  },
  {
    "objectID": "plan/completed/porting_pytorch_jax.html#dependencies",
    "href": "plan/completed/porting_pytorch_jax.html#dependencies",
    "title": "JAX MPPI Implementation Plan",
    "section": "",
    "text": "Core: jax[cuda13], jaxlib, numpy Testing: pytest, gymnasium[classic_control] Autotuning (optional): cmaes or evosax Examples (optional): matplotlib, gymnasium"
  },
  {
    "objectID": "plan/completed/porting_pytorch_jax.html#actionable-task-checklist",
    "href": "plan/completed/porting_pytorch_jax.html#actionable-task-checklist",
    "title": "JAX MPPI Implementation Plan",
    "section": "",
    "text": "Mirror pytorch_mppi signature flags: rollout_samples, sample_null_action, noise_abs_cost.\nImplement get_rollouts handling: accept single or batched state; allow dynamics that augment state (take :nx).\nAdd shift_nominal_trajectory via jnp.roll + u_init fill.\nImplement action cost with optional abs(noise) branch.\nAdd u_per_command slicing and u_scale application in command.\n\n\n\n\n\nCarry action_sequence in state and integrate U with delta_t.\nImplement distinct action bounds (action_min/action_max) vs control bounds (u_min/u_max).\nAdd smoothness cost from diff(action_sequence) and weight w_action_seq_cost.\nEnsure reset() updates both U and action_sequence.\nImplement proper shift with action continuity (hold last value).\nImplement dual bounding system (_bound_control and _bound_action).\nRecompute effective noise after bounding for accurate cost.\n\n\n\n\n\nImplement theta control points + interpolation kernel (RBF by default).\nBuild Tk/Hs grids and re-build on horizon changes.\nUse solve(Ktktk, K) for interpolation weights (no explicit inverse).\nShift theta via interpolation when shifting nominal trajectory.\nImplement RBFKernel with configurable sigma.\nNoise sampling in control point space.\nBatched interpolation with vmap.\n\n\n\n\n\nMirror autotune interface from pytorch_mppi/autotune*.py at a minimal level (evaluation fn + optimizer loop).\nPort tests/auto_tune_parameters.py logic into a JAX-friendly example."
  },
  {
    "objectID": "plan/completed/cuda_mppi_implementation.html",
    "href": "plan/completed/cuda_mppi_implementation.html",
    "title": "CUDA/C++ MPPI Implementation Plan",
    "section": "",
    "text": "Implement CUDA/C++ versions of MPPI, SMPPI, and KMPPI controllers within the src/cuda_mppi directory, using ../MPPI-Generic as a reference for high-performance CUDA implementation patterns.\n\n\n\n\nCreate a C++/CUDA project structure within src/cuda_mppi.\nImplement the standard MPPI algorithm (mirroring src/jax_mppi/mppi.py).\nImplement the Smooth MPPI (SMPPI) algorithm (mirroring src/jax_mppi/smppi.py).\nImplement the Kernel MPPI (KMPPI) algorithm (mirroring src/jax_mppi/kmppi.py).\nEnsure the implementations are self-contained or have clear interfaces (even if not fully hooked up to Python yet).\n\n\n\n\nWe will create src/cuda_mppi with the following structure:\nsrc/cuda_mppi/\nâ”œâ”€â”€ CMakeLists.txt              # Build configuration\nâ”œâ”€â”€ include/\nâ”‚   â””â”€â”€ mppi/\nâ”‚       â”œâ”€â”€ controllers/\nâ”‚       â”‚   â”œâ”€â”€ mppi.cuh        # Standard MPPI header\nâ”‚       â”‚   â”œâ”€â”€ smppi.cuh       # Smooth MPPI header\nâ”‚       â”‚   â””â”€â”€ kmppi.cuh       # Kernel MPPI header\nâ”‚       â”œâ”€â”€ core/\nâ”‚       â”‚   â”œâ”€â”€ mppi_common.cuh # Common structures and utilities\nâ”‚       â”‚   â””â”€â”€ kernels.cuh     # Shared CUDA kernels (rollout, cost, etc.)\nâ”‚       â”œâ”€â”€ dynamics/\nâ”‚       â”‚   â””â”€â”€ dynamics.cuh    # Dynamics interface and base classes\nâ”‚       â”œâ”€â”€ costs/\nâ”‚       â”‚   â””â”€â”€ costs.cuh       # Cost function interface\nâ”‚       â””â”€â”€ utils/\nâ”‚           â””â”€â”€ cuda_utils.cuh  # CUDA helper functions\nâ””â”€â”€ src/\n    â”œâ”€â”€ controllers/\n    â”‚   â”œâ”€â”€ mppi.cu             # Standard MPPI implementation\n    â”‚   â”œâ”€â”€ smppi.cu            # Smooth MPPI implementation\n    â”‚   â””â”€â”€ kmppi.cu            # Kernel MPPI implementation\n    â”œâ”€â”€ core/\n    â”‚   â””â”€â”€ kernels.cu          # Kernel implementations\n    â””â”€â”€ utils/\n        â””â”€â”€ cuda_utils.cu       # Utility implementations\n\n\n\n\n\n\nmppi_common.cuh: Define data structures for state, configuration, and control sequences.\nkernels.cuh:\n\nrollout_kernel: Generic kernel to propagate dynamics and compute costs for \\(K\\) samples over \\(T\\) timesteps.\nreduce_cost_kernel: Kernel to compute weighted averages of trajectories.\n\n\n\n\n\n\nDefine template interfaces or base classes for Dynamics and RunningCost so that specific system models (like Quadrotor) can be plugged in.\nNote: Since we are focusing on the controllers, we will provide a simple example dynamics (e.g., Double Integrator or simple Quadrotor) to verify compilation, but the main focus is the controller logic.\n\n\n\n\n\n\n\nLogic:\n\nSample noise \\(\\epsilon \\sim \\mathcal{N}(0, \\Sigma)\\).\nCompute \\(u_{per} = u_{nom} + \\epsilon\\).\nRollout dynamics using \\(u_{per}\\).\nCompute costs \\(J(\\tau)\\).\nCompute weights \\(w \\propto \\exp(-J/\\lambda)\\).\nUpdate \\(u_{nom} \\leftarrow u_{nom} + \\sum w \\epsilon\\).\n\nCUDA: Use block-per-sample or thread-per-sample approach depending on horizon/state size. MPPI-Generic often uses block-y striding.\n\n\n\n\n\nLogic:\n\nSample noise in velocity space \\(\\delta v\\).\nIntegrate to get actions \\(u\\).\nAdd smoothness cost \\(\\sum (\\Delta u)^2\\).\nUpdate velocity sequence \\(v_{nom}\\).\n\nCUDA: Needs a kernel that handles the integration step (velocity -&gt; action) before the rollout.\n\n\n\n\n\nLogic:\n\nControl trajectory parameterized by control points \\(\\theta\\) and kernel \\(K(\\cdot, \\cdot)\\).\nSample noise on \\(\\theta\\).\nInterpolate \\(\\theta \\to u(t)\\).\nRollout.\nUpdate \\(\\theta\\).\n\nCUDA: Needs a kernel multiplication/interpolation step before rollout.\n\n\n\n\n\n\n\nSetup: Create directory structure and CMakeLists.txt.\nCommon: Implement mppi_common.cuh and basic cuda_utils.cuh.\nDynamics/Cost: Define minimal interfaces.\nMPPI: Implement mppi.cuh and mppi.cu.\nSMPPI: Implement smppi.cuh and smppi.cu.\nKMPPI: Implement kmppi.cuh and kmppi.cu.\nVerification: Create a dummy main.cu to instantiate these controllers and verify they compile.\n\n\n\n\n\n\nExpose the C++ MPPI controllers to Python to allow direct usage from the jax_mppi package, potentially replacing the JAX implementation for performance-critical sections.\n\n\n\n\nBinding Library: Use nanobind (efficient, small footprint) to create Python bindings for the C++ classes.\nData Transfer:\n\nBasic: Accept NumPy arrays (CPU) and copy to GPU in C++.\nAdvanced (Zero-Copy): Accept DLPack capsules (from jax.Array or torch.Tensor) to pass GPU pointers directly to the C++ controllers, avoiding CPU-GPU transfers.\n\n\n\n\n\n\nProject Config:\n\nUpdate pyproject.toml to support C++ extensions (e.g., using scikit-build-core).\nAdd dependencies: nanobind, scikit-build-core.\n\nBindings Code:\n\nCreate src/cuda_mppi/bindings/bindings.cpp.\nExpose MPPIConfig struct as a Python class.\nExpose MPPIController, SMPPIController, KMPPIController classes.\nBind methods like compute(state) and get_action().\nImplement type casters for Eigen::VectorXf &lt;-&gt; numpy.ndarray (using nanobind/eigen/dense.h).\n\nCMake Update:\n\nAdd nanobind_add_module target.\nLink against cuda_mppi and CUDA libraries.\n\nIntegration:\n\nCreate a Python wrapper module (e.g., jax_mppi.cuda) that imports the extension.\nAdd tests in tests/ to verify correctness against the JAX implementation.\n\n\n\n\n\n\n\n\nAllow users to define dynamics and cost functions in Python (initially as C++ code strings, or eventually transpiled from JAX) and compile the specialized MPPI controller at runtime. This avoids the need to recompile the shared library for every new system.\n\n\n\n\nNVRTC (NVIDIA Runtime Compilation): Use NVRTC to compile CUDA C++ code strings into PTX at runtime.\nCUDA Driver API: Use the Driver API (cuModuleLoadData, cuLaunchKernel) to load the compiled PTX and launch the rollout_kernel.\nWarm Start: The compilation happens once during the â€œwarm startâ€ phase (controller initialization), enabling high-performance rollouts thereafter.\n\n\n\n\n\nBuild Config: Link against nvrtc and cuda (Driver API).\nJIT Compiler Class (src/cuda_mppi/include/mppi/jit/jit_compiler.hpp):\n\nInputs: Strings for dynamics_struct_code and cost_struct_code.\nAction: Constructs the full .cu source code (headers + user structs + template instantiation).\nOutput: Compiles to PTX using nvrtcProgramCompile.\nUpdated wrapper generation to work with Driver API.\n\nJIT Controller (JITMPPIController):\n\nA generic controller class that holds CUfunction handles instead of hardcoded kernels.\ncompute() method launches the generated kernel via cuLaunchKernel.\nImplemented in include/mppi/controllers/jit_mppi.hpp and src/jit/jit_mppi_controller.cpp.\n\nPython Interface:\n\nExpose JITMPPIController to Python via nanobind.\nExample usage:\ndynamics_code = \"\"\"\nstruct UserDynamics {\n    __device__ void step(...) { ... }\n};\n\"\"\"\ncost_code = \"\"\"\nstruct UserCost {\n    __device__ float compute(...) { ... }\n    __device__ float terminal_cost(...) { ... }\n};\n\"\"\"\ncontroller = cuda_mppi.JITMPPIController(config, dynamics_code, cost_code, include_paths)\n\nVerification & Examples:\n\nImplemented examples/cuda_pendulum_jit.py - complete pendulum swing-up example with matplotlib plotting.\nCreated include/mppi/jit/examples.hpp with example templates for common systems:\n\nPendulum dynamics and cost\nDouble integrator dynamics and cost\nCart-pole dynamics and cost\n\nCreated examples/JIT_EXAMPLES_README.md with comprehensive documentation.\nNote: Interactive pygame visualization can be added in future enhancement.\n\n\n\n\n\n\nNew Files:\n\ninclude/mppi/controllers/jit_mppi.hpp - JIT controller header\nsrc/jit/jit_mppi_controller.cpp - JIT controller implementation\ninclude/mppi/jit/examples.hpp - Example code templates\nexamples/cuda_pendulum_jit.py - Pendulum swing-up example\nexamples/JIT_EXAMPLES_README.md - JIT examples documentation\n\nModified Files:\n\nsrc/jit/jit_compiler.cpp - Updated wrapper generation for Driver API compatibility\nCMakeLists.txt - Added JIT sources to build\nbindings/bindings.cu - Added Python bindings for JITMPPIController\n\n\n\n\n\nfrom jax_mppi import cuda_mppi\nimport numpy as np\nimport os\n\n# Set include path\nos.environ['CUDA_MPPI_INCLUDE_DIR'] = '/path/to/src/cuda_mppi/include'\n\n# Configure MPPI\nconfig = cuda_mppi.MPPIConfig(\n    num_samples=1000,\n    horizon=50,\n    nx=2, nu=1,\n    lambda_=1.0,\n    dt=0.02,\n    u_scale=5.0,\n    w_action_seq_cost=0.0,\n    num_support_pts=10\n)\n\n# Define custom dynamics and cost\ndynamics_code = \"\"\"...\"\"\"  # See examples.hpp for templates\ncost_code = \"\"\"...\"\"\"\n\n# Create JIT controller (compilation happens here, ~1-5 seconds)\ncontroller = cuda_mppi.JITMPPIController(\n    config, dynamics_code, cost_code,\n    [os.environ['CUDA_MPPI_INCLUDE_DIR']]\n)\n\n# Use controller\nstate = np.array([1.0, 0.0], dtype=np.float32)\ncontroller.compute(state)\naction = controller.get_action()\ncontroller.shift()\n\n\n\n\n\nsrc/jax_mppi/*.py (Main reference for the MPPI Implementation)\n../MPPI-Generic (Reference for CUDA patterns)\nNVRTC Documentation"
  },
  {
    "objectID": "plan/completed/cuda_mppi_implementation.html#objective",
    "href": "plan/completed/cuda_mppi_implementation.html#objective",
    "title": "CUDA/C++ MPPI Implementation Plan",
    "section": "",
    "text": "Implement CUDA/C++ versions of MPPI, SMPPI, and KMPPI controllers within the src/cuda_mppi directory, using ../MPPI-Generic as a reference for high-performance CUDA implementation patterns."
  },
  {
    "objectID": "plan/completed/cuda_mppi_implementation.html#goals",
    "href": "plan/completed/cuda_mppi_implementation.html#goals",
    "title": "CUDA/C++ MPPI Implementation Plan",
    "section": "",
    "text": "Create a C++/CUDA project structure within src/cuda_mppi.\nImplement the standard MPPI algorithm (mirroring src/jax_mppi/mppi.py).\nImplement the Smooth MPPI (SMPPI) algorithm (mirroring src/jax_mppi/smppi.py).\nImplement the Kernel MPPI (KMPPI) algorithm (mirroring src/jax_mppi/kmppi.py).\nEnsure the implementations are self-contained or have clear interfaces (even if not fully hooked up to Python yet)."
  },
  {
    "objectID": "plan/completed/cuda_mppi_implementation.html#directory-structure",
    "href": "plan/completed/cuda_mppi_implementation.html#directory-structure",
    "title": "CUDA/C++ MPPI Implementation Plan",
    "section": "",
    "text": "We will create src/cuda_mppi with the following structure:\nsrc/cuda_mppi/\nâ”œâ”€â”€ CMakeLists.txt              # Build configuration\nâ”œâ”€â”€ include/\nâ”‚   â””â”€â”€ mppi/\nâ”‚       â”œâ”€â”€ controllers/\nâ”‚       â”‚   â”œâ”€â”€ mppi.cuh        # Standard MPPI header\nâ”‚       â”‚   â”œâ”€â”€ smppi.cuh       # Smooth MPPI header\nâ”‚       â”‚   â””â”€â”€ kmppi.cuh       # Kernel MPPI header\nâ”‚       â”œâ”€â”€ core/\nâ”‚       â”‚   â”œâ”€â”€ mppi_common.cuh # Common structures and utilities\nâ”‚       â”‚   â””â”€â”€ kernels.cuh     # Shared CUDA kernels (rollout, cost, etc.)\nâ”‚       â”œâ”€â”€ dynamics/\nâ”‚       â”‚   â””â”€â”€ dynamics.cuh    # Dynamics interface and base classes\nâ”‚       â”œâ”€â”€ costs/\nâ”‚       â”‚   â””â”€â”€ costs.cuh       # Cost function interface\nâ”‚       â””â”€â”€ utils/\nâ”‚           â””â”€â”€ cuda_utils.cuh  # CUDA helper functions\nâ””â”€â”€ src/\n    â”œâ”€â”€ controllers/\n    â”‚   â”œâ”€â”€ mppi.cu             # Standard MPPI implementation\n    â”‚   â”œâ”€â”€ smppi.cu            # Smooth MPPI implementation\n    â”‚   â””â”€â”€ kmppi.cu            # Kernel MPPI implementation\n    â”œâ”€â”€ core/\n    â”‚   â””â”€â”€ kernels.cu          # Kernel implementations\n    â””â”€â”€ utils/\n        â””â”€â”€ cuda_utils.cu       # Utility implementations"
  },
  {
    "objectID": "plan/completed/cuda_mppi_implementation.html#implementation-details",
    "href": "plan/completed/cuda_mppi_implementation.html#implementation-details",
    "title": "CUDA/C++ MPPI Implementation Plan",
    "section": "",
    "text": "mppi_common.cuh: Define data structures for state, configuration, and control sequences.\nkernels.cuh:\n\nrollout_kernel: Generic kernel to propagate dynamics and compute costs for \\(K\\) samples over \\(T\\) timesteps.\nreduce_cost_kernel: Kernel to compute weighted averages of trajectories.\n\n\n\n\n\n\nDefine template interfaces or base classes for Dynamics and RunningCost so that specific system models (like Quadrotor) can be plugged in.\nNote: Since we are focusing on the controllers, we will provide a simple example dynamics (e.g., Double Integrator or simple Quadrotor) to verify compilation, but the main focus is the controller logic.\n\n\n\n\n\n\n\nLogic:\n\nSample noise \\(\\epsilon \\sim \\mathcal{N}(0, \\Sigma)\\).\nCompute \\(u_{per} = u_{nom} + \\epsilon\\).\nRollout dynamics using \\(u_{per}\\).\nCompute costs \\(J(\\tau)\\).\nCompute weights \\(w \\propto \\exp(-J/\\lambda)\\).\nUpdate \\(u_{nom} \\leftarrow u_{nom} + \\sum w \\epsilon\\).\n\nCUDA: Use block-per-sample or thread-per-sample approach depending on horizon/state size. MPPI-Generic often uses block-y striding.\n\n\n\n\n\nLogic:\n\nSample noise in velocity space \\(\\delta v\\).\nIntegrate to get actions \\(u\\).\nAdd smoothness cost \\(\\sum (\\Delta u)^2\\).\nUpdate velocity sequence \\(v_{nom}\\).\n\nCUDA: Needs a kernel that handles the integration step (velocity -&gt; action) before the rollout.\n\n\n\n\n\nLogic:\n\nControl trajectory parameterized by control points \\(\\theta\\) and kernel \\(K(\\cdot, \\cdot)\\).\nSample noise on \\(\\theta\\).\nInterpolate \\(\\theta \\to u(t)\\).\nRollout.\nUpdate \\(\\theta\\).\n\nCUDA: Needs a kernel multiplication/interpolation step before rollout."
  },
  {
    "objectID": "plan/completed/cuda_mppi_implementation.html#execution-plan",
    "href": "plan/completed/cuda_mppi_implementation.html#execution-plan",
    "title": "CUDA/C++ MPPI Implementation Plan",
    "section": "",
    "text": "Setup: Create directory structure and CMakeLists.txt.\nCommon: Implement mppi_common.cuh and basic cuda_utils.cuh.\nDynamics/Cost: Define minimal interfaces.\nMPPI: Implement mppi.cuh and mppi.cu.\nSMPPI: Implement smppi.cuh and smppi.cu.\nKMPPI: Implement kmppi.cuh and kmppi.cu.\nVerification: Create a dummy main.cu to instantiate these controllers and verify they compile."
  },
  {
    "objectID": "plan/completed/cuda_mppi_implementation.html#python-integration-phase-2",
    "href": "plan/completed/cuda_mppi_implementation.html#python-integration-phase-2",
    "title": "CUDA/C++ MPPI Implementation Plan",
    "section": "",
    "text": "Expose the C++ MPPI controllers to Python to allow direct usage from the jax_mppi package, potentially replacing the JAX implementation for performance-critical sections.\n\n\n\n\nBinding Library: Use nanobind (efficient, small footprint) to create Python bindings for the C++ classes.\nData Transfer:\n\nBasic: Accept NumPy arrays (CPU) and copy to GPU in C++.\nAdvanced (Zero-Copy): Accept DLPack capsules (from jax.Array or torch.Tensor) to pass GPU pointers directly to the C++ controllers, avoiding CPU-GPU transfers.\n\n\n\n\n\n\nProject Config:\n\nUpdate pyproject.toml to support C++ extensions (e.g., using scikit-build-core).\nAdd dependencies: nanobind, scikit-build-core.\n\nBindings Code:\n\nCreate src/cuda_mppi/bindings/bindings.cpp.\nExpose MPPIConfig struct as a Python class.\nExpose MPPIController, SMPPIController, KMPPIController classes.\nBind methods like compute(state) and get_action().\nImplement type casters for Eigen::VectorXf &lt;-&gt; numpy.ndarray (using nanobind/eigen/dense.h).\n\nCMake Update:\n\nAdd nanobind_add_module target.\nLink against cuda_mppi and CUDA libraries.\n\nIntegration:\n\nCreate a Python wrapper module (e.g., jax_mppi.cuda) that imports the extension.\nAdd tests in tests/ to verify correctness against the JAX implementation."
  },
  {
    "objectID": "plan/completed/cuda_mppi_implementation.html#phase-3-runtime-dynamics-compilation-nvrtc",
    "href": "plan/completed/cuda_mppi_implementation.html#phase-3-runtime-dynamics-compilation-nvrtc",
    "title": "CUDA/C++ MPPI Implementation Plan",
    "section": "",
    "text": "Allow users to define dynamics and cost functions in Python (initially as C++ code strings, or eventually transpiled from JAX) and compile the specialized MPPI controller at runtime. This avoids the need to recompile the shared library for every new system.\n\n\n\n\nNVRTC (NVIDIA Runtime Compilation): Use NVRTC to compile CUDA C++ code strings into PTX at runtime.\nCUDA Driver API: Use the Driver API (cuModuleLoadData, cuLaunchKernel) to load the compiled PTX and launch the rollout_kernel.\nWarm Start: The compilation happens once during the â€œwarm startâ€ phase (controller initialization), enabling high-performance rollouts thereafter.\n\n\n\n\n\nBuild Config: Link against nvrtc and cuda (Driver API).\nJIT Compiler Class (src/cuda_mppi/include/mppi/jit/jit_compiler.hpp):\n\nInputs: Strings for dynamics_struct_code and cost_struct_code.\nAction: Constructs the full .cu source code (headers + user structs + template instantiation).\nOutput: Compiles to PTX using nvrtcProgramCompile.\nUpdated wrapper generation to work with Driver API.\n\nJIT Controller (JITMPPIController):\n\nA generic controller class that holds CUfunction handles instead of hardcoded kernels.\ncompute() method launches the generated kernel via cuLaunchKernel.\nImplemented in include/mppi/controllers/jit_mppi.hpp and src/jit/jit_mppi_controller.cpp.\n\nPython Interface:\n\nExpose JITMPPIController to Python via nanobind.\nExample usage:\ndynamics_code = \"\"\"\nstruct UserDynamics {\n    __device__ void step(...) { ... }\n};\n\"\"\"\ncost_code = \"\"\"\nstruct UserCost {\n    __device__ float compute(...) { ... }\n    __device__ float terminal_cost(...) { ... }\n};\n\"\"\"\ncontroller = cuda_mppi.JITMPPIController(config, dynamics_code, cost_code, include_paths)\n\nVerification & Examples:\n\nImplemented examples/cuda_pendulum_jit.py - complete pendulum swing-up example with matplotlib plotting.\nCreated include/mppi/jit/examples.hpp with example templates for common systems:\n\nPendulum dynamics and cost\nDouble integrator dynamics and cost\nCart-pole dynamics and cost\n\nCreated examples/JIT_EXAMPLES_README.md with comprehensive documentation.\nNote: Interactive pygame visualization can be added in future enhancement.\n\n\n\n\n\n\nNew Files:\n\ninclude/mppi/controllers/jit_mppi.hpp - JIT controller header\nsrc/jit/jit_mppi_controller.cpp - JIT controller implementation\ninclude/mppi/jit/examples.hpp - Example code templates\nexamples/cuda_pendulum_jit.py - Pendulum swing-up example\nexamples/JIT_EXAMPLES_README.md - JIT examples documentation\n\nModified Files:\n\nsrc/jit/jit_compiler.cpp - Updated wrapper generation for Driver API compatibility\nCMakeLists.txt - Added JIT sources to build\nbindings/bindings.cu - Added Python bindings for JITMPPIController\n\n\n\n\n\nfrom jax_mppi import cuda_mppi\nimport numpy as np\nimport os\n\n# Set include path\nos.environ['CUDA_MPPI_INCLUDE_DIR'] = '/path/to/src/cuda_mppi/include'\n\n# Configure MPPI\nconfig = cuda_mppi.MPPIConfig(\n    num_samples=1000,\n    horizon=50,\n    nx=2, nu=1,\n    lambda_=1.0,\n    dt=0.02,\n    u_scale=5.0,\n    w_action_seq_cost=0.0,\n    num_support_pts=10\n)\n\n# Define custom dynamics and cost\ndynamics_code = \"\"\"...\"\"\"  # See examples.hpp for templates\ncost_code = \"\"\"...\"\"\"\n\n# Create JIT controller (compilation happens here, ~1-5 seconds)\ncontroller = cuda_mppi.JITMPPIController(\n    config, dynamics_code, cost_code,\n    [os.environ['CUDA_MPPI_INCLUDE_DIR']]\n)\n\n# Use controller\nstate = np.array([1.0, 0.0], dtype=np.float32)\ncontroller.compute(state)\naction = controller.get_action()\ncontroller.shift()"
  },
  {
    "objectID": "plan/completed/cuda_mppi_implementation.html#references",
    "href": "plan/completed/cuda_mppi_implementation.html#references",
    "title": "CUDA/C++ MPPI Implementation Plan",
    "section": "",
    "text": "src/jax_mppi/*.py (Main reference for the MPPI Implementation)\n../MPPI-Generic (Reference for CUDA patterns)\nNVRTC Documentation"
  },
  {
    "objectID": "plan/completed/move_i_mppi_to_src.html",
    "href": "plan/completed/move_i_mppi_to_src.html",
    "title": "Move I-MPPI Modules Into src/jax_mppi",
    "section": "",
    "text": "Inspect existing I-MPPI module layout and all references.\nMove I-MPPI modules from examples/i_mppi_modules into src/jax_mppi.\nUpdate example imports to use the new package path.\nRun targeted tests/checks and verify imports."
  },
  {
    "objectID": "plan/completed/move_i_mppi_to_src.html#steps",
    "href": "plan/completed/move_i_mppi_to_src.html#steps",
    "title": "Move I-MPPI Modules Into src/jax_mppi",
    "section": "",
    "text": "Inspect existing I-MPPI module layout and all references.\nMove I-MPPI modules from examples/i_mppi_modules into src/jax_mppi.\nUpdate example imports to use the new package path.\nRun targeted tests/checks and verify imports."
  },
  {
    "objectID": "plan/performance_analysis.html",
    "href": "plan/performance_analysis.html",
    "title": "Performance Analysis of JAX-MPPI Autotuning",
    "section": "",
    "text": "This document outlines the performance bottlenecks and issues identified in the autotuning module of jax_mppi, specifically focusing on the evosax integration.\n\n\nThe primary reason why autotune_evosax.py does not achieve expected performance gains over cma (CPU-based) is a fundamental mismatch between the Autotune framework architecture and JAXâ€™s functional programming model.\n\nCurrent Architecture: The Autotune class and TunableParameter interface rely on a shared, mutable ConfigStateHolder. The evaluate_fn is a black-box function that relies on this side-effect-laden state update mechanism.\nImpact: This prevents vmap-ing the evaluation function over a population of parameters. JAX requires pure functions to parallelize execution. Because TunableParameter.apply_parameter_value modifies the global holder in-place, it cannot be safely used within a jax.vmap or jax.lax.scan context without significant refactoring.\n\n\n\n\nIn src/jax_mppi/autotune_evosax.py, the optimize_step method performs the following loop:\n# Evaluate all solutions sequentially\nresults = []\nfitness_values = []\n\nfor x in solutions:\n    result = self.evaluate_fn(np.array(x))  # type: ignore\n    results.append(result)\n    # ...\n\nIssue: The population generated by evosax (on GPU) is iterated over in Python. Each candidate solution is converted to a NumPy array, transferred to CPU, and evaluated individually.\nConsequence: This completely negates the massive parallelization advantage of JAX. Instead of running N simulations in parallel on the GPU, they are run sequentially (or with limited batching if evaluate_fn internally batches, but typically evaluate_fn runs one configuration).\nComparison: While cma is CPU-based and expects sequential/parallel CPU evaluation, evosax is designed to run the entire ask-evaluate-tell loop on the GPU. The current implementation uses evosax only for the â€œaskâ€ and â€œtellâ€ steps, leaving the most expensive part (evaluation) to a slow Python loop.\n\n\n\n\nThe interface forces repeated data movement between device and host:\n\nsolutions (from es.ask) are JAX arrays on GPU.\nnp.array(x) moves individual solution vectors to CPU.\nevaluate_fn likely uses JAX internally, so it might move data back to GPU for simulation.\nResults are moved back to CPU.\nfitness_array = jnp.array(fitness_values) moves costs back to GPU for es.tell.\n\n\n\n\nevosax allows for the entire optimization process (multiple generations) to be JIT-compiled using jax.lax.scan.\n\nCurrent State: optimize_step is a Python method that cannot be JIT-compiled because it calls the Python-based evaluate_fn loop.\nUnused Code: _create_jax_evaluate_fn exists in autotune_evosax.py but is not utilized effectively to enable JAX-pure evaluation.\n\n\n\n\nThe same sequential evaluation pattern is present in src/jax_mppi/autotune_qd.py:\nfor solution in solutions:\n    result = self.evaluate_fn(solution)\n    results.append(result)\nThis limits the scalability of the QD algorithms (CMA-ME), which typically benefit from large population sizes.\n\n\n\n\nHardcoded PRNG Key: EvoSaxOptimizer.setup_optimization resets the random key to jax.random.PRNGKey(0). This forces deterministic behavior that resets on every setup call, which might not be desired if the user wants to continue optimization or run multiple independent trials.\nType Hinting: Autotune.optimize_all is typed to return EvaluationResult, but can return None if iterations=0.\nUnused Variable: self.jax_evaluate_fn in EvoSaxOptimizer is assigned but never used.\n\n\n\n\n\nRefactor TunableParameter: Create a functional interface where parameters can be applied to a config/state to produce a new config/state without side effects.\nVectorized Evaluation: Update Autotune to support a batched_evaluate_fn that accepts a batch of parameters (JAX array) and returns a batch of costs.\nJIT-compile Loop: Once evaluation is vectorized and pure, use jax.lax.scan to run the optimization loop entirely on the GPU."
  },
  {
    "objectID": "plan/performance_analysis.html#architectural-bottleneck-stateful-vs-functional",
    "href": "plan/performance_analysis.html#architectural-bottleneck-stateful-vs-functional",
    "title": "Performance Analysis of JAX-MPPI Autotuning",
    "section": "",
    "text": "The primary reason why autotune_evosax.py does not achieve expected performance gains over cma (CPU-based) is a fundamental mismatch between the Autotune framework architecture and JAXâ€™s functional programming model.\n\nCurrent Architecture: The Autotune class and TunableParameter interface rely on a shared, mutable ConfigStateHolder. The evaluate_fn is a black-box function that relies on this side-effect-laden state update mechanism.\nImpact: This prevents vmap-ing the evaluation function over a population of parameters. JAX requires pure functions to parallelize execution. Because TunableParameter.apply_parameter_value modifies the global holder in-place, it cannot be safely used within a jax.vmap or jax.lax.scan context without significant refactoring."
  },
  {
    "objectID": "plan/performance_analysis.html#sequential-evaluation-in-evosax-optimization",
    "href": "plan/performance_analysis.html#sequential-evaluation-in-evosax-optimization",
    "title": "Performance Analysis of JAX-MPPI Autotuning",
    "section": "",
    "text": "In src/jax_mppi/autotune_evosax.py, the optimize_step method performs the following loop:\n# Evaluate all solutions sequentially\nresults = []\nfitness_values = []\n\nfor x in solutions:\n    result = self.evaluate_fn(np.array(x))  # type: ignore\n    results.append(result)\n    # ...\n\nIssue: The population generated by evosax (on GPU) is iterated over in Python. Each candidate solution is converted to a NumPy array, transferred to CPU, and evaluated individually.\nConsequence: This completely negates the massive parallelization advantage of JAX. Instead of running N simulations in parallel on the GPU, they are run sequentially (or with limited batching if evaluate_fn internally batches, but typically evaluate_fn runs one configuration).\nComparison: While cma is CPU-based and expects sequential/parallel CPU evaluation, evosax is designed to run the entire ask-evaluate-tell loop on the GPU. The current implementation uses evosax only for the â€œaskâ€ and â€œtellâ€ steps, leaving the most expensive part (evaluation) to a slow Python loop."
  },
  {
    "objectID": "plan/performance_analysis.html#data-transfer-overhead",
    "href": "plan/performance_analysis.html#data-transfer-overhead",
    "title": "Performance Analysis of JAX-MPPI Autotuning",
    "section": "",
    "text": "The interface forces repeated data movement between device and host:\n\nsolutions (from es.ask) are JAX arrays on GPU.\nnp.array(x) moves individual solution vectors to CPU.\nevaluate_fn likely uses JAX internally, so it might move data back to GPU for simulation.\nResults are moved back to CPU.\nfitness_array = jnp.array(fitness_values) moves costs back to GPU for es.tell."
  },
  {
    "objectID": "plan/performance_analysis.html#lack-of-end-to-end-jit-compilation",
    "href": "plan/performance_analysis.html#lack-of-end-to-end-jit-compilation",
    "title": "Performance Analysis of JAX-MPPI Autotuning",
    "section": "",
    "text": "evosax allows for the entire optimization process (multiple generations) to be JIT-compiled using jax.lax.scan.\n\nCurrent State: optimize_step is a Python method that cannot be JIT-compiled because it calls the Python-based evaluate_fn loop.\nUnused Code: _create_jax_evaluate_fn exists in autotune_evosax.py but is not utilized effectively to enable JAX-pure evaluation."
  },
  {
    "objectID": "plan/performance_analysis.html#issues-in-quality-diversity-qd-tuning",
    "href": "plan/performance_analysis.html#issues-in-quality-diversity-qd-tuning",
    "title": "Performance Analysis of JAX-MPPI Autotuning",
    "section": "",
    "text": "The same sequential evaluation pattern is present in src/jax_mppi/autotune_qd.py:\nfor solution in solutions:\n    result = self.evaluate_fn(solution)\n    results.append(result)\nThis limits the scalability of the QD algorithms (CMA-ME), which typically benefit from large population sizes."
  },
  {
    "objectID": "plan/performance_analysis.html#minor-issues",
    "href": "plan/performance_analysis.html#minor-issues",
    "title": "Performance Analysis of JAX-MPPI Autotuning",
    "section": "",
    "text": "Hardcoded PRNG Key: EvoSaxOptimizer.setup_optimization resets the random key to jax.random.PRNGKey(0). This forces deterministic behavior that resets on every setup call, which might not be desired if the user wants to continue optimization or run multiple independent trials.\nType Hinting: Autotune.optimize_all is typed to return EvaluationResult, but can return None if iterations=0.\nUnused Variable: self.jax_evaluate_fn in EvoSaxOptimizer is assigned but never used."
  },
  {
    "objectID": "plan/performance_analysis.html#recommendations-for-improvement",
    "href": "plan/performance_analysis.html#recommendations-for-improvement",
    "title": "Performance Analysis of JAX-MPPI Autotuning",
    "section": "",
    "text": "Refactor TunableParameter: Create a functional interface where parameters can be applied to a config/state to produce a new config/state without side effects.\nVectorized Evaluation: Update Autotune to support a batched_evaluate_fn that accepts a batch of parameters (JAX array) and returns a batch of costs.\nJIT-compile Loop: Once evaluation is vectorized and pure, use jax.lax.scan to run the optimization loop entirely on the GPU."
  },
  {
    "objectID": "plan/quadrotor_trajectory_following.html",
    "href": "plan/quadrotor_trajectory_following.html",
    "title": "Quadrotor Trajectory Following with MPPI",
    "section": "",
    "text": "Status: In Progress Branch: feat/quadrotor-traj-foll-example Created: 2026-02-01\n\n\nImplement a comprehensive set of examples demonstrating quadrotor trajectory following using MPPI control. The goal is to showcase the JAX-MPPI libraryâ€™s capabilities on a realistic robotic system with nonlinear dynamics and provide a reference implementation for users.\n\n\n\nThe current JAX-MPPI library includes:\n\nThree MPPI variants: standard MPPI, SMPPI (smooth), and KMPPI (kernel-based)\nExamples: inverted pendulum, 2D navigation with obstacles\nWell-structured functional API with JIT compilation support\nAutotuning infrastructure for hyperparameter optimization\n\nA quadrotor trajectory following example will:\n\nDemonstrate MPPI on a high-dimensional nonlinear system (13D state space)\nShowcase reference tracking capabilities\nProvide a realistic robotics benchmark\nEnable comparison between MPPI variants for trajectory smoothness\n\n\n\n\nThe quadrotor is modeled as a rigid body with 6 degrees of freedom. The state space is 13-dimensional, representing position, velocity, orientation (quaternion), and angular velocity.\nFrame Conventions:\n\nNED (North-East-Down): Global/world frame where Z-axis points down (gravity is positive Z)\nFRD (Forward-Right-Down): Body frame where X-axis points forward, Y-axis points right, Z-axis points down\n\n\n\nThe state vector \\(\\mathbf{x} \\in \\mathbb{R}^{13}\\) is defined as:\n[ = [^T, ^T, ^T, ^T]^T ]\nwhere:\n\n\\(\\mathbf{p} = [p_x, p_y, p_z]^T\\) is the position in the NED world frame.\n\\(\\mathbf{v} = [v_x, v_y, v_z]^T\\) is the linear velocity in the NED world frame.\n\\(\\mathbf{q} = [q_w, q_x, q_y, q_z]^T\\) is the unit quaternion representing orientation (body FRD to world NED).\n\\(\\boldsymbol{\\omega} = [\\omega_x, \\omega_y, \\omega_z]^T\\) is the angular velocity in the FRD body frame.\n\nThe control input \\(\\mathbf{u} \\in \\mathbb{R}^{4}\\) consists of the total thrust and body angular rates:\n[ = [T, {x,cmd}, {y,cmd}, _{z,cmd}]^T ]\n\n\n\nThe system dynamics are governed by the following equations:\n\n\n[ = ]\n\n\n\n[ = + R()\n\\[\\begin{bmatrix} 0 \\\\ 0 \\\\ -T \\end{bmatrix}\\]\n]\nwhere \\(\\mathbf{g} = [0, 0, g]^T\\) is the gravity vector in NED frame (positive down), \\(m\\) is the mass, \\(T\\) is the thrust magnitude (positive), and \\(R(\\mathbf{q})\\) is the rotation matrix from FRD body frame to NED world frame. The thrust vector in body frame is \\([0, 0, -T]^T\\) (upward thrust is negative Z in FRD).\n\n\n\nThe time derivative of the quaternion is given by:\n[ =\n\\[\\begin{bmatrix} 0 \\\\ \\boldsymbol{\\omega} \\end{bmatrix}\\]\n]\nwhere \\(\\otimes\\) denotes quaternion multiplication. In matrix form involving the skew-symmetric matrix\n[ = () ]\nNote: The implementation must ensure \\(\\|\\mathbf{q}\\| = 1\\), typically by normalization after integration.\n\n\n\n[ = (_{cmd} - ) ]\nwhere \\(\\tau_\\omega\\) is the time constant for the angular velocity tracking.\n\n\n\n\nThe MPPI controller optimizes a cost function \\(J\\) over a horizon \\(H\\). The instantaneous cost \\(C(\\mathbf{x}_t, \\mathbf{u}_t)\\) is defined as\n[ C(t, t) = |t - {ref,t}|{Q{pos}}^2 + |t - {ref,t}|{Q{vel}}^2 + |t|{R}^2 ]\nwhere \\(\\|\\mathbf{z}\\|_W^2 = \\mathbf{z}^T W \\mathbf{z}\\).\n\n\n\n\n\n\n\n\n\n6-DOF rigid body dynamics\nState representation: position (3D), velocity (3D), orientation (quaternion), angular velocity (3D) = 13D\nControl inputs: body thrust + body rates (roll, pitch, yaw rates)\nPhysical parameters: mass, inertia matrix, arm length\nFull nonlinear dynamics with quaternion-based attitude representation\n\n\n\n\n\nMultiple reference trajectory types:\n\nCircular/helical trajectories\nLemniscate (figure-8) trajectories\nMinimum snap polynomial trajectories\nWaypoint-based trajectories\n\nTime-parameterized trajectories with position, velocity, acceleration references\n\n\n\n\n\nPosition tracking error (weighted L2 norm)\nVelocity tracking error\nAttitude tracking error (quaternion distance: 1 - |q^T q_ref|)\nControl effort penalty (R matrix on actions)\nTrajectory smoothness penalty (action rate limiting)\nTerminal cost for goal convergence\n\n\n\n\n\nExample 1: Basic hover control (stabilization around setpoint)\nExample 2: Circular trajectory following\nExample 3: Figure-8 trajectory with MPPI/SMPPI/KMPPI comparison\nExample 4: Minimum snap trajectory following\nExample 5: Obstacle avoidance during trajectory following (stretch goal)\n\n\n\n\n\n3D trajectory plots (reference vs actual)\nTracking error over time\nControl inputs over time\nEnergy consumption\nOptional: animated 3D quadrotor visualization\n\n\n\n\n\n\nPerformance: JIT-compiled control loops running at &gt;100 Hz on CPU\nCode Quality: Follow existing examples pattern (pendulum.py structure)\nDocumentation: Clear docstrings, inline comments for dynamics equations\nTesting: Unit tests for dynamics, cost functions, and integration tests\n\n\n\n\n\n\n\n\n\nstate = [\n    px, py, pz,        # position (3)\n    vx, vy, vz,        # velocity (3)\n    qw, qx, qy, qz,    # quaternion (4) - unit norm constraint\n    wx, wy, wz         # angular velocity in body frame (3)\n]\n\n\n\n\nQuaternions avoid gimbal lock singularities present in Euler angle representations\nMore numerically stable for aggressive maneuvers\nStandard representation in modern quadrotor control literature\nUnit norm constraint: ||q|| = 1 (enforced after integration)\n\n\n\n\n\n\n\naction = [\n    T,              # total thrust magnitude (N) - [0, max_thrust]\n                    # Acts in -Z direction of FRD body frame (upward)\n    wx_cmd,         # roll rate command (rad/s) - body X-axis (FRD forward)\n    wy_cmd,         # pitch rate command (rad/s) - body Y-axis (FRD right)\n    wz_cmd          # yaw rate command (rad/s) - body Z-axis (FRD down)\n]\n\n\n\n\nDirect control of thrust and angular velocities\nEasier to enforce control bounds than motor-level commands\nMore intuitive for trajectory tracking\nStandard in many quadrotor control frameworks\nFRD body frame convention: thrust acts in -Z direction (upward)\n\n\n\n\n\nImplement a modular dynamics function following the libraryâ€™s pattern:\ndef quadrotor_dynamics(\n    state: jax.Array,\n    action: jax.Array,\n    dt: float = 0.01,\n    mass: float = 1.0,\n    inertia: jax.Array = jnp.eye(3) * 0.1,\n    gravity: float = 9.81,\n    tau_omega: float = 0.05  # angular velocity time constant\n) -&gt; jax.Array:\n    \"\"\"\n    6-DOF quadrotor dynamics with quaternion representation.\n    Frame conventions: NED (world), FRD (body)\n\n    State: [px, py, pz, vx, vy, vz, qw, qx, qy, qz, wx, wy, wz] (13D)\n    - Position/velocity in NED world frame\n    - Quaternion: body FRD to world NED\n    - Angular velocity in FRD body frame\n\n    Action: [T, wx_cmd, wy_cmd, wz_cmd] (4D)\n    - T: thrust magnitude (positive, acts in -Z body direction)\n    - w_cmd: angular rate commands in FRD body frame\n\n    Returns: next_state after dt using RK4 integration\n    \"\"\"\n    # Extract state components\n    pos = state[0:3]\n    vel = state[3:6]\n    quat = state[6:10]  # [qw, qx, qy, qz]\n    omega = state[10:13]  # angular velocity in FRD body frame\n\n    # Extract control\n    thrust = action[0]  # positive magnitude\n    omega_cmd = action[1:4]\n\n    # Rotation matrix from FRD body to NED world frame\n    R = quaternion_to_rotation_matrix(quat)\n\n    # Translational dynamics (NED world frame)\n    # Gravity: positive Z in NED (downward)\n    f_gravity = jnp.array([0, 0, mass * gravity])\n    # Thrust in body frame: [0, 0, -T] (upward in FRD)\n    # Transform to world frame\n    f_thrust = R @ jnp.array([0, 0, -thrust])\n    accel = (f_gravity + f_thrust) / mass\n\n    # Rotational dynamics (FRD body frame, first-order model)\n    # For more realism, can use: omega_dot = inv(I) @ (torque - omega x (I @ omega))\n    omega_dot = (omega_cmd - omega) / tau_omega\n\n    # Quaternion kinematics: q_dot = 0.5 * Omega(omega) @ q\n    # where Omega(omega) is the skew-symmetric matrix\n    q_dot = 0.5 * jnp.array([\n        -omega[0]*quat[1] - omega[1]*quat[2] - omega[2]*quat[3],  # qw_dot\n         omega[0]*quat[0] + omega[2]*quat[2] - omega[1]*quat[3],  # qx_dot\n         omega[1]*quat[0] - omega[2]*quat[1] + omega[0]*quat[3],  # qy_dot\n         omega[2]*quat[0] + omega[1]*quat[1] - omega[0]*quat[2]   # qz_dot\n    ])\n\n    # State derivative\n    state_dot = jnp.concatenate([vel, accel, q_dot, omega_dot])\n\n    # Integration (can use RK4 for better accuracy)\n    next_state = state + dt * state_dot\n\n    # Normalize quaternion to maintain unit norm\n    next_quat = next_state[6:10]\n    next_quat = next_quat / jnp.linalg.norm(next_quat)\n    next_state = next_state.at[6:10].set(next_quat)\n\n    return next_state\n\n\n\nFrame Conventions: NED world frame, FRD body frame\nGravity: Acts in +Z direction in NED (down is positive)\nThrust: Magnitude T (positive) acts in -Z direction in FRD (upward)\nQuaternion normalization after integration is critical\nRK4 integration recommended for better accuracy\nFirst-order model for angular velocity (can be extended to full Euler dynamics)\n\n\n\n\n\n\n\ndef trajectory_running_cost(\n    state: jax.Array,\n    action: jax.Array,\n    reference: jax.Array,\n    t: int,\n    Q_pos: jax.Array,\n    Q_vel: jax.Array,\n    Q_att: jax.Array,\n    R: jax.Array\n) -&gt; float:\n    \"\"\"\n    Trajectory tracking cost with control penalty.\n\n    reference: [px_ref, py_ref, pz_ref, vx_ref, vy_ref, vz_ref, ...]\n    \"\"\"\n    # Extract reference for current time step\n    ref_t = reference[t]  # or interpolate\n\n    # Position tracking error\n    pos_error = state[0:3] - ref_t[0:3]\n    cost_pos = pos_error.T @ Q_pos @ pos_error\n\n    # Velocity tracking error\n    vel_error = state[3:6] - ref_t[3:6]\n    cost_vel = vel_error.T @ Q_vel @ vel_error\n\n    # Attitude tracking (optional)\n    # att_error = ...\n    # cost_att = att_error.T @ Q_att @ att_error\n\n    # Control effort\n    cost_control = action.T @ R @ action\n\n    return cost_pos + cost_vel + cost_control\n\n\n\ndef trajectory_terminal_cost(\n    state: jax.Array,\n    last_action: jax.Array,\n    goal: jax.Array,\n    Q_terminal: jax.Array\n) -&gt; float:\n    \"\"\"Terminal cost for reaching goal state.\"\"\"\n    error = state - goal\n    return error.T @ Q_terminal @ error\n\n\n\n\nImplement modular trajectory generators:\ndef generate_circle_trajectory(\n    radius: float,\n    height: float,\n    period: float,\n    num_steps: int,\n    dt: float\n) -&gt; jax.Array:\n    \"\"\"\n    Generate circular trajectory in NED frame.\n    \n    Args:\n        radius: Circle radius in xy plane (m)\n        height: Altitude in NED frame (positive down, e.g., -5.0 for 5m above ground)\n        period: Period of one revolution (s)\n        num_steps: Number of trajectory points\n        dt: Time step (s)\n    \"\"\"\n    t = jnp.arange(num_steps) * dt\n    omega = 2 * jnp.pi / period\n\n    x = radius * jnp.cos(omega * t)\n    y = radius * jnp.sin(omega * t)\n    z = jnp.ones_like(t) * height  # NED: positive down\n\n    vx = -radius * omega * jnp.sin(omega * t)\n    vy = radius * omega * jnp.cos(omega * t)\n    vz = jnp.zeros_like(t)\n\n    # Stack into trajectory array\n    trajectory = jnp.stack([x, y, z, vx, vy, vz], axis=1)\n    return trajectory\n\n\ndef generate_lemniscate_trajectory(\n    scale: float,\n    height: float,\n    period: float,\n    num_steps: int,\n    dt: float\n) -&gt; jax.Array:\n    \"\"\"\n    Generate figure-8 (lemniscate) trajectory in NED frame.\n    \n    Args:\n        scale: Size of the figure-8 (m)\n        height: Altitude in NED frame (positive down, e.g., -5.0 for 5m above ground)\n        period: Period of one complete figure-8 (s)\n        num_steps: Number of trajectory points\n        dt: Time step (s)\n    \"\"\"\n    t = jnp.arange(num_steps) * dt\n    omega = 2 * jnp.pi / period\n\n    # Lemniscate of Gerono\n    x = scale * jnp.sin(omega * t)\n    y = scale * jnp.sin(omega * t) * jnp.cos(omega * t)\n    z = jnp.ones_like(t) * height  # NED: positive down\n\n    # Velocities (derivatives)\n    vx = scale * omega * jnp.cos(omega * t)\n    vy = scale * omega * (jnp.cos(omega * t)**2 - jnp.sin(omega * t)**2)\n    vz = jnp.zeros_like(t)\n\n    trajectory = jnp.stack([x, y, z, vx, vy, vz], axis=1)\n    return trajectory\n\n\n\n\n\n\n\nExplore existing codebase\nCreate feature branch feat/quadrotor-traj-foll-example\nDraft implementation plan\nImplement quadrotor dynamics module (src/jax_mppi/dynamics/quadrotor.py)\n\nQuaternion utilities (to rotation matrix, normalization, etc.)\nQuaternion kinematics\n6-DOF dynamics with RK4 integration\nUnit tests for dynamics (quaternion norm preservation, energy conservation)\n\nImplement trajectory cost functions (src/jax_mppi/costs/quadrotor.py)\n\nPosition/velocity tracking cost\nQuaternion-based attitude tracking cost\nTerminal cost\nUnit tests for costs\n\n\n\n\n\n\nCreate trajectory generation utilities (examples/quadrotor/trajectories.py)\n\nCircular trajectory\nFigure-8 (lemniscate) trajectory\nHover setpoint\nHelix trajectory (bonus)\nWaypoint interpolation with cubic Hermite splines\nTrajectory metrics computation\n\nUnit tests for trajectory generators (28 tests, all passing)\n\n\n\n\n\nExample 1: Hover control (examples/quadrotor_hover.py)\n\nStabilization around fixed setpoint\nVisualization of state vs time\nPerformance metrics (settling time, overshoot)\n\nExample 2: Circle following (examples/quadrotor_circle.py)\n\nCircular trajectory tracking\nTracking error visualization\nControl input visualization\n3D trajectory plotting\n\nIntegration tests (11 tests covering both examples)\n\n\n\n\n\nExample 3: Figure-8 comparison (examples/quadrotor_figure8_comparison.py)\n\nMPPI vs SMPPI vs KMPPI comparison\nSmoothness metrics (control rate, jerk)\nEnergy consumption comparison\nSide-by-side trajectory plots (6 subplots)\nComprehensive performance comparison table\n\nExample 4: Custom trajectory (examples/quadrotor_custom_trajectory.py)\n\nWaypoint-based trajectories with cubic Hermite interpolation\nUser-defined reference trajectories\nWaypoint passage verification\nCommand-line waypoint parsing\n\nIntegration tests (13 tests for advanced examples)\n\n\n\n\n\nAdd comprehensive docstrings\nCreate README for quadrotor examples (examples/quadrotor/README.md)\nAdd theory documentation (docs/examples/quadrotor.md)\nIntegration tests\nPerformance benchmarks\nUpdate main README with quadrotor examples\n\n\n\n\n\nObstacle avoidance during trajectory following\nFull Euler dynamics for rotational motion (torque-based control)\nMotor-level control (PWM to thrust mapping)\nWind disturbance modeling\nAutotuning example for quadrotor MPPI hyperparameters\nReal-time visualization with animation\nROS integration example\n\n\n\n\n\njax_mppi/\nâ”œâ”€â”€ src/jax_mppi/\nâ”‚   â”œâ”€â”€ dynamics/\nâ”‚   â”‚   â”œâ”€â”€ __init__.py\nâ”‚   â”‚   â”œâ”€â”€ linear.py\nâ”‚   â”‚   â””â”€â”€ quadrotor.py         # NEW: Quadrotor dynamics\nâ”‚   â”œâ”€â”€ costs/\nâ”‚   â”‚   â”œâ”€â”€ __init__.py\nâ”‚   â”‚   â”œâ”€â”€ basic.py\nâ”‚   â”‚   â””â”€â”€ quadrotor.py         # NEW: Quadrotor-specific costs\nâ”‚   â””â”€â”€ ...\nâ”œâ”€â”€ examples/\nâ”‚   â”œâ”€â”€ pendulum.py\nâ”‚   â”œâ”€â”€ smooth_comparison.py\nâ”‚   â”œâ”€â”€ quadrotor/               # NEW: Quadrotor examples directory\nâ”‚   â”‚   â”œâ”€â”€ __init__.py\nâ”‚   â”‚   â”œâ”€â”€ trajectories.py      # NEW: Trajectory generators\nâ”‚   â”‚   â”œâ”€â”€ plotting.py          # NEW: Visualization utilities\nâ”‚   â”‚   â””â”€â”€ README.md            # NEW: Quadrotor examples guide\nâ”‚   â”œâ”€â”€ quadrotor_hover.py       # NEW: Example 1\nâ”‚   â”œâ”€â”€ quadrotor_circle.py      # NEW: Example 2\nâ”‚   â”œâ”€â”€ quadrotor_figure8_comparison.py  # NEW: Example 3\nâ”‚   â””â”€â”€ quadrotor_custom_trajectory.py   # NEW: Example 4\nâ”œâ”€â”€ tests/\nâ”‚   â”œâ”€â”€ test_quadrotor_dynamics.py  # NEW\nâ”‚   â”œâ”€â”€ test_quadrotor_costs.py     # NEW\nâ”‚   â””â”€â”€ test_quadrotor_examples.py  # NEW\nâ””â”€â”€ docs/\n    â”œâ”€â”€ plan/\n    â”‚   â””â”€â”€ quadrotor_trajectory_following.md  # This file\n    â””â”€â”€ examples/\n        â””â”€â”€ quadrotor.md         # NEW: Theory and usage guide\n\n\n\n\nFunctionality: All examples run without errors and demonstrate trajectory following\nPerformance: Control loops run at &gt;100 Hz on CPU (JIT-compiled)\nAccuracy: Tracking error &lt;5% of trajectory scale for well-tuned parameters\nCode Quality: Follows existing code style, comprehensive tests (&gt;80% coverage)\nDocumentation: Clear README, docstrings, and theory documentation\nUsability: New users can run examples out-of-the-box with minimal setup\n\n\n\n\n\n\n\nDynamics model: verify state evolution, energy conservation\nCost functions: verify gradient correctness, cost bounds\nTrajectory generators: verify continuity, derivative correctness\n\n\n\n\n\nEnd-to-end MPPI control loop with quadrotor\nJIT compilation compatibility\nBatch rollout generation for visualization\n\n\n\n\n\nBenchmark control loop frequency\nMemory usage profiling\nComparison with baseline implementations\n\n\n\n\n\n\n\n\n\n\n\n\n\nRisk\nImpact\nMitigation\n\n\n\n\nDynamics too complex for real-time control\nHigh\nProfile performance early, optimize JIT compilation\n\n\nQuaternion norm drift during integration\nMedium\nNormalize after each integration step\n\n\nPoor tracking performance\nMedium\nImplement autotuning example, provide tuning guidelines\n\n\nIntegration complexity\nLow\nFollow existing example patterns closely\n\n\n\n\n\n\n\nJAX (already required)\nmatplotlib (for visualization, already used in examples)\nscipy (optional, for minimum snap trajectories)\nAll dependencies should be compatible with existing pyproject.toml\n\n\n\n\n\n[1] Williams, G., et al.Â â€œInformation theoretic MPC for model-based reinforcement learning.â€ ICRA 2017.\n[2] Williams, G., et al.Â â€œModel predictive path integral control using covariance variable importance sampling.â€ arXiv:1509.01149, 2015.\n[3] Beard, R. W., & McLain, T. W. â€œSmall Unmanned Aircraft: Theory and Practice.â€ Princeton University Press, 2012.\n[4] Mellinger, D., & Kumar, V. â€œMinimum snap trajectory generation and control for quadrotors.â€ ICRA 2011.\n[5] pytorch_mppi original implementation\n\n\n\n\n\nThis plan should be updated as implementation progresses\nMove to docs/plan/completed/ when all phases are finished\nLink any related issues or PRs here\n\n\n\nNED-FRD Convention:\n\nNED (North-East-Down): World/global frame\n\nX: North, Y: East, Z: Down (positive downward)\nGravity: g = [0, 0, +9.81] m/sÂ² (positive Z direction)\n\nFRD (Forward-Right-Down): Body frame\n\nX: Forward, Y: Right, Z: Down (positive downward)\nThrust: T acts in -Z direction (upward thrust)\nAngular rates: [Ï‰x, Ï‰y, Ï‰z] about [Forward, Right, Down] axes\n\n\nImportant Implementation Details:\n\nAltitude: Negative values indicate height above ground (e.g., z = -5.0 means 5m altitude)\nThrust: Positive magnitude T, applied as [0, 0, -T] in body frame\nRotation matrix R(q): transforms from FRD body to NED world\n\n\n\n\n\n\n\n\nCompleted:\n\nImplemented src/jax_mppi/dynamics/quadrotor.py with full 6-DOF quadrotor dynamics\n\nQuaternion utilities: rotation matrix conversion, normalization, multiplication\nRK4 integration for accurate numerical integration\nFirst-order angular velocity tracking model\nNED-FRD frame conventions properly implemented\nControl bounds enforcement\n\nImplemented src/jax_mppi/costs/quadrotor.py with comprehensive cost functions\n\nTrajectory tracking cost (position + velocity)\nTime-indexed trajectory cost\nHover control cost (with attitude tracking)\nTerminal cost for goal reaching\nQuaternion distance metric\n\nComprehensive test coverage (40 tests, all passing)\n\ntests/test_quadrotor_dynamics.py (19 tests)\ntests/test_quadrotor_costs.py (21 tests)\nTests verify: quaternion math, dynamics correctness, JIT compatibility, gradients\n\n\nKey Features:\n\nAll functions are JIT-compatible for high performance\nGradients work correctly through all dynamics and cost functions\nQuaternion norm preservation verified during integration\nPhysical behaviors validated (gravity, thrust, angular tracking)\n\nNext Steps:\n\nPhase 2: Trajectory generators (circle, figure-8, hover setpoint)\n\n\n\n\nCompleted:\n\nImplemented examples/quadrotor/trajectories.py with comprehensive trajectory generators\n\ngenerate_hover_setpoint() - Constant position stabilization\ngenerate_circle_trajectory() - Circular paths with configurable center and phase\ngenerate_lemniscate_trajectory() - Figure-8 patterns (horizontal or vertical)\ngenerate_helix_trajectory() - Spiral paths with vertical motion\ngenerate_waypoint_trajectory() - Smooth cubic Hermite interpolation through waypoints\ncompute_trajectory_metrics() - Analyze distance, velocity, acceleration\n\nComprehensive test coverage (28 tests, all passing)\n\nTests verify: trajectory shapes, periodicity, continuity\nValidates velocity/position relationships\nChecks metric computation accuracy\n\n\nKey Features:\n\nAll trajectories follow NED frame convention\nAnalytical derivatives for velocity (no numerical differentiation)\nConfigurable parameters (center, phase, duration, dt)\nSupport for both horizontal and vertical figure-8 patterns\n\nNext Steps:\n\nPhase 3: Basic examples (hover control, circle following)\n\n\n\n\nCompleted:\n\nImplemented examples/quadrotor_hover.py - Hover control stabilization\n\nMPPI-based hover controller with position and attitude tracking\nPerformance metrics (settling time, position/velocity error)\nComprehensive visualization (9 subplots: position, velocity, angular velocity, control inputs, errors, cost)\nCommand-line interface with configurable parameters\n\nImplemented examples/quadrotor_circle.py - Circular trajectory tracking\n\nTime-varying reference tracking using trajectory generators\n3D trajectory visualization with top-view projection\nTracking error analysis and metrics\nConfigurable circle parameters (radius, period)\n\nIntegration tests (11 tests)\n\nExample execution tests\nConvergence validation\nQuaternion norm preservation\nCost decrease verification\nCross-example compatibility checks\n\n\nKey Features:\n\nBoth examples run at 50 Hz control rate (JIT-compiled)\nDetailed visualizations saved to docs/media/\nProper NED frame convention throughout\nPerformance metrics automatically computed and reported\n\nNext Steps:\n\nPhase 4: Advanced examples (figure-8 comparison, custom trajectories)\n\n\n\n\nCompleted:\n\nImplemented examples/quadrotor_figure8_comparison.py - MPPI variant comparison\n\nSide-by-side comparison of MPPI, SMPPI, and KMPPI on aggressive figure-8\nComprehensive metrics: tracking accuracy, control smoothness, energy consumption\nSmoothness metrics: control rate (acceleration) and jerk analysis\n6-subplot visualization comparing all three variants\nPerformance comparison table with 7 key metrics\nDemonstrates trade-offs between tracking accuracy and control smoothness\n\nImplemented examples/quadrotor_custom_trajectory.py - Waypoint following\n\nUser-defined waypoint trajectories with smooth interpolation\nCubic Hermite splines for C1 continuity\nWaypoint passage verification and error reporting\nCommand-line interface for custom waypoint specification\n6-subplot visualization including waypoint markers\nDefault square pattern demonstration\n\nIntegration tests (13 tests)\n\nFigure-8 comparison execution and metrics validation\nCustom trajectory with various waypoint configurations\nQuaternion normalization across all controllers\nFinite value checks for all outputs\n\n\nKey Features:\n\nFigure-8 example shows SMPPI produces smoother control (lower jerk)\nCustom trajectory allows arbitrary waypoint sequences\nAll examples maintain 50 Hz control rate\nPublication-quality comparison visualizations\n\nNext Steps:\n\nPhase 5: Documentation and polish\n\n\nLast Updated: 2026-02-02 Author: riccardo-enr"
  },
  {
    "objectID": "plan/quadrotor_trajectory_following.html#objective",
    "href": "plan/quadrotor_trajectory_following.html#objective",
    "title": "Quadrotor Trajectory Following with MPPI",
    "section": "",
    "text": "Implement a comprehensive set of examples demonstrating quadrotor trajectory following using MPPI control. The goal is to showcase the JAX-MPPI libraryâ€™s capabilities on a realistic robotic system with nonlinear dynamics and provide a reference implementation for users."
  },
  {
    "objectID": "plan/quadrotor_trajectory_following.html#background",
    "href": "plan/quadrotor_trajectory_following.html#background",
    "title": "Quadrotor Trajectory Following with MPPI",
    "section": "",
    "text": "The current JAX-MPPI library includes:\n\nThree MPPI variants: standard MPPI, SMPPI (smooth), and KMPPI (kernel-based)\nExamples: inverted pendulum, 2D navigation with obstacles\nWell-structured functional API with JIT compilation support\nAutotuning infrastructure for hyperparameter optimization\n\nA quadrotor trajectory following example will:\n\nDemonstrate MPPI on a high-dimensional nonlinear system (13D state space)\nShowcase reference tracking capabilities\nProvide a realistic robotics benchmark\nEnable comparison between MPPI variants for trajectory smoothness"
  },
  {
    "objectID": "plan/quadrotor_trajectory_following.html#theoretical-background",
    "href": "plan/quadrotor_trajectory_following.html#theoretical-background",
    "title": "Quadrotor Trajectory Following with MPPI",
    "section": "",
    "text": "The quadrotor is modeled as a rigid body with 6 degrees of freedom. The state space is 13-dimensional, representing position, velocity, orientation (quaternion), and angular velocity.\nFrame Conventions:\n\nNED (North-East-Down): Global/world frame where Z-axis points down (gravity is positive Z)\nFRD (Forward-Right-Down): Body frame where X-axis points forward, Y-axis points right, Z-axis points down\n\n\n\nThe state vector \\(\\mathbf{x} \\in \\mathbb{R}^{13}\\) is defined as:\n[ = [^T, ^T, ^T, ^T]^T ]\nwhere:\n\n\\(\\mathbf{p} = [p_x, p_y, p_z]^T\\) is the position in the NED world frame.\n\\(\\mathbf{v} = [v_x, v_y, v_z]^T\\) is the linear velocity in the NED world frame.\n\\(\\mathbf{q} = [q_w, q_x, q_y, q_z]^T\\) is the unit quaternion representing orientation (body FRD to world NED).\n\\(\\boldsymbol{\\omega} = [\\omega_x, \\omega_y, \\omega_z]^T\\) is the angular velocity in the FRD body frame.\n\nThe control input \\(\\mathbf{u} \\in \\mathbb{R}^{4}\\) consists of the total thrust and body angular rates:\n[ = [T, {x,cmd}, {y,cmd}, _{z,cmd}]^T ]\n\n\n\nThe system dynamics are governed by the following equations:\n\n\n[ = ]\n\n\n\n[ = + R()\n\\[\\begin{bmatrix} 0 \\\\ 0 \\\\ -T \\end{bmatrix}\\]\n]\nwhere \\(\\mathbf{g} = [0, 0, g]^T\\) is the gravity vector in NED frame (positive down), \\(m\\) is the mass, \\(T\\) is the thrust magnitude (positive), and \\(R(\\mathbf{q})\\) is the rotation matrix from FRD body frame to NED world frame. The thrust vector in body frame is \\([0, 0, -T]^T\\) (upward thrust is negative Z in FRD).\n\n\n\nThe time derivative of the quaternion is given by:\n[ =\n\\[\\begin{bmatrix} 0 \\\\ \\boldsymbol{\\omega} \\end{bmatrix}\\]\n]\nwhere \\(\\otimes\\) denotes quaternion multiplication. In matrix form involving the skew-symmetric matrix\n[ = () ]\nNote: The implementation must ensure \\(\\|\\mathbf{q}\\| = 1\\), typically by normalization after integration.\n\n\n\n[ = (_{cmd} - ) ]\nwhere \\(\\tau_\\omega\\) is the time constant for the angular velocity tracking.\n\n\n\n\nThe MPPI controller optimizes a cost function \\(J\\) over a horizon \\(H\\). The instantaneous cost \\(C(\\mathbf{x}_t, \\mathbf{u}_t)\\) is defined as\n[ C(t, t) = |t - {ref,t}|{Q{pos}}^2 + |t - {ref,t}|{Q{vel}}^2 + |t|{R}^2 ]\nwhere \\(\\|\\mathbf{z}\\|_W^2 = \\mathbf{z}^T W \\mathbf{z}\\)."
  },
  {
    "objectID": "plan/quadrotor_trajectory_following.html#requirements",
    "href": "plan/quadrotor_trajectory_following.html#requirements",
    "title": "Quadrotor Trajectory Following with MPPI",
    "section": "",
    "text": "6-DOF rigid body dynamics\nState representation: position (3D), velocity (3D), orientation (quaternion), angular velocity (3D) = 13D\nControl inputs: body thrust + body rates (roll, pitch, yaw rates)\nPhysical parameters: mass, inertia matrix, arm length\nFull nonlinear dynamics with quaternion-based attitude representation\n\n\n\n\n\nMultiple reference trajectory types:\n\nCircular/helical trajectories\nLemniscate (figure-8) trajectories\nMinimum snap polynomial trajectories\nWaypoint-based trajectories\n\nTime-parameterized trajectories with position, velocity, acceleration references\n\n\n\n\n\nPosition tracking error (weighted L2 norm)\nVelocity tracking error\nAttitude tracking error (quaternion distance: 1 - |q^T q_ref|)\nControl effort penalty (R matrix on actions)\nTrajectory smoothness penalty (action rate limiting)\nTerminal cost for goal convergence\n\n\n\n\n\nExample 1: Basic hover control (stabilization around setpoint)\nExample 2: Circular trajectory following\nExample 3: Figure-8 trajectory with MPPI/SMPPI/KMPPI comparison\nExample 4: Minimum snap trajectory following\nExample 5: Obstacle avoidance during trajectory following (stretch goal)\n\n\n\n\n\n3D trajectory plots (reference vs actual)\nTracking error over time\nControl inputs over time\nEnergy consumption\nOptional: animated 3D quadrotor visualization\n\n\n\n\n\n\nPerformance: JIT-compiled control loops running at &gt;100 Hz on CPU\nCode Quality: Follow existing examples pattern (pendulum.py structure)\nDocumentation: Clear docstrings, inline comments for dynamics equations\nTesting: Unit tests for dynamics, cost functions, and integration tests"
  },
  {
    "objectID": "plan/quadrotor_trajectory_following.html#technical-design",
    "href": "plan/quadrotor_trajectory_following.html#technical-design",
    "title": "Quadrotor Trajectory Following with MPPI",
    "section": "",
    "text": "state = [\n    px, py, pz,        # position (3)\n    vx, vy, vz,        # velocity (3)\n    qw, qx, qy, qz,    # quaternion (4) - unit norm constraint\n    wx, wy, wz         # angular velocity in body frame (3)\n]\n\n\n\n\nQuaternions avoid gimbal lock singularities present in Euler angle representations\nMore numerically stable for aggressive maneuvers\nStandard representation in modern quadrotor control literature\nUnit norm constraint: ||q|| = 1 (enforced after integration)\n\n\n\n\n\n\n\naction = [\n    T,              # total thrust magnitude (N) - [0, max_thrust]\n                    # Acts in -Z direction of FRD body frame (upward)\n    wx_cmd,         # roll rate command (rad/s) - body X-axis (FRD forward)\n    wy_cmd,         # pitch rate command (rad/s) - body Y-axis (FRD right)\n    wz_cmd          # yaw rate command (rad/s) - body Z-axis (FRD down)\n]\n\n\n\n\nDirect control of thrust and angular velocities\nEasier to enforce control bounds than motor-level commands\nMore intuitive for trajectory tracking\nStandard in many quadrotor control frameworks\nFRD body frame convention: thrust acts in -Z direction (upward)\n\n\n\n\n\nImplement a modular dynamics function following the libraryâ€™s pattern:\ndef quadrotor_dynamics(\n    state: jax.Array,\n    action: jax.Array,\n    dt: float = 0.01,\n    mass: float = 1.0,\n    inertia: jax.Array = jnp.eye(3) * 0.1,\n    gravity: float = 9.81,\n    tau_omega: float = 0.05  # angular velocity time constant\n) -&gt; jax.Array:\n    \"\"\"\n    6-DOF quadrotor dynamics with quaternion representation.\n    Frame conventions: NED (world), FRD (body)\n\n    State: [px, py, pz, vx, vy, vz, qw, qx, qy, qz, wx, wy, wz] (13D)\n    - Position/velocity in NED world frame\n    - Quaternion: body FRD to world NED\n    - Angular velocity in FRD body frame\n\n    Action: [T, wx_cmd, wy_cmd, wz_cmd] (4D)\n    - T: thrust magnitude (positive, acts in -Z body direction)\n    - w_cmd: angular rate commands in FRD body frame\n\n    Returns: next_state after dt using RK4 integration\n    \"\"\"\n    # Extract state components\n    pos = state[0:3]\n    vel = state[3:6]\n    quat = state[6:10]  # [qw, qx, qy, qz]\n    omega = state[10:13]  # angular velocity in FRD body frame\n\n    # Extract control\n    thrust = action[0]  # positive magnitude\n    omega_cmd = action[1:4]\n\n    # Rotation matrix from FRD body to NED world frame\n    R = quaternion_to_rotation_matrix(quat)\n\n    # Translational dynamics (NED world frame)\n    # Gravity: positive Z in NED (downward)\n    f_gravity = jnp.array([0, 0, mass * gravity])\n    # Thrust in body frame: [0, 0, -T] (upward in FRD)\n    # Transform to world frame\n    f_thrust = R @ jnp.array([0, 0, -thrust])\n    accel = (f_gravity + f_thrust) / mass\n\n    # Rotational dynamics (FRD body frame, first-order model)\n    # For more realism, can use: omega_dot = inv(I) @ (torque - omega x (I @ omega))\n    omega_dot = (omega_cmd - omega) / tau_omega\n\n    # Quaternion kinematics: q_dot = 0.5 * Omega(omega) @ q\n    # where Omega(omega) is the skew-symmetric matrix\n    q_dot = 0.5 * jnp.array([\n        -omega[0]*quat[1] - omega[1]*quat[2] - omega[2]*quat[3],  # qw_dot\n         omega[0]*quat[0] + omega[2]*quat[2] - omega[1]*quat[3],  # qx_dot\n         omega[1]*quat[0] - omega[2]*quat[1] + omega[0]*quat[3],  # qy_dot\n         omega[2]*quat[0] + omega[1]*quat[1] - omega[0]*quat[2]   # qz_dot\n    ])\n\n    # State derivative\n    state_dot = jnp.concatenate([vel, accel, q_dot, omega_dot])\n\n    # Integration (can use RK4 for better accuracy)\n    next_state = state + dt * state_dot\n\n    # Normalize quaternion to maintain unit norm\n    next_quat = next_state[6:10]\n    next_quat = next_quat / jnp.linalg.norm(next_quat)\n    next_state = next_state.at[6:10].set(next_quat)\n\n    return next_state\n\n\n\nFrame Conventions: NED world frame, FRD body frame\nGravity: Acts in +Z direction in NED (down is positive)\nThrust: Magnitude T (positive) acts in -Z direction in FRD (upward)\nQuaternion normalization after integration is critical\nRK4 integration recommended for better accuracy\nFirst-order model for angular velocity (can be extended to full Euler dynamics)\n\n\n\n\n\n\n\ndef trajectory_running_cost(\n    state: jax.Array,\n    action: jax.Array,\n    reference: jax.Array,\n    t: int,\n    Q_pos: jax.Array,\n    Q_vel: jax.Array,\n    Q_att: jax.Array,\n    R: jax.Array\n) -&gt; float:\n    \"\"\"\n    Trajectory tracking cost with control penalty.\n\n    reference: [px_ref, py_ref, pz_ref, vx_ref, vy_ref, vz_ref, ...]\n    \"\"\"\n    # Extract reference for current time step\n    ref_t = reference[t]  # or interpolate\n\n    # Position tracking error\n    pos_error = state[0:3] - ref_t[0:3]\n    cost_pos = pos_error.T @ Q_pos @ pos_error\n\n    # Velocity tracking error\n    vel_error = state[3:6] - ref_t[3:6]\n    cost_vel = vel_error.T @ Q_vel @ vel_error\n\n    # Attitude tracking (optional)\n    # att_error = ...\n    # cost_att = att_error.T @ Q_att @ att_error\n\n    # Control effort\n    cost_control = action.T @ R @ action\n\n    return cost_pos + cost_vel + cost_control\n\n\n\ndef trajectory_terminal_cost(\n    state: jax.Array,\n    last_action: jax.Array,\n    goal: jax.Array,\n    Q_terminal: jax.Array\n) -&gt; float:\n    \"\"\"Terminal cost for reaching goal state.\"\"\"\n    error = state - goal\n    return error.T @ Q_terminal @ error\n\n\n\n\nImplement modular trajectory generators:\ndef generate_circle_trajectory(\n    radius: float,\n    height: float,\n    period: float,\n    num_steps: int,\n    dt: float\n) -&gt; jax.Array:\n    \"\"\"\n    Generate circular trajectory in NED frame.\n    \n    Args:\n        radius: Circle radius in xy plane (m)\n        height: Altitude in NED frame (positive down, e.g., -5.0 for 5m above ground)\n        period: Period of one revolution (s)\n        num_steps: Number of trajectory points\n        dt: Time step (s)\n    \"\"\"\n    t = jnp.arange(num_steps) * dt\n    omega = 2 * jnp.pi / period\n\n    x = radius * jnp.cos(omega * t)\n    y = radius * jnp.sin(omega * t)\n    z = jnp.ones_like(t) * height  # NED: positive down\n\n    vx = -radius * omega * jnp.sin(omega * t)\n    vy = radius * omega * jnp.cos(omega * t)\n    vz = jnp.zeros_like(t)\n\n    # Stack into trajectory array\n    trajectory = jnp.stack([x, y, z, vx, vy, vz], axis=1)\n    return trajectory\n\n\ndef generate_lemniscate_trajectory(\n    scale: float,\n    height: float,\n    period: float,\n    num_steps: int,\n    dt: float\n) -&gt; jax.Array:\n    \"\"\"\n    Generate figure-8 (lemniscate) trajectory in NED frame.\n    \n    Args:\n        scale: Size of the figure-8 (m)\n        height: Altitude in NED frame (positive down, e.g., -5.0 for 5m above ground)\n        period: Period of one complete figure-8 (s)\n        num_steps: Number of trajectory points\n        dt: Time step (s)\n    \"\"\"\n    t = jnp.arange(num_steps) * dt\n    omega = 2 * jnp.pi / period\n\n    # Lemniscate of Gerono\n    x = scale * jnp.sin(omega * t)\n    y = scale * jnp.sin(omega * t) * jnp.cos(omega * t)\n    z = jnp.ones_like(t) * height  # NED: positive down\n\n    # Velocities (derivatives)\n    vx = scale * omega * jnp.cos(omega * t)\n    vy = scale * omega * (jnp.cos(omega * t)**2 - jnp.sin(omega * t)**2)\n    vz = jnp.zeros_like(t)\n\n    trajectory = jnp.stack([x, y, z, vx, vy, vz], axis=1)\n    return trajectory"
  },
  {
    "objectID": "plan/quadrotor_trajectory_following.html#implementation-plan",
    "href": "plan/quadrotor_trajectory_following.html#implementation-plan",
    "title": "Quadrotor Trajectory Following with MPPI",
    "section": "",
    "text": "Explore existing codebase\nCreate feature branch feat/quadrotor-traj-foll-example\nDraft implementation plan\nImplement quadrotor dynamics module (src/jax_mppi/dynamics/quadrotor.py)\n\nQuaternion utilities (to rotation matrix, normalization, etc.)\nQuaternion kinematics\n6-DOF dynamics with RK4 integration\nUnit tests for dynamics (quaternion norm preservation, energy conservation)\n\nImplement trajectory cost functions (src/jax_mppi/costs/quadrotor.py)\n\nPosition/velocity tracking cost\nQuaternion-based attitude tracking cost\nTerminal cost\nUnit tests for costs\n\n\n\n\n\n\nCreate trajectory generation utilities (examples/quadrotor/trajectories.py)\n\nCircular trajectory\nFigure-8 (lemniscate) trajectory\nHover setpoint\nHelix trajectory (bonus)\nWaypoint interpolation with cubic Hermite splines\nTrajectory metrics computation\n\nUnit tests for trajectory generators (28 tests, all passing)\n\n\n\n\n\nExample 1: Hover control (examples/quadrotor_hover.py)\n\nStabilization around fixed setpoint\nVisualization of state vs time\nPerformance metrics (settling time, overshoot)\n\nExample 2: Circle following (examples/quadrotor_circle.py)\n\nCircular trajectory tracking\nTracking error visualization\nControl input visualization\n3D trajectory plotting\n\nIntegration tests (11 tests covering both examples)\n\n\n\n\n\nExample 3: Figure-8 comparison (examples/quadrotor_figure8_comparison.py)\n\nMPPI vs SMPPI vs KMPPI comparison\nSmoothness metrics (control rate, jerk)\nEnergy consumption comparison\nSide-by-side trajectory plots (6 subplots)\nComprehensive performance comparison table\n\nExample 4: Custom trajectory (examples/quadrotor_custom_trajectory.py)\n\nWaypoint-based trajectories with cubic Hermite interpolation\nUser-defined reference trajectories\nWaypoint passage verification\nCommand-line waypoint parsing\n\nIntegration tests (13 tests for advanced examples)\n\n\n\n\n\nAdd comprehensive docstrings\nCreate README for quadrotor examples (examples/quadrotor/README.md)\nAdd theory documentation (docs/examples/quadrotor.md)\nIntegration tests\nPerformance benchmarks\nUpdate main README with quadrotor examples\n\n\n\n\n\nObstacle avoidance during trajectory following\nFull Euler dynamics for rotational motion (torque-based control)\nMotor-level control (PWM to thrust mapping)\nWind disturbance modeling\nAutotuning example for quadrotor MPPI hyperparameters\nReal-time visualization with animation\nROS integration example"
  },
  {
    "objectID": "plan/quadrotor_trajectory_following.html#file-structure",
    "href": "plan/quadrotor_trajectory_following.html#file-structure",
    "title": "Quadrotor Trajectory Following with MPPI",
    "section": "",
    "text": "jax_mppi/\nâ”œâ”€â”€ src/jax_mppi/\nâ”‚   â”œâ”€â”€ dynamics/\nâ”‚   â”‚   â”œâ”€â”€ __init__.py\nâ”‚   â”‚   â”œâ”€â”€ linear.py\nâ”‚   â”‚   â””â”€â”€ quadrotor.py         # NEW: Quadrotor dynamics\nâ”‚   â”œâ”€â”€ costs/\nâ”‚   â”‚   â”œâ”€â”€ __init__.py\nâ”‚   â”‚   â”œâ”€â”€ basic.py\nâ”‚   â”‚   â””â”€â”€ quadrotor.py         # NEW: Quadrotor-specific costs\nâ”‚   â””â”€â”€ ...\nâ”œâ”€â”€ examples/\nâ”‚   â”œâ”€â”€ pendulum.py\nâ”‚   â”œâ”€â”€ smooth_comparison.py\nâ”‚   â”œâ”€â”€ quadrotor/               # NEW: Quadrotor examples directory\nâ”‚   â”‚   â”œâ”€â”€ __init__.py\nâ”‚   â”‚   â”œâ”€â”€ trajectories.py      # NEW: Trajectory generators\nâ”‚   â”‚   â”œâ”€â”€ plotting.py          # NEW: Visualization utilities\nâ”‚   â”‚   â””â”€â”€ README.md            # NEW: Quadrotor examples guide\nâ”‚   â”œâ”€â”€ quadrotor_hover.py       # NEW: Example 1\nâ”‚   â”œâ”€â”€ quadrotor_circle.py      # NEW: Example 2\nâ”‚   â”œâ”€â”€ quadrotor_figure8_comparison.py  # NEW: Example 3\nâ”‚   â””â”€â”€ quadrotor_custom_trajectory.py   # NEW: Example 4\nâ”œâ”€â”€ tests/\nâ”‚   â”œâ”€â”€ test_quadrotor_dynamics.py  # NEW\nâ”‚   â”œâ”€â”€ test_quadrotor_costs.py     # NEW\nâ”‚   â””â”€â”€ test_quadrotor_examples.py  # NEW\nâ””â”€â”€ docs/\n    â”œâ”€â”€ plan/\n    â”‚   â””â”€â”€ quadrotor_trajectory_following.md  # This file\n    â””â”€â”€ examples/\n        â””â”€â”€ quadrotor.md         # NEW: Theory and usage guide"
  },
  {
    "objectID": "plan/quadrotor_trajectory_following.html#success-criteria",
    "href": "plan/quadrotor_trajectory_following.html#success-criteria",
    "title": "Quadrotor Trajectory Following with MPPI",
    "section": "",
    "text": "Functionality: All examples run without errors and demonstrate trajectory following\nPerformance: Control loops run at &gt;100 Hz on CPU (JIT-compiled)\nAccuracy: Tracking error &lt;5% of trajectory scale for well-tuned parameters\nCode Quality: Follows existing code style, comprehensive tests (&gt;80% coverage)\nDocumentation: Clear README, docstrings, and theory documentation\nUsability: New users can run examples out-of-the-box with minimal setup"
  },
  {
    "objectID": "plan/quadrotor_trajectory_following.html#testing-strategy",
    "href": "plan/quadrotor_trajectory_following.html#testing-strategy",
    "title": "Quadrotor Trajectory Following with MPPI",
    "section": "",
    "text": "Dynamics model: verify state evolution, energy conservation\nCost functions: verify gradient correctness, cost bounds\nTrajectory generators: verify continuity, derivative correctness\n\n\n\n\n\nEnd-to-end MPPI control loop with quadrotor\nJIT compilation compatibility\nBatch rollout generation for visualization\n\n\n\n\n\nBenchmark control loop frequency\nMemory usage profiling\nComparison with baseline implementations"
  },
  {
    "objectID": "plan/quadrotor_trajectory_following.html#risk-mitigation",
    "href": "plan/quadrotor_trajectory_following.html#risk-mitigation",
    "title": "Quadrotor Trajectory Following with MPPI",
    "section": "",
    "text": "Risk\nImpact\nMitigation\n\n\n\n\nDynamics too complex for real-time control\nHigh\nProfile performance early, optimize JIT compilation\n\n\nQuaternion norm drift during integration\nMedium\nNormalize after each integration step\n\n\nPoor tracking performance\nMedium\nImplement autotuning example, provide tuning guidelines\n\n\nIntegration complexity\nLow\nFollow existing example patterns closely"
  },
  {
    "objectID": "plan/quadrotor_trajectory_following.html#dependencies",
    "href": "plan/quadrotor_trajectory_following.html#dependencies",
    "title": "Quadrotor Trajectory Following with MPPI",
    "section": "",
    "text": "JAX (already required)\nmatplotlib (for visualization, already used in examples)\nscipy (optional, for minimum snap trajectories)\nAll dependencies should be compatible with existing pyproject.toml"
  },
  {
    "objectID": "plan/quadrotor_trajectory_following.html#references",
    "href": "plan/quadrotor_trajectory_following.html#references",
    "title": "Quadrotor Trajectory Following with MPPI",
    "section": "",
    "text": "[1] Williams, G., et al.Â â€œInformation theoretic MPC for model-based reinforcement learning.â€ ICRA 2017.\n[2] Williams, G., et al.Â â€œModel predictive path integral control using covariance variable importance sampling.â€ arXiv:1509.01149, 2015.\n[3] Beard, R. W., & McLain, T. W. â€œSmall Unmanned Aircraft: Theory and Practice.â€ Princeton University Press, 2012.\n[4] Mellinger, D., & Kumar, V. â€œMinimum snap trajectory generation and control for quadrotors.â€ ICRA 2011.\n[5] pytorch_mppi original implementation"
  },
  {
    "objectID": "plan/quadrotor_trajectory_following.html#notes",
    "href": "plan/quadrotor_trajectory_following.html#notes",
    "title": "Quadrotor Trajectory Following with MPPI",
    "section": "",
    "text": "This plan should be updated as implementation progresses\nMove to docs/plan/completed/ when all phases are finished\nLink any related issues or PRs here\n\n\n\nNED-FRD Convention:\n\nNED (North-East-Down): World/global frame\n\nX: North, Y: East, Z: Down (positive downward)\nGravity: g = [0, 0, +9.81] m/sÂ² (positive Z direction)\n\nFRD (Forward-Right-Down): Body frame\n\nX: Forward, Y: Right, Z: Down (positive downward)\nThrust: T acts in -Z direction (upward thrust)\nAngular rates: [Ï‰x, Ï‰y, Ï‰z] about [Forward, Right, Down] axes\n\n\nImportant Implementation Details:\n\nAltitude: Negative values indicate height above ground (e.g., z = -5.0 means 5m altitude)\nThrust: Positive magnitude T, applied as [0, 0, -T] in body frame\nRotation matrix R(q): transforms from FRD body to NED world"
  },
  {
    "objectID": "plan/quadrotor_trajectory_following.html#progress-log",
    "href": "plan/quadrotor_trajectory_following.html#progress-log",
    "title": "Quadrotor Trajectory Following with MPPI",
    "section": "",
    "text": "Completed:\n\nImplemented src/jax_mppi/dynamics/quadrotor.py with full 6-DOF quadrotor dynamics\n\nQuaternion utilities: rotation matrix conversion, normalization, multiplication\nRK4 integration for accurate numerical integration\nFirst-order angular velocity tracking model\nNED-FRD frame conventions properly implemented\nControl bounds enforcement\n\nImplemented src/jax_mppi/costs/quadrotor.py with comprehensive cost functions\n\nTrajectory tracking cost (position + velocity)\nTime-indexed trajectory cost\nHover control cost (with attitude tracking)\nTerminal cost for goal reaching\nQuaternion distance metric\n\nComprehensive test coverage (40 tests, all passing)\n\ntests/test_quadrotor_dynamics.py (19 tests)\ntests/test_quadrotor_costs.py (21 tests)\nTests verify: quaternion math, dynamics correctness, JIT compatibility, gradients\n\n\nKey Features:\n\nAll functions are JIT-compatible for high performance\nGradients work correctly through all dynamics and cost functions\nQuaternion norm preservation verified during integration\nPhysical behaviors validated (gravity, thrust, angular tracking)\n\nNext Steps:\n\nPhase 2: Trajectory generators (circle, figure-8, hover setpoint)\n\n\n\n\nCompleted:\n\nImplemented examples/quadrotor/trajectories.py with comprehensive trajectory generators\n\ngenerate_hover_setpoint() - Constant position stabilization\ngenerate_circle_trajectory() - Circular paths with configurable center and phase\ngenerate_lemniscate_trajectory() - Figure-8 patterns (horizontal or vertical)\ngenerate_helix_trajectory() - Spiral paths with vertical motion\ngenerate_waypoint_trajectory() - Smooth cubic Hermite interpolation through waypoints\ncompute_trajectory_metrics() - Analyze distance, velocity, acceleration\n\nComprehensive test coverage (28 tests, all passing)\n\nTests verify: trajectory shapes, periodicity, continuity\nValidates velocity/position relationships\nChecks metric computation accuracy\n\n\nKey Features:\n\nAll trajectories follow NED frame convention\nAnalytical derivatives for velocity (no numerical differentiation)\nConfigurable parameters (center, phase, duration, dt)\nSupport for both horizontal and vertical figure-8 patterns\n\nNext Steps:\n\nPhase 3: Basic examples (hover control, circle following)\n\n\n\n\nCompleted:\n\nImplemented examples/quadrotor_hover.py - Hover control stabilization\n\nMPPI-based hover controller with position and attitude tracking\nPerformance metrics (settling time, position/velocity error)\nComprehensive visualization (9 subplots: position, velocity, angular velocity, control inputs, errors, cost)\nCommand-line interface with configurable parameters\n\nImplemented examples/quadrotor_circle.py - Circular trajectory tracking\n\nTime-varying reference tracking using trajectory generators\n3D trajectory visualization with top-view projection\nTracking error analysis and metrics\nConfigurable circle parameters (radius, period)\n\nIntegration tests (11 tests)\n\nExample execution tests\nConvergence validation\nQuaternion norm preservation\nCost decrease verification\nCross-example compatibility checks\n\n\nKey Features:\n\nBoth examples run at 50 Hz control rate (JIT-compiled)\nDetailed visualizations saved to docs/media/\nProper NED frame convention throughout\nPerformance metrics automatically computed and reported\n\nNext Steps:\n\nPhase 4: Advanced examples (figure-8 comparison, custom trajectories)\n\n\n\n\nCompleted:\n\nImplemented examples/quadrotor_figure8_comparison.py - MPPI variant comparison\n\nSide-by-side comparison of MPPI, SMPPI, and KMPPI on aggressive figure-8\nComprehensive metrics: tracking accuracy, control smoothness, energy consumption\nSmoothness metrics: control rate (acceleration) and jerk analysis\n6-subplot visualization comparing all three variants\nPerformance comparison table with 7 key metrics\nDemonstrates trade-offs between tracking accuracy and control smoothness\n\nImplemented examples/quadrotor_custom_trajectory.py - Waypoint following\n\nUser-defined waypoint trajectories with smooth interpolation\nCubic Hermite splines for C1 continuity\nWaypoint passage verification and error reporting\nCommand-line interface for custom waypoint specification\n6-subplot visualization including waypoint markers\nDefault square pattern demonstration\n\nIntegration tests (13 tests)\n\nFigure-8 comparison execution and metrics validation\nCustom trajectory with various waypoint configurations\nQuaternion normalization across all controllers\nFinite value checks for all outputs\n\n\nKey Features:\n\nFigure-8 example shows SMPPI produces smoother control (lower jerk)\nCustom trajectory allows arbitrary waypoint sequences\nAll examples maintain 50 Hz control rate\nPublication-quality comparison visualizations\n\nNext Steps:\n\nPhase 5: Documentation and polish\n\n\nLast Updated: 2026-02-02 Author: riccardo-enr"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "jax_mppi",
    "section": "",
    "text": "Open In Colab\n\n\njax_mppi is a functional, JIT-compilable port of the pytorch_mppi library to JAX. It implements Model Predictive Path Integral (MPPI) control with a focus on performance and composability.\n\n\nThis library embraces JAXâ€™s functional paradigm:\n\nPure Functions: Core logic is implemented as pure functions command(state, mppi_state) -&gt; (action, mppi_state).\nDataclass State: State is held in jax.tree_util.register_dataclass containers, allowing easy integration with jit, vmap, and grad.\nNo Side Effects: Unlike the PyTorch version, there is no mutable self. State transitions are explicit.\n\n\n\n\n\nCore MPPI: Robust implementation of the standard MPPI algorithm.\nSmooth MPPI (SMPPI): Maintains action sequences and smoothness costs for better trajectory generation.\nKernel MPPI (KMPPI): Uses kernel interpolation for control points, reducing the parameter space.\nAutotuning: Built-in hyperparameter optimization using CMA-ES, Ray Tune, and Quality Diversity.\nCUDA/C++ Backend: High-performance implementations of all controllers in CUDA/C++17, exposed to Python via `nanobind`.\nJAX Integration:\n\njax.vmap for efficient batch processing.\njax.lax.scan for fast horizon loops.\nFully compatible with JIT compilation for high-performance control loops.\n\n\n\n\n\n# Clone the repository\ngit clone https://github.com/yourusername/jax_mppi.git\ncd jax_mppi\n\n# Install dependencies\npip install -e .\n\n\n\nimport jax\nimport jax.numpy as jnp\nfrom jax_mppi import mppi\n\n# Define dynamics and cost functions\ndef dynamics(state, action):\n    # Your dynamics model here\n    return state + action\n\ndef running_cost(state, action):\n    # Your cost function here\n    return jnp.sum(state**2) + jnp.sum(action**2)\n\n# Create configuration and initial state\nconfig, mppi_state = mppi.create(\n    nx=4, nu=2,\n    noise_sigma=jnp.eye(2) * 0.1,\n    horizon=20,\n    lambda_=1.0\n)\n\n# Control loop\nkey = jax.random.PRNGKey(0)\ncurrent_obs = jnp.zeros(4)\n\n# JIT compile the command function for performance\njitted_command = jax.jit(mppi.command, static_argnames=['dynamics', 'running_cost'])\n\nfor _ in range(100):\n    key, subkey = jax.random.split(key)\n    action, mppi_state = jitted_command(\n        config,\n        mppi_state,\n        current_obs,\n        dynamics=dynamics,\n        running_cost=running_cost\n    )\n    # Apply action to environment...\n\n\n\njax_mppi/\nâ”œâ”€â”€ src/jax_mppi/\nâ”‚   â”œâ”€â”€ mppi.py              # Core MPPI implementation\nâ”‚   â”œâ”€â”€ smppi.py             # Smooth MPPI variant\nâ”‚   â”œâ”€â”€ kmppi.py             # Kernel MPPI variant\nâ”‚   â”œâ”€â”€ types.py             # Type definitions\nâ”‚   â”œâ”€â”€ autotune.py          # Autotuning core & CMA-ES\nâ”‚   â”œâ”€â”€ autotune_global.py   # Ray Tune integration\nâ”‚   â””â”€â”€ autotune_qd.py       # Quality Diversity optimization\nâ”œâ”€â”€ examples/\nâ”‚   â”œâ”€â”€ pendulum.py          # Pendulum environment example\nâ”‚   â”œâ”€â”€ autotune_basic.py    # Basic autotuning example\nâ”‚   â”œâ”€â”€ autotune_pendulum.py # Autotuning pendulum\nâ”‚   â””â”€â”€ smooth_comparison.py # Comparison of MPPI variants\nâ””â”€â”€ tests/                   # Unit and integration tests\n\n\n\nThe development is structured in phases:\n\nCore MPPI: Basic implementation with JAX parity.\nIntegration: Pendulum example and verification.\nSmooth MPPI: Implementation of smoothness constraints.\nKernel MPPI: Kernel-based control parameterization.\nComparisons: Benchmarking and visual comparisons.\nAutotuning: Parameter optimization using CMA-ES, Ray Tune, and QD.\n\n\n\n\nThis project is a direct port of pytorch_mppi. We aim to maintain parity with the original implementation while leveraging JAXâ€™s unique features for performance and flexibility.\n\n\n\n\nPorting Plan\nEvosax Integration Plan\nCUDA MPPI Implementation Plan",
    "crumbs": [
      "Home",
      "Introduction",
      "jax_mppi"
    ]
  },
  {
    "objectID": "index.html#design-philosophy",
    "href": "index.html#design-philosophy",
    "title": "jax_mppi",
    "section": "",
    "text": "This library embraces JAXâ€™s functional paradigm:\n\nPure Functions: Core logic is implemented as pure functions command(state, mppi_state) -&gt; (action, mppi_state).\nDataclass State: State is held in jax.tree_util.register_dataclass containers, allowing easy integration with jit, vmap, and grad.\nNo Side Effects: Unlike the PyTorch version, there is no mutable self. State transitions are explicit.",
    "crumbs": [
      "Home",
      "Introduction",
      "jax_mppi"
    ]
  },
  {
    "objectID": "index.html#key-features",
    "href": "index.html#key-features",
    "title": "jax_mppi",
    "section": "",
    "text": "Core MPPI: Robust implementation of the standard MPPI algorithm.\nSmooth MPPI (SMPPI): Maintains action sequences and smoothness costs for better trajectory generation.\nKernel MPPI (KMPPI): Uses kernel interpolation for control points, reducing the parameter space.\nAutotuning: Built-in hyperparameter optimization using CMA-ES, Ray Tune, and Quality Diversity.\nCUDA/C++ Backend: High-performance implementations of all controllers in CUDA/C++17, exposed to Python via `nanobind`.\nJAX Integration:\n\njax.vmap for efficient batch processing.\njax.lax.scan for fast horizon loops.\nFully compatible with JIT compilation for high-performance control loops.",
    "crumbs": [
      "Home",
      "Introduction",
      "jax_mppi"
    ]
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "jax_mppi",
    "section": "",
    "text": "# Clone the repository\ngit clone https://github.com/yourusername/jax_mppi.git\ncd jax_mppi\n\n# Install dependencies\npip install -e .",
    "crumbs": [
      "Home",
      "Introduction",
      "jax_mppi"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "jax_mppi",
    "section": "",
    "text": "import jax\nimport jax.numpy as jnp\nfrom jax_mppi import mppi\n\n# Define dynamics and cost functions\ndef dynamics(state, action):\n    # Your dynamics model here\n    return state + action\n\ndef running_cost(state, action):\n    # Your cost function here\n    return jnp.sum(state**2) + jnp.sum(action**2)\n\n# Create configuration and initial state\nconfig, mppi_state = mppi.create(\n    nx=4, nu=2,\n    noise_sigma=jnp.eye(2) * 0.1,\n    horizon=20,\n    lambda_=1.0\n)\n\n# Control loop\nkey = jax.random.PRNGKey(0)\ncurrent_obs = jnp.zeros(4)\n\n# JIT compile the command function for performance\njitted_command = jax.jit(mppi.command, static_argnames=['dynamics', 'running_cost'])\n\nfor _ in range(100):\n    key, subkey = jax.random.split(key)\n    action, mppi_state = jitted_command(\n        config,\n        mppi_state,\n        current_obs,\n        dynamics=dynamics,\n        running_cost=running_cost\n    )\n    # Apply action to environment...",
    "crumbs": [
      "Home",
      "Introduction",
      "jax_mppi"
    ]
  },
  {
    "objectID": "index.html#project-structure",
    "href": "index.html#project-structure",
    "title": "jax_mppi",
    "section": "",
    "text": "jax_mppi/\nâ”œâ”€â”€ src/jax_mppi/\nâ”‚   â”œâ”€â”€ mppi.py              # Core MPPI implementation\nâ”‚   â”œâ”€â”€ smppi.py             # Smooth MPPI variant\nâ”‚   â”œâ”€â”€ kmppi.py             # Kernel MPPI variant\nâ”‚   â”œâ”€â”€ types.py             # Type definitions\nâ”‚   â”œâ”€â”€ autotune.py          # Autotuning core & CMA-ES\nâ”‚   â”œâ”€â”€ autotune_global.py   # Ray Tune integration\nâ”‚   â””â”€â”€ autotune_qd.py       # Quality Diversity optimization\nâ”œâ”€â”€ examples/\nâ”‚   â”œâ”€â”€ pendulum.py          # Pendulum environment example\nâ”‚   â”œâ”€â”€ autotune_basic.py    # Basic autotuning example\nâ”‚   â”œâ”€â”€ autotune_pendulum.py # Autotuning pendulum\nâ”‚   â””â”€â”€ smooth_comparison.py # Comparison of MPPI variants\nâ””â”€â”€ tests/                   # Unit and integration tests",
    "crumbs": [
      "Home",
      "Introduction",
      "jax_mppi"
    ]
  },
  {
    "objectID": "index.html#roadmap",
    "href": "index.html#roadmap",
    "title": "jax_mppi",
    "section": "",
    "text": "The development is structured in phases:\n\nCore MPPI: Basic implementation with JAX parity.\nIntegration: Pendulum example and verification.\nSmooth MPPI: Implementation of smoothness constraints.\nKernel MPPI: Kernel-based control parameterization.\nComparisons: Benchmarking and visual comparisons.\nAutotuning: Parameter optimization using CMA-ES, Ray Tune, and QD.",
    "crumbs": [
      "Home",
      "Introduction",
      "jax_mppi"
    ]
  },
  {
    "objectID": "index.html#credits",
    "href": "index.html#credits",
    "title": "jax_mppi",
    "section": "",
    "text": "This project is a direct port of pytorch_mppi. We aim to maintain parity with the original implementation while leveraging JAXâ€™s unique features for performance and flexibility.",
    "crumbs": [
      "Home",
      "Introduction",
      "jax_mppi"
    ]
  },
  {
    "objectID": "index.html#completed-plans",
    "href": "index.html#completed-plans",
    "title": "jax_mppi",
    "section": "",
    "text": "Porting Plan\nEvosax Integration Plan\nCUDA MPPI Implementation Plan",
    "crumbs": [
      "Home",
      "Introduction",
      "jax_mppi"
    ]
  },
  {
    "objectID": "examples/i_mppi_interactive_simulation.html",
    "href": "examples/i_mppi_interactive_simulation.html",
    "title": "I-MPPI: Interactive Informative Model Predictive Path Integral Control",
    "section": "",
    "text": "Open In Colab\nThis notebook provides an interactive simulation of the two-layer I-MPPI architecture for informative path planning with GPU acceleration."
  },
  {
    "objectID": "examples/i_mppi_interactive_simulation.html#architecture-overview",
    "href": "examples/i_mppi_interactive_simulation.html#architecture-overview",
    "title": "I-MPPI: Interactive Informative Model Predictive Path Integral Control",
    "section": "Architecture Overview",
    "text": "Architecture Overview\nLayer 2 (FSMI Analyzer, ~5 Hz)         Layer 3 (I-MPPI Controller, ~50 Hz)\n+---------------------------------+     +-----------------------------------+\n| Full FSMI (O(n^2))             |     | Biased MPPI + Uniform-FSMI (O(n)) |\n| - Occupancy grid analysis      | --&gt; | - Tracks Layer 2 reference traj   |\n| - Global information planning  |     | - Local informative reactivity    |\n| - Reference trajectory output  |     | - Obstacle avoidance              |\n+---------------------------------+     +-----------------------------------+\nLayer 2 generates reference trajectories maximizing global information gain using Fisher-Shannon Mutual Information (FSMI) on the occupancy grid.\nLayer 3 tracks the reference while maintaining local informative viewpoints via Uniform-FSMI, ensuring reactive exploration even between Layer 2 updates.\nCost function: J = Tracking(ref) + Obstacles - lambda * Uniform_FSMI(local)\n\n# @title Setup: Install jax_mppi and dependencies (Colab only)\nimport os\nimport sys\n\nif \"COLAB_GPU\" in os.environ or \"COLAB_RELEASE_TAG\" in os.environ:\n    # Running in Google Colab\n    !git clone https://github.com/riccardo-enr/jax_mppi.git /content/jax_mppi\n    # Install Python dependencies only (skip C++ build)\n    !rm -rf /content/jax_mppi\n    !git clone https://github.com/riccardo-enr/jax_mppi.git /content/jax_mppi\n    %pip install -q jaxtyping chex matplotlib ipywidgets\n    # Add source to path directly\n    sys.path.insert(0, \"/content/jax_mppi/src\")\n    os.chdir(\"/content/jax_mppi\")\nelse:\n    print(\"Not running in Colab -- assuming local installation.\")\n\n# Verify JAX and GPU\nimport jax\n\nprint(f\"JAX version: {jax.__version__}\")\nprint(f\"Available devices: {jax.devices()}\")\ngpu_available = any(\n    \"gpu\" in str(d).lower() or \"cuda\" in str(d).lower() for d in jax.devices()\n)\nif gpu_available:\n    print(\"GPU detected.\")\nelse:\n    print(\"WARNING: No GPU detected. Simulation will run on CPU (slower).\")\n    print(\"In Colab: Runtime &gt; Change runtime type &gt; GPU\")\n\nNot running in Colab -- assuming local installation.\nJAX version: 0.9.0\nAvailable devices: [CudaDevice(id=0)]\nGPU detected.\n\n\n\n# Imports\nimport time\nfrom functools import partial\n\nimport ipywidgets as widgets\nimport jax\nimport jax.numpy as jnp\nimport matplotlib.patches as mpatches\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom IPython.display import clear_output, display\n\nfrom jax_mppi import mppi\nfrom jax_mppi.i_mppi.environment import (\n    GOAL_POS,\n    INFO_ZONES,\n    augmented_dynamics,\n    informative_running_cost,\n)\nfrom jax_mppi.i_mppi.fsmi import (\n    FSMIConfig,\n    FSMITrajectoryGenerator,\n    UniformFSMI,\n    UniformFSMIConfig,\n)\nfrom jax_mppi.i_mppi.map import GridMap\nfrom jax_mppi.i_mppi.planner import biased_mppi_command\n\nprint(\"All imports successful.\")"
  },
  {
    "objectID": "examples/i_mppi_interactive_simulation.html#environment-setup",
    "href": "examples/i_mppi_interactive_simulation.html#environment-setup",
    "title": "I-MPPI: Interactive Informative Model Predictive Path Integral Control",
    "section": "Environment Setup",
    "text": "Environment Setup\nThe simulation takes place in a 14m x 12m office-like environment with: - Walls (gray): Physical obstacles the quadrotor must avoid - Info zones (yellow): Unknown regions with high entropy â€“ the robot gains information by flying near them - Goal (red star): Target position the robot must reach - Start (green circle): Initial robot position\nThe occupancy grid encodes uncertainty: 0.5 = unknown, 0.2 = known free, 0.9 = known occupied.\n\ndef create_occupancy_grid():\n    \"\"\"Create an office-like occupancy grid with rooms and corridors.\"\"\"\n    world_width = 14.0\n    world_height = 12.0\n    resolution = 0.1\n\n    width = int(world_width / resolution)\n    height = int(world_height / resolution)\n\n    grid = 0.5 * jnp.ones((height, width))\n\n    # Known free space (central corridor)\n    grid = grid.at[35:85, 5:135].set(0.2)\n\n    # Outer walls\n    grid = grid.at[0:5, :].set(0.9)\n    grid = grid.at[115:120, :].set(0.9)\n    grid = grid.at[:, 0:5].set(0.9)\n    grid = grid.at[:, 135:140].set(0.9)\n\n    # Room 1: Bottom-left office\n    grid = grid.at[85:115, 5:45].set(0.9)\n    grid = grid.at[35:115, 5:10].set(0.9)\n    grid = grid.at[35:85, 40:45].set(0.9)\n    grid = grid.at[35:45, 40:45].set(0.2)  # doorway\n    grid = grid.at[40:80, 10:40].set(0.5)  # unknown interior\n    grid = grid.at[40:50, 30:40].set(0.35)\n\n    # Room 2: Top-left office\n    grid = grid.at[5:35, 5:45].set(0.9)\n    grid = grid.at[5:35, 40:45].set(0.9)\n    grid = grid.at[28:36, 40:45].set(0.2)  # doorway\n    grid = grid.at[10:30, 10:40].set(0.5)\n\n    # Room 3: Bottom-right office\n    grid = grid.at[85:115, 95:135].set(0.9)\n    grid = grid.at[85:115, 130:135].set(0.9)\n    grid = grid.at[35:85, 95:100].set(0.9)\n    grid = grid.at[40:50, 95:100].set(0.2)  # doorway\n    grid = grid.at[40:80, 100:130].set(0.5)\n    grid = grid.at[50:60, 105:115].set(0.8)\n    grid = grid.at[65:75, 120:125].set(0.8)\n\n    # Room 4: Top-right office\n    grid = grid.at[5:35, 95:135].set(0.9)\n    grid = grid.at[5:35, 95:100].set(0.9)\n    grid = grid.at[28:36, 95:100].set(0.2)  # doorway\n    grid = grid.at[10:30, 100:130].set(0.5)\n    grid = grid.at[25:32, 100:110].set(0.35)\n\n    # Central obstacles\n    grid = grid.at[45:55, 50:60].set(0.85)\n    grid = grid.at[65:75, 70:80].set(0.85)\n    grid = grid.at[40:45, 85:90].set(0.8)\n    grid = grid.at[75:80, 20:25].set(0.8)\n\n    # Narrow passages\n    grid = grid.at[35:85, 45:52].set(0.2)\n    grid = grid.at[55:65, 60:70].set(0.2)\n\n    # Info zones (high uncertainty)\n    grid = grid.at[50:75, 12:35].set(0.5)\n    grid = grid.at[55:70, 15:30].set(0.55)\n    grid = grid.at[12:28, 102:128].set(0.5)\n    grid = grid.at[15:25, 105:125].set(0.55)\n\n    # Additional complexity\n    grid = grid.at[70:82, 48:52].set(0.9)\n    grid = grid.at[72:80, 48:52].set(0.2)\n    grid = grid.at[72:80, 45:48].set(0.52)\n    grid = grid.at[55:70, 90:95].set(0.9)\n    grid = grid.at[35:36, 40:45].set(0.75)\n    grid = grid.at[84:85, 95:100].set(0.75)\n\n    map_origin = jnp.array([0.0, 0.0])\n    return grid, map_origin, resolution, width, height\n\n\n# Build environment\ngrid_array, map_origin, map_resolution, grid_width, grid_height = (\n    create_occupancy_grid()\n)\ngrid_map_obj = GridMap(\n    grid=grid_array,\n    origin=map_origin,\n    resolution=map_resolution,\n    width=grid_width,\n    height=grid_height,\n)\n\n\n# Visualize\ndef plot_environment(ax, grid, resolution, show_labels=True):\n    \"\"\"Plot the occupancy grid with walls, info zones, start, and goal.\"\"\"\n    extent = [0, grid.shape[1] * resolution, 0, grid.shape[0] * resolution]\n    ax.imshow(\n        np.array(grid),\n        origin=\"lower\",\n        extent=extent,\n        cmap=\"gray_r\",\n        vmin=0,\n        vmax=1,\n        alpha=0.8,\n    )\n\n    # Info zones\n    for i in range(len(INFO_ZONES)):\n        cx, cy = float(INFO_ZONES[i, 0]), float(INFO_ZONES[i, 1])\n        w, h = float(INFO_ZONES[i, 2]), float(INFO_ZONES[i, 3])\n        rect = mpatches.FancyBboxPatch(\n            (cx - w / 2, cy - h / 2),\n            w,\n            h,\n            boxstyle=\"round,pad=0.05\",\n            facecolor=\"yellow\",\n            alpha=0.3,\n            edgecolor=\"orange\",\n            linewidth=1.5,\n        )\n        ax.add_patch(rect)\n        if show_labels:\n            ax.text(\n                cx, cy, f\"Info {i+1}\", ha=\"center\", va=\"center\", fontsize=8\n            )\n\n    # Start and goal\n    ax.plot(1.0, 5.0, \"go\", markersize=10, label=\"Start\", zorder=5)\n    ax.plot(\n        float(GOAL_POS[0]),\n        float(GOAL_POS[1]),\n        \"r*\",\n        markersize=15,\n        label=\"Goal\",\n        zorder=5,\n    )\n\n    ax.set_xlim(-0.5, 14.5)\n    ax.set_ylim(-0.5, 12.5)\n    ax.set_xlabel(\"X (m)\")\n    ax.set_ylabel(\"Y (m)\")\n    ax.set_aspect(\"equal\")\n\n\nfig, ax = plt.subplots(1, 1, figsize=(10, 8))\nplot_environment(ax, grid_array, map_resolution)\nax.set_title(\"Office Environment: Occupancy Grid\")\nax.legend(loc=\"upper left\")\nplt.colorbar(\n    ax.images[0],\n    ax=ax,\n    label=\"Occupancy (0=free, 0.5=unknown, 1=occupied)\",\n)\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "examples/i_mppi_interactive_simulation.html#interactive-parameter-configuration",
    "href": "examples/i_mppi_interactive_simulation.html#interactive-parameter-configuration",
    "title": "I-MPPI: Interactive Informative Model Predictive Path Integral Control",
    "section": "Interactive Parameter Configuration",
    "text": "Interactive Parameter Configuration\nAdjust the parameters below and click Run Simulation to execute the I-MPPI controller.\n\n\n\n\n\n\n\n\nParameter\nDescription\nEffect\n\n\n\n\nSamples\nNumber of MPPI rollout samples\nMore = better trajectories, slower\n\n\nHorizon\nPlanning horizon (steps)\nLonger = further look-ahead\n\n\nLambda\nMPPI temperature\nLower = more greedy (exploits best)\n\n\nInfo Weight\nUniform-FSMI weight in Layer 3\nHigher = more exploration-driven\n\n\nFSMI Beams\nNumber of sensor beams (Layer 2)\nMore = better information estimate\n\n\nFSMI Range\nMax sensor range (Layer 2)\nLonger = wider planning scope\n\n\n\n\n# Visualization helper functions\n\n\ndef plot_trajectory_2d(\n    ax, history_x, grid, resolution, title=\"I-MPPI Trajectory\"\n):\n    \"\"\"Plot 2D trajectory over the environment.\"\"\"\n    plot_environment(ax, grid, resolution, show_labels=False)\n\n    # Trajectory colored by time\n    positions = np.array(history_x[:, :2])\n    n_steps = len(positions)\n    colors = plt.cm.viridis(np.linspace(0, 1, n_steps))\n    for i in range(n_steps - 1):\n        ax.plot(\n            positions[i : i + 2, 0],\n            positions[i : i + 2, 1],\n            color=colors[i],\n            linewidth=2,\n        )\n\n    ax.plot(positions[0, 0], positions[0, 1], \"go\", markersize=10, zorder=5)\n    ax.plot(positions[-1, 0], positions[-1, 1], \"bs\", markersize=8, zorder=5)\n    ax.plot(\n        float(GOAL_POS[0]), float(GOAL_POS[1]), \"r*\", markersize=15, zorder=5\n    )\n    ax.set_title(title)\n\n\ndef plot_info_levels(ax, history_info, dt):\n    \"\"\"Plot info zone depletion over time.\"\"\"\n    info = np.array(history_info)\n    t = np.arange(len(info)) * dt\n    for i in range(info.shape[1]):\n        ax.plot(t, info[:, i], linewidth=2, label=f\"Info Zone {i+1}\")\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Information Level\")\n    ax.set_title(\"Information Zone Depletion\")\n    ax.legend()\n    ax.grid(True, alpha=0.3)\n\n\ndef plot_control_inputs(axes, actions, dt):\n    \"\"\"Plot control inputs over time (4 subplots).\"\"\"\n    acts = np.array(actions)\n    t = np.arange(len(acts)) * dt\n    labels = [\n        \"Thrust (N)\",\n        \"Omega X (rad/s)\",\n        \"Omega Y (rad/s)\",\n        \"Omega Z (rad/s)\",\n    ]\n    colors = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\"]\n    for i, (ax, label, color) in enumerate(zip(axes, labels, colors)):\n        ax.plot(t, acts[:, i], color=color, linewidth=1, alpha=0.8)\n        ax.set_ylabel(label)\n        ax.grid(True, alpha=0.3)\n    axes[-1].set_xlabel(\"Time (s)\")\n    axes[0].set_title(\"Control Inputs\")\n\n\ndef plot_position_3d(ax, history_x):\n    \"\"\"Plot 3D trajectory.\"\"\"\n    pos = np.array(history_x[:, :3])\n    n = len(pos)\n    colors = plt.cm.viridis(np.linspace(0, 1, n))\n    for i in range(n - 1):\n        ax.plot(\n            pos[i : i + 2, 0],\n            pos[i : i + 2, 1],\n            pos[i : i + 2, 2],\n            color=colors[i],\n            linewidth=1.5,\n        )\n    ax.scatter(*pos[0], color=\"green\", s=60, zorder=5)\n    ax.scatter(\n        float(GOAL_POS[0]),\n        float(GOAL_POS[1]),\n        float(GOAL_POS[2]),\n        color=\"red\",\n        marker=\"*\",\n        s=100,\n        zorder=5,\n    )\n    ax.set_xlabel(\"X (m)\")\n    ax.set_ylabel(\"Y (m)\")\n    ax.set_zlabel(\"Z (m)\")\n    ax.set_title(\"3D Trajectory\")\n\n\n# Simulation helper functions\n\n# Constants\nDT = 0.05\nNX = 16  # 13 (quad) + 3 (info zones)\nNU = 4\nCONTROL_HZ = 50.0\nFSMI_HZ = 5.0\nFSMI_STEPS = int(round(CONTROL_HZ / FSMI_HZ))\n\nU_MIN = jnp.array([0.0, -10.0, -10.0, -10.0])\nU_MAX = jnp.array([4.0 * 9.81, 10.0, 10.0, 10.0])\nU_INIT = jnp.array([9.81, 0.0, 0.0, 0.0])\nNOISE_SIGMA = jnp.diag(jnp.array([2.0, 0.5, 0.5, 0.5]) ** 2)\n\n\ndef make_u_ref_from_traj(current_state, ref_traj):\n    \"\"\"Convert position reference trajectory to control reference.\"\"\"\n    pos = current_state[:3]\n    err = ref_traj - pos[None, :]\n\n    k_thrust = 3.0\n    thrust = U_INIT[0] + k_thrust * err[:, 2]\n\n    k_omega = 0.6\n    omega_x = k_omega * err[:, 1]\n    omega_y = -k_omega * err[:, 0]\n    omega_z = jnp.zeros_like(omega_x)\n\n    u_ref = jnp.stack([thrust, omega_x, omega_y, omega_z], axis=1)\n    u_ref = jnp.clip(u_ref, U_MIN, U_MAX)\n    return u_ref\n\n\ndef compute_smoothness(actions, positions, dt_val):\n    \"\"\"Compute action jerk and trajectory jerk metrics.\"\"\"\n    action_jerk = jnp.diff(actions, n=2, axis=0) / (dt_val**2)\n    action_jerk_mean = jnp.mean(jnp.linalg.norm(action_jerk, axis=1))\n\n    pos = positions[:, :3]\n    vel = jnp.diff(pos, axis=0) / dt_val\n    acc = jnp.diff(vel, axis=0) / dt_val\n    jerk = jnp.diff(acc, axis=0) / dt_val\n    traj_jerk_mean = jnp.mean(jnp.linalg.norm(jerk, axis=1))\n\n    return action_jerk_mean, traj_jerk_mean\n\n\ndef build_sim_fn(\n    config,\n    fsmi_planner,\n    uniform_fsmi,\n    uniform_fsmi_config,\n    horizon,\n    sim_steps,\n):\n    \"\"\"Build a JIT-compiled simulation function.\"\"\"\n\n    def step_fn(carry, t):\n        current_state, current_ctrl_state, ref_traj = carry\n\n        # Layer 2: Full FSMI reference trajectory (slow, 5 Hz)\n        current_info = current_state[13:]\n        do_update = jnp.equal(jnp.mod(t, FSMI_STEPS), 0)\n        info_data = (grid_map_obj.grid, current_info)\n\n        ref_traj = jax.lax.cond(\n            do_update,\n            lambda _: fsmi_planner.get_reference_trajectory(\n                current_state, info_data, horizon, DT\n            )[0],\n            lambda _: ref_traj,\n            operand=None,\n        )\n\n        # Layer 3: Biased I-MPPI with Uniform-FSMI (fast, 50 Hz)\n        cost_fn = partial(\n            informative_running_cost,\n            target=ref_traj,\n            grid_map=grid_map_obj.grid,\n            uniform_fsmi_fn=uniform_fsmi.compute,\n            info_weight=uniform_fsmi_config.info_weight,\n        )\n\n        U_ref_local = make_u_ref_from_traj(current_state, ref_traj)\n\n        action, next_ctrl_state = biased_mppi_command(\n            config,\n            current_ctrl_state,\n            current_state,\n            augmented_dynamics,\n            cost_fn,\n            U_ref_local,\n            bias_alpha=0.2,\n        )\n\n        next_state = augmented_dynamics(current_state, action, dt=DT)\n\n        return (next_state, next_ctrl_state, ref_traj), (\n            next_state,\n            current_info,\n            ref_traj[0],\n            action,\n        )\n\n    def sim_fn(initial_state, initial_ctrl_state):\n        info_data = (grid_map_obj.grid, initial_state[13:])\n        init_ref_traj, _ = fsmi_planner.get_reference_trajectory(\n            initial_state, info_data, horizon, DT\n        )\n        (\n            (final_state, final_ctrl_state, _),\n            (history_x, history_info, targets, actions),\n        ) = jax.lax.scan(\n            step_fn,\n            (initial_state, initial_ctrl_state, init_ref_traj),\n            jnp.arange(sim_steps),\n        )\n        return final_state, history_x, history_info, targets, actions\n\n    return jax.jit(sim_fn)\n\n\nprint(\"Simulation engine ready.\")\n\n\n# Interactive widgets\n\n# System parameters\nw_start_x = widgets.FloatSlider(\n    value=1.0, min=0.5, max=12.0, step=0.5, description=\"Start X (m):\"\n)\nw_start_y = widgets.FloatSlider(\n    value=5.0, min=0.5, max=9.0, step=0.5, description=\"Start Y (m):\"\n)\nw_duration = widgets.FloatSlider(\n    value=15.0, min=5.0, max=60.0, step=5.0, description=\"Duration (s):\"\n)\n\n# Controller parameters\nw_samples = widgets.IntSlider(\n    value=1000, min=100, max=5000, step=100, description=\"Samples:\"\n)\nw_horizon = widgets.IntSlider(\n    value=40, min=10, max=80, step=5, description=\"Horizon:\"\n)\nw_lambda = widgets.FloatLogSlider(\n    value=0.1, min=-2, max=1, step=0.1, description=\"Lambda:\"\n)\nw_info_weight = widgets.FloatSlider(\n    value=5.0, min=0.0, max=20.0, step=1.0, description=\"Info Weight:\"\n)\n\n# FSMI parameters\nw_fsmi_beams = widgets.IntSlider(\n    value=12, min=4, max=24, step=2, description=\"FSMI Beams:\"\n)\nw_fsmi_range = widgets.FloatSlider(\n    value=5.0, min=2.0, max=10.0, step=0.5, description=\"FSMI Range:\"\n)\n\nrun_button = widgets.Button(\n    description=\"Run Simulation\",\n    button_style=\"success\",\n    icon=\"play\",\n    layout=widgets.Layout(width=\"200px\", height=\"40px\"),\n)\noutput_area = widgets.Output()\n\n\ndef run_simulation(button):\n    \"\"\"Run I-MPPI simulation with current widget parameters.\"\"\"\n    with output_area:\n        clear_output(wait=True)\n\n        # Read parameters\n        start_x = w_start_x.value\n        start_y = w_start_y.value\n        sim_duration = w_duration.value\n        num_samples = w_samples.value\n        horizon = w_horizon.value\n        lambda_ = w_lambda.value\n        info_weight = w_info_weight.value\n        fsmi_beams = w_fsmi_beams.value\n        fsmi_range = w_fsmi_range.value\n\n        sim_steps = int(round(sim_duration * CONTROL_HZ))\n\n        print(\"=\" * 60)\n        print(\"I-MPPI Interactive Simulation\")\n        print(\"=\" * 60)\n        print(f\"  Start: ({start_x}, {start_y})\")\n        print(f\"  Duration: {sim_duration}s ({sim_steps} steps)\")\n        print(\n            f\"  Samples: {num_samples}, Horizon: {horizon}, \"\n            f\"Lambda: {lambda_}\"\n        )\n        print(f\"  Info Weight: {info_weight}\")\n        print(f\"  FSMI Beams: {fsmi_beams}, Range: {fsmi_range}m\")\n        print()\n\n        # Initial state\n        start_pos = jnp.array([start_x, start_y, -2.0])\n        info_init = jnp.array([100.0, 100.0, 100.0])\n        x0 = jnp.zeros(13)\n        x0 = x0.at[:3].set(start_pos)\n        x0 = x0.at[6].set(1.0)  # qw=1\n        state = jnp.concatenate([x0, info_init])\n\n        # Layer 2: FSMI config\n        fsmi_config = FSMIConfig(\n            use_grid_fsmi=True,\n            goal_pos=GOAL_POS,\n            fov_rad=1.57,\n            num_beams=fsmi_beams,\n            max_range=fsmi_range,\n            ray_step=0.15,\n            sigma_range=0.15,\n            gaussian_truncation_sigma=3.0,\n            trajectory_subsample_rate=8,\n            info_weight=25.0,\n            motion_weight=0.5,\n        )\n        fsmi_planner = FSMITrajectoryGenerator(\n            config=fsmi_config,\n            info_zones=INFO_ZONES,\n            grid_map=grid_map_obj,\n        )\n\n        # Layer 3: Uniform-FSMI config\n        uniform_fsmi_config = UniformFSMIConfig(\n            fov_rad=1.57,\n            num_beams=6,\n            max_range=2.5,\n            ray_step=0.2,\n            info_weight=info_weight,\n        )\n        uniform_fsmi = UniformFSMI(\n            uniform_fsmi_config,\n            map_origin,\n            map_resolution,\n        )\n\n        # MPPI config\n        config, ctrl_state = mppi.create(\n            nx=NX,\n            nu=NU,\n            noise_sigma=NOISE_SIGMA,\n            num_samples=num_samples,\n            horizon=horizon,\n            lambda_=lambda_,\n            u_min=U_MIN,\n            u_max=U_MAX,\n            u_init=U_INIT,\n            step_dependent_dynamics=True,\n        )\n\n        # Build simulation\n        sim_fn = build_sim_fn(\n            config,\n            fsmi_planner,\n            uniform_fsmi,\n            uniform_fsmi_config,\n            horizon,\n            sim_steps,\n        )\n\n        # JIT compile (warm-up)\n        print(\"JIT compiling... (this may take 1-2 min on first run)\")\n        t0 = time.perf_counter()\n        warm = sim_fn(state, ctrl_state)\n        for leaf in jax.tree_util.tree_leaves(warm):\n            leaf.block_until_ready()\n        compile_time = time.perf_counter() - t0\n        print(f\"  Compilation: {compile_time:.1f}s\")\n\n        # Timed run\n        print(\"Running simulation...\")\n        t0 = time.perf_counter()\n        final_state, history_x, history_info, targets, actions = sim_fn(\n            state, ctrl_state\n        )\n        final_state.block_until_ready()\n        runtime = time.perf_counter() - t0\n\n        # Metrics\n        action_jerk, traj_jerk = compute_smoothness(actions, history_x, DT)\n        final_pos = final_state[:3]\n        goal_dist = float(jnp.linalg.norm(final_pos - GOAL_POS))\n\n        print(\n            f\"  Runtime: {runtime:.2f}s \"\n            f\"({runtime / sim_duration:.2f}x realtime)\"\n        )\n        print(\n            f\"  Final position: [{final_pos[0]:.2f}, \"\n            f\"{final_pos[1]:.2f}, {final_pos[2]:.2f}]\"\n        )\n        print(f\"  Distance to goal: {goal_dist:.2f}m\")\n        print(f\"  Info levels: {final_state[13:]}\")\n        print(f\"  Action jerk: {float(action_jerk):.4f}\")\n        print(f\"  Trajectory jerk: {float(traj_jerk):.4f}\")\n        print()\n\n        # Visualization\n        fig = plt.figure(figsize=(16, 12))\n\n        # 2D trajectory\n        ax1 = fig.add_subplot(2, 2, 1)\n        plot_trajectory_2d(\n            ax1,\n            history_x,\n            grid_array,\n            map_resolution,\n            \"I-MPPI Trajectory (2D)\",\n        )\n\n        # Info level depletion\n        ax2 = fig.add_subplot(2, 2, 2)\n        plot_info_levels(ax2, history_info, DT)\n\n        # 3D trajectory\n        ax3 = fig.add_subplot(2, 2, 3, projection=\"3d\")\n        plot_position_3d(ax3, history_x)\n\n        # Control inputs\n        ax4a = fig.add_subplot(4, 2, 6)\n        ax4b = fig.add_subplot(4, 2, 8)\n        acts = np.array(actions)\n        t_arr = np.arange(len(acts)) * DT\n        ax4a.plot(t_arr, acts[:, 0], color=\"#1f77b4\", linewidth=1)\n        ax4a.set_ylabel(\"Thrust (N)\")\n        ax4a.set_title(\"Control Inputs\")\n        ax4a.grid(True, alpha=0.3)\n        ax4b.plot(t_arr, acts[:, 1], color=\"#ff7f0e\", linewidth=1, label=\"wx\")\n        ax4b.plot(t_arr, acts[:, 2], color=\"#2ca02c\", linewidth=1, label=\"wy\")\n        ax4b.plot(t_arr, acts[:, 3], color=\"#d62728\", linewidth=1, label=\"wz\")\n        ax4b.set_ylabel(\"Angular rates\")\n        ax4b.set_xlabel(\"Time (s)\")\n        ax4b.legend(fontsize=8)\n        ax4b.grid(True, alpha=0.3)\n\n        plt.tight_layout()\n        plt.show()\n\n\nrun_button.on_click(run_simulation)\n\n# Layout\nsystem_box = widgets.VBox(\n    [\n        widgets.HTML(\"&lt;h3&gt;System Parameters&lt;/h3&gt;\"),\n        w_start_x,\n        w_start_y,\n        w_duration,\n    ]\n)\ncontroller_box = widgets.VBox(\n    [\n        widgets.HTML(\"&lt;h3&gt;Controller Parameters&lt;/h3&gt;\"),\n        w_samples,\n        w_horizon,\n        w_lambda,\n        w_info_weight,\n    ]\n)\nfsmi_box = widgets.VBox(\n    [\n        widgets.HTML(\"&lt;h3&gt;FSMI Parameters (Layer 2)&lt;/h3&gt;\"),\n        w_fsmi_beams,\n        w_fsmi_range,\n    ]\n)\n\nparam_panel = widgets.HBox([system_box, controller_box, fsmi_box])\ndisplay(widgets.VBox([param_panel, run_button, output_area]))"
  },
  {
    "objectID": "examples/i_mppi_interactive_simulation.html#mppi-simulation-with-fixed-parameters",
    "href": "examples/i_mppi_interactive_simulation.html#mppi-simulation-with-fixed-parameters",
    "title": "I-MPPI: Interactive Informative Model Predictive Path Integral Control",
    "section": "MPPI Simulation with Fixed Parameters",
    "text": "MPPI Simulation with Fixed Parameters\nRun the I-MPPI controller with fixed parameters for a reproducible comparison baseline.\nThe two-layer architecture uses: - Layer 2: Full FSMI reference trajectory generation - Layer 3: Biased MPPI tracking + local Uniform-FSMI information gain\n\n# Fixed-parameter MPPI simulation\n\n\ndef run_fixed_simulation():\n    \"\"\"Run MPPI controller with fixed parameters.\"\"\"\n    horizon = 40\n    sim_duration = 30.0\n    sim_steps = int(round(sim_duration * CONTROL_HZ))\n\n    # Initial state\n    start_pos = jnp.array([1.0, 5.0, -2.0])\n    info_init = jnp.array([100.0, 100.0, 100.0])\n    x0 = jnp.zeros(13)\n    x0 = x0.at[:3].set(start_pos)\n    x0 = x0.at[6].set(1.0)\n    state = jnp.concatenate([x0, info_init])\n\n    # Shared FSMI setup\n    fsmi_config = FSMIConfig(\n        use_grid_fsmi=True,\n        goal_pos=GOAL_POS,\n        fov_rad=1.57,\n        num_beams=12,\n        max_range=5.0,\n        ray_step=0.15,\n        sigma_range=0.15,\n        gaussian_truncation_sigma=3.0,\n        trajectory_subsample_rate=8,\n        info_weight=25.0,\n        motion_weight=0.5,\n    )\n    fsmi_planner = FSMITrajectoryGenerator(\n        config=fsmi_config,\n        info_zones=INFO_ZONES,\n        grid_map=grid_map_obj,\n    )\n\n    uniform_fsmi_config = UniformFSMIConfig(\n        fov_rad=1.57,\n        num_beams=6,\n        max_range=2.5,\n        ray_step=0.2,\n        info_weight=5.0,\n    )\n    uniform_fsmi = UniformFSMI(\n        uniform_fsmi_config,\n        map_origin,\n        map_resolution,\n    )\n\n    def block_until_ready(tree):\n        for leaf in jax.tree_util.tree_leaves(tree):\n            leaf.block_until_ready()\n\n    # MPPI\n    mppi_config, mppi_state = mppi.create(\n        nx=NX, nu=NU, noise_sigma=NOISE_SIGMA, num_samples=1000,\n        horizon=horizon, lambda_=0.1, u_min=U_MIN, u_max=U_MAX,\n        u_init=U_INIT, step_dependent_dynamics=True,\n    )\n\n    sim_fn = build_sim_fn(\n        mppi_config,\n        fsmi_planner,\n        uniform_fsmi,\n        uniform_fsmi_config,\n        horizon,\n        sim_steps,\n    )\n\n    print(\"Running MPPI...\")\n\n    # Warm-up\n    print(\"  JIT compiling...\")\n    warm = sim_fn(state, mppi_state)\n    block_until_ready(warm)\n\n    # Timed run\n    t0 = time.perf_counter()\n    final_state, history_x, history_info, targets, actions = sim_fn(\n        state, mppi_state\n    )\n    final_state.block_until_ready()\n    elapsed = time.perf_counter() - t0\n\n    action_jerk, traj_jerk = compute_smoothness(actions, history_x, DT)\n    goal_dist = float(jnp.linalg.norm(final_state[:3] - GOAL_POS))\n\n    results = {\n        \"history_x\": history_x,\n        \"history_info\": history_info,\n        \"actions\": actions,\n        \"runtime_s\": elapsed,\n        \"action_jerk\": float(action_jerk),\n        \"traj_jerk\": float(traj_jerk),\n        \"goal_dist\": goal_dist,\n        \"final_state\": final_state,\n    }\n    print(\n        f\"  MPPI: {elapsed:.2f}s \"\n        f\"({elapsed / sim_duration:.2f}x realtime), \"\n        f\"goal dist: {goal_dist:.2f}m\"\n    )\n\n    return results\n\n\nprint(\"Running fixed-parameter simulation...\")\nprint()\nmppi_results = run_fixed_simulation()\n\n\n# MPPI results visualization\n\nfig, axes = plt.subplots(1, 3, figsize=(18, 6))\n\n# 2D trajectory\nax = axes[0]\nplot_environment(ax, grid_array, map_resolution, show_labels=False)\nhistory_x = mppi_results[\"history_x\"]\npositions = np.array(history_x[:, :2])\nn_steps = len(positions)\ncolors_traj = plt.cm.viridis(np.linspace(0, 1, n_steps))\nfor i in range(n_steps - 1):\n    ax.plot(\n        positions[i : i + 2, 0],\n        positions[i : i + 2, 1],\n        color=colors_traj[i],\n        linewidth=2,\n    )\nax.set_title(\"I-MPPI Trajectory\")\n\n# Info level depletion\nplot_info_levels(axes[1], mppi_results[\"history_info\"], DT)\naxes[1].set_title(\"Information Zone Depletion\")\n\n# Control inputs\nacts = np.array(mppi_results[\"actions\"])\nt_arr = np.arange(len(acts)) * DT\nax3 = axes[2]\nax3.plot(t_arr, acts[:, 0], color=\"#1f77b4\", linewidth=1, label=\"Thrust\")\nax3.plot(t_arr, acts[:, 1], color=\"#ff7f0e\", linewidth=1, label=\"wx\")\nax3.plot(t_arr, acts[:, 2], color=\"#2ca02c\", linewidth=1, label=\"wy\")\nax3.plot(t_arr, acts[:, 3], color=\"#d62728\", linewidth=1, label=\"wz\")\nax3.set_ylabel(\"Control Input\")\nax3.set_xlabel(\"Time (s)\")\nax3.set_title(\"Control Inputs\")\nax3.legend(fontsize=8)\nax3.grid(True, alpha=0.3)\n\nplt.suptitle(\n    \"I-MPPI: Full FSMI (Layer 2) + \"\n    \"Biased MPPI with Uniform-FSMI (Layer 3)\",\n    fontsize=14,\n)\nplt.tight_layout()\nplt.show()\n\n# Performance summary\nr = mppi_results\nprint()\nprint(\"=\" * 60)\nprint(f\"{'Metric':&lt;25} {'Value':&gt;15}\")\nprint(\"-\" * 60)\nprint(f\"{'Runtime (ms)':&lt;25} {r['runtime_s']*1000:&gt;15.1f}\")\nprint(f\"{'Goal Distance (m)':&lt;25} {r['goal_dist']:&gt;15.2f}\")\nprint(f\"{'Action Jerk':&lt;25} {r['action_jerk']:&gt;15.4f}\")\nprint(f\"{'Trajectory Jerk':&lt;25} {r['traj_jerk']:&gt;15.4f}\")\nprint(\"=\" * 60)"
  },
  {
    "objectID": "releasing.html",
    "href": "releasing.html",
    "title": "Releasing Guide",
    "section": "",
    "text": "This guide describes how to release a new version of jax_mppi to PyPI.\n\n\nThe release process is automated using GitHub Actions, but it requires the repository to be configured as a Trusted Publisher on PyPI.\n\n\n\nLog in to your PyPI account.\nGo to Publishing in your project settings (or create a new project if this is the first release).\nAdd a new Trusted Publisher.\nSelect GitHub.\nEnter the following details:\n\nOwner: riccardo-enr\nRepository name: jax_mppi\nWorkflow name: publish.yml\nEnvironment name: (Leave empty)\n\nClick Add.\n\nThis allows the GitHub Action to authenticate with PyPI using OIDC tokens without needing a long-lived API token or password.\n\n\n\n\nTo release a new version:\n\nUpdate Version: Update the version number in pyproject.toml:\n[project]\nversion = \"0.1.6\"  # Example version\nCommit and Push: Commit the version change and push to main.\ngit add pyproject.toml\ngit commit -m \"Bump version to 0.1.6\"\ngit push origin main\nCreate Tag: Create a git tag for the release. The tag must start with v.\ngit tag v0.1.6\ngit push origin v0.1.6\nWait for Action: The Publish to PyPI GitHub Action will automatically run when the tag is pushed. It will build the package and upload it to PyPI.\nVerify: Check the PyPI page to confirm the new version is available.",
    "crumbs": [
      "Home",
      "Development",
      "Releasing Guide"
    ]
  },
  {
    "objectID": "releasing.html#prerequisites",
    "href": "releasing.html#prerequisites",
    "title": "Releasing Guide",
    "section": "",
    "text": "The release process is automated using GitHub Actions, but it requires the repository to be configured as a Trusted Publisher on PyPI.\n\n\n\nLog in to your PyPI account.\nGo to Publishing in your project settings (or create a new project if this is the first release).\nAdd a new Trusted Publisher.\nSelect GitHub.\nEnter the following details:\n\nOwner: riccardo-enr\nRepository name: jax_mppi\nWorkflow name: publish.yml\nEnvironment name: (Leave empty)\n\nClick Add.\n\nThis allows the GitHub Action to authenticate with PyPI using OIDC tokens without needing a long-lived API token or password.",
    "crumbs": [
      "Home",
      "Development",
      "Releasing Guide"
    ]
  },
  {
    "objectID": "releasing.html#release-process",
    "href": "releasing.html#release-process",
    "title": "Releasing Guide",
    "section": "",
    "text": "To release a new version:\n\nUpdate Version: Update the version number in pyproject.toml:\n[project]\nversion = \"0.1.6\"  # Example version\nCommit and Push: Commit the version change and push to main.\ngit add pyproject.toml\ngit commit -m \"Bump version to 0.1.6\"\ngit push origin main\nCreate Tag: Create a git tag for the release. The tag must start with v.\ngit tag v0.1.6\ngit push origin v0.1.6\nWait for Action: The Publish to PyPI GitHub Action will automatically run when the tag is pushed. It will build the package and upload it to PyPI.\nVerify: Check the PyPI page to confirm the new version is available.",
    "crumbs": [
      "Home",
      "Development",
      "Releasing Guide"
    ]
  },
  {
    "objectID": "i_mppi.html",
    "href": "i_mppi.html",
    "title": "I-MPPI: Informative Model Predictive Path Integral",
    "section": "",
    "text": "The field of autonomous Unmanned Aerial Vehicle (UAV) exploration has transitioned from simple geometric coverage to complex, information-driven strategic maneuvers. In unstructured environments, a robot faces a fundamental duality: the global coverage problem (â€œwhere to goâ€) and the reactive control problem (â€œhow to move safelyâ€). Traditional approaches often decouple these modules, resulting in â€œmyopicâ€ local planners that fail to escape local minima of uncertainty, or deterministic global planners that produce coarse, â€œjaggedâ€ paths unsuitable for the high-speed, non-linear dynamics of agile flight.\nThis document describes the Hierarchical Informative Model Predictive Path Integral (I-MPPI) framework. This architecture synthesizes global strategic planning, analytical viewpoint refinement via Fast Shannon Mutual Information (FSMI), and reactive Biased-MPPI control with sensitivity-based feedback.\n\n\n\n\n\n\nNoteRepository Scope\n\n\n\nThe focus of this repository is the high-performance CUDA implementation of Layer 2 (Local Refinement) and Layer 3/4 (Reactive Control). The Global Planner (Layer 1), such as FUEL, is considered an external input that provides the mission context and global waypoints.",
    "crumbs": [
      "Home",
      "Algorithms",
      "I-MPPI: Informative Model Predictive Path Integral"
    ]
  },
  {
    "objectID": "i_mppi.html#optimal-control-duality-free-energy",
    "href": "i_mppi.html#optimal-control-duality-free-energy",
    "title": "I-MPPI: Informative Model Predictive Path Integral",
    "section": "Optimal Control Duality & Free Energy",
    "text": "Optimal Control Duality & Free Energy\nThe mathematical derivation of the MPPI algorithm is rooted in the definition of the free energy of the dynamical system. The value function \\(V(x, t)\\) of a stochastic system can be linearized through a logarithmic transformation, leading to the Path Integral formulation. The Free Energy (\\(\\mathcal{F}\\)) of the dynamical system is defined as:\n\\[ \\mathcal{F}(x_0) = -\\lambda \\log \\mathbb{E}_{\\mathbb{P}} \\left[ \\exp \\left( -\\frac{1}{\\lambda} S(\\tau) \\right) \\right] \\]\n\n\\(\\tau\\): The state-control trajectory \\(\\{x_0, u_0, x_1, u_1, \\dots, x_T\\}\\).\n\\(\\mathbb{P}\\): The base distribution, representing the stochastic trajectories of the â€œpassiveâ€ system.\n\\(S(\\tau)\\): The cumulative cost (Action) of a trajectory \\(\\tau\\).\n\\(\\lambda\\): The temperature parameter, representing the noise variance.\n\nThe â€œoptimal trajectoryâ€ is the mean of the distribution \\(\\mathbb{Q}^*\\) that minimizes the KL-divergence to the distribution of â€œlow-costâ€ paths, leading to the thermodynamic weight update rule:\n\\[ \\omega^k = \\frac{\\exp\\left(-\\frac{1}{\\lambda}(J^k - \\rho)\\right)}{\\sum_{j=1}^{K} \\exp\\left(-\\frac{1}{\\lambda}(J^j - \\rho)\\right)} \\]",
    "crumbs": [
      "Home",
      "Algorithms",
      "I-MPPI: Informative Model Predictive Path Integral"
    ]
  },
  {
    "objectID": "i_mppi.html#shannon-mutual-information",
    "href": "i_mppi.html#shannon-mutual-information",
    "title": "I-MPPI: Informative Model Predictive Path Integral",
    "section": "Shannon Mutual Information",
    "text": "Shannon Mutual Information\nThe informative reward is the Shannon Mutual Information (MI) between the map \\(M\\) and a future sensor measurement \\(Z\\): \\[ I(M; Z) = H(M) - H(M|Z) \\] where \\(H(M)\\) is the map entropy. High MI indicates regions of unknown space or uncertain areas.",
    "crumbs": [
      "Home",
      "Algorithms",
      "I-MPPI: Informative Model Predictive Path Integral"
    ]
  },
  {
    "objectID": "i_mppi.html#fast-shannon-mutual-information-fsmi",
    "href": "i_mppi.html#fast-shannon-mutual-information-fsmi",
    "title": "I-MPPI: Informative Model Predictive Path Integral",
    "section": "Fast Shannon Mutual Information (FSMI)",
    "text": "Fast Shannon Mutual Information (FSMI)\nComputing Shannon MI analytically for a sensor beam involves:\n\nRaycasting: Cast a ray intersecting \\(n\\) cells with occupancy \\(o_i\\).\nVisibility (\\(P(e_j)\\)): Probability that the beam reaches cell \\(j\\): \\[ P(e_j) = o_j \\prod_{k=1}^{j-1} (1 - o_k) \\]\nInformation Density (\\(C_k\\)): Cumulative info gain based on inverse sensor model.\nAnalytic Summation: \\[ I_{FSMI} = \\sum_{j=0}^{n} \\sum_{k=1}^{n} P(e_j) C_k G_{k,j} \\]\n\nThe Uniform-FSMI variant simplifies this to \\(O(n)\\) complexity: \\[ I \\approx \\sum_{j=0}^{n} P(e_j) \\frac{D_{j+H} - D_{j-H-1}}{2H + 1} \\]",
    "crumbs": [
      "Home",
      "Algorithms",
      "I-MPPI: Informative Model Predictive Path Integral"
    ]
  },
  {
    "objectID": "i_mppi.html#exploration-campaign",
    "href": "i_mppi.html#exploration-campaign",
    "title": "I-MPPI: Informative Model Predictive Path Integral",
    "section": "Exploration Campaign",
    "text": "Exploration Campaign\nTo verify the effectiveness of the informative reward, we conducted a simulation campaign in a â€œcorridor with a holeâ€ scenario. Both controllers are tasked with reaching a common goal at \\((9, 5)\\). The map contains two high-entropy â€œunknownâ€ zones located away from the direct path.\n\nHierarchical Architecture Specification\nThe goal for the I-MPPI simulation is to verify the effectiveness of the implementation of layer 2 and layer 3 of the hierarchical architecture.\nA higher-level FSMI-driven trajectory generator should precede the I-MPPI module. - Frequency: Runs at a lower rate (1-5 Hz). - Logic: 1. Explore Area 1: Prioritize regions with high information interest and lower dynamical cost. 2. Transition: As Area 1 is explored, its information value drops to zero. 3. Explore Area 2: Move to the next area of interest. 4. Drive to Goal: When information cost is depleted, drive to the goal minimizing only the dynamical cost.\n\nStandard MPPI: Simply moves towards the target, ignoring the high-entropy regions.\nInformative MPPI: Proactively deviates from the shortest path to explore the unknown areas, gathering information before proceeding to the goal.\nThe two zones are marked with Yellow Rectangles. They should have a high importance in the cost function. But after they get explored, their importance should decrease, thus the I-MPPI is free to move towards the goal. This should simulate the behaviour of the FSMI only trajectory refiner which gives a goal taking into account the uncertainty of the map.\n\n\n\n\nI-MPPI Exploration Campaign. The heatmap shows the cost field (darker is better). The Gold Star is the common goal. Yellow Rectangles denote high-interest (unknown) zones. The Cyan Lines represent walls. Standard MPPI (black dashed) goes direct, while Informative MPPI (white solid) deviates to explore both blobs before reaching the goal.\n\n\n\n\nPerformance Comparison\nThe Informative MPPI demonstrates a clear bias towards high-entropy regions of the map. By minimizing the Unified Cost Function, the controller naturally seeks out viewpoints that maximize sensor coverage of unknown space, effectively â€œfallingâ€ into informative gravity wells as predicted by the theory.",
    "crumbs": [
      "Home",
      "Algorithms",
      "I-MPPI: Informative Model Predictive Path Integral"
    ]
  },
  {
    "objectID": "examples/pendulum.html",
    "href": "examples/pendulum.html",
    "title": "Pendulum Swing-Up",
    "section": "",
    "text": "This example demonstrates how to use jax_mppi to control an inverted pendulum. The goal is to swing the pendulum up from a hanging position and stabilize it at the top.\n\n\nThe full example code is available in examples/basic/pendulum.py.\n\n\n\nThe pendulum dynamics are defined as a pure function:\ndef pendulum_dynamics(state: jax.Array, action: jax.Array) -&gt; jax.Array:\n    \"\"\"Pendulum dynamics.\n\n    State: [theta, theta_dot]\n        theta: angle from upright (0 = upright, pi = hanging down)\n        theta_dot: angular velocity\n    Action: [torque]\n        torque: applied torque (control input)\n    \"\"\"\n    g = 10.0  # gravity\n    m = 1.0  # mass\n    l = 1.0  # length\n    dt = 0.05  # timestep\n\n    theta, theta_dot = state[0], state[1]\n    torque = action[0]\n\n    # Clip torque to reasonable bounds\n    torque = jnp.clip(torque, -2.0, 2.0)\n\n    # Pendulum dynamics: theta_ddot = (torque - m*g*l*sin(theta)) / (m*l^2)\n    theta_ddot = (torque - m * g * l * jnp.sin(theta)) / (m * l * l)\n\n    # Euler integration\n    theta_dot_next = theta_dot + theta_ddot * dt\n    theta_next = theta + theta_dot_next * dt\n\n    # Normalize angle to [-pi, pi]\n    theta_next = ((theta_next + jnp.pi) % (2 * jnp.pi)) - jnp.pi\n\n    return jnp.array([theta_next, theta_dot_next])\n\n\n\nThe running cost penalizes deviation from the upright position and high control effort:\ndef pendulum_cost(state: jax.Array, action: jax.Array) -&gt; jax.Array:\n    theta, theta_dot = state[0], state[1]\n    torque = action[0]\n\n    # Cost for being away from upright (theta=0)\n    angle_cost = theta**2\n\n    # Cost for high angular velocity\n    velocity_cost = 0.1 * theta_dot**2\n\n    # Cost for using torque\n    control_cost = 0.01 * torque**2\n\n    return angle_cost + velocity_cost + control_cost\n\n\n\nYou can run the example using:\npython examples/basic/pendulum.py --visualize",
    "crumbs": [
      "Home",
      "Examples",
      "Pendulum Swing-Up"
    ]
  },
  {
    "objectID": "examples/pendulum.html#code",
    "href": "examples/pendulum.html#code",
    "title": "Pendulum Swing-Up",
    "section": "",
    "text": "The full example code is available in examples/basic/pendulum.py.",
    "crumbs": [
      "Home",
      "Examples",
      "Pendulum Swing-Up"
    ]
  },
  {
    "objectID": "examples/pendulum.html#dynamics",
    "href": "examples/pendulum.html#dynamics",
    "title": "Pendulum Swing-Up",
    "section": "",
    "text": "The pendulum dynamics are defined as a pure function:\ndef pendulum_dynamics(state: jax.Array, action: jax.Array) -&gt; jax.Array:\n    \"\"\"Pendulum dynamics.\n\n    State: [theta, theta_dot]\n        theta: angle from upright (0 = upright, pi = hanging down)\n        theta_dot: angular velocity\n    Action: [torque]\n        torque: applied torque (control input)\n    \"\"\"\n    g = 10.0  # gravity\n    m = 1.0  # mass\n    l = 1.0  # length\n    dt = 0.05  # timestep\n\n    theta, theta_dot = state[0], state[1]\n    torque = action[0]\n\n    # Clip torque to reasonable bounds\n    torque = jnp.clip(torque, -2.0, 2.0)\n\n    # Pendulum dynamics: theta_ddot = (torque - m*g*l*sin(theta)) / (m*l^2)\n    theta_ddot = (torque - m * g * l * jnp.sin(theta)) / (m * l * l)\n\n    # Euler integration\n    theta_dot_next = theta_dot + theta_ddot * dt\n    theta_next = theta + theta_dot_next * dt\n\n    # Normalize angle to [-pi, pi]\n    theta_next = ((theta_next + jnp.pi) % (2 * jnp.pi)) - jnp.pi\n\n    return jnp.array([theta_next, theta_dot_next])",
    "crumbs": [
      "Home",
      "Examples",
      "Pendulum Swing-Up"
    ]
  },
  {
    "objectID": "examples/pendulum.html#cost-function",
    "href": "examples/pendulum.html#cost-function",
    "title": "Pendulum Swing-Up",
    "section": "",
    "text": "The running cost penalizes deviation from the upright position and high control effort:\ndef pendulum_cost(state: jax.Array, action: jax.Array) -&gt; jax.Array:\n    theta, theta_dot = state[0], state[1]\n    torque = action[0]\n\n    # Cost for being away from upright (theta=0)\n    angle_cost = theta**2\n\n    # Cost for high angular velocity\n    velocity_cost = 0.1 * theta_dot**2\n\n    # Cost for using torque\n    control_cost = 0.01 * torque**2\n\n    return angle_cost + velocity_cost + control_cost",
    "crumbs": [
      "Home",
      "Examples",
      "Pendulum Swing-Up"
    ]
  },
  {
    "objectID": "examples/pendulum.html#running-the-example",
    "href": "examples/pendulum.html#running-the-example",
    "title": "Pendulum Swing-Up",
    "section": "",
    "text": "You can run the example using:\npython examples/basic/pendulum.py --visualize",
    "crumbs": [
      "Home",
      "Examples",
      "Pendulum Swing-Up"
    ]
  },
  {
    "objectID": "testing.html",
    "href": "testing.html",
    "title": "Testing Guide",
    "section": "",
    "text": "This guide explains the testing stack for jax_mppi and provides instructions on how to run and write tests.\n\n\nThe project uses pytest for running tests. You can run all tests using uv:\nuv run pytest\nTo run a specific test file:\nuv run pytest tests/test_mppi.py\nTo run a specific test case:\nuv run pytest tests/test_mppi.py::TestMPPICommand::test_command_returns_correct_shapes\n\n\n\nThe tests are located in the tests/ directory and mirror the source code structure where appropriate. The test suite is divided into several files, each covering a specific flavor or aspect of the library.\n\n\n\ntests/test_mppi.py: Tests for the base MPPI implementation (jax_mppi.mppi).\n\nGoal: Ensure the correctness of the core algorithm, state management, and configuration options.\nScope:\n\nInitialization: Verifies that create() returns correct shapes and types for config and state.\nCommand Generation: Tests the command() function to ensure it generates valid actions within bounds and correctly updates the state.\nConfiguration Options: Validates various settings like u_per_command (multi-step control), step_dependent_dynamics (time-varying systems), sample_null_action (ensuring baseline inclusion), and u_scale (control authority scaling).\nIntegration: Includes basic convergence tests to verify that the cost decreases over iterations (e.g., TestMPPIIntegration).\n\n\ntests/test_smppi.py: Tests for Smooth MPPI (jax_mppi.smppi).\n\nGoal: Verify that the â€œsmoothâ€ variant correctly operates in the lifted velocity control space and produces continuous action sequences.\nScope:\n\nLifted Space: Checks that the internal state (U) represents control velocity/acceleration, while action_sequence represents the integrated actions.\nSmoothness: Verifies that the smoothness cost penalty (w_action_seq_cost) effectively reduces action variance.\nBounds: Tests that bounds are respected for both the control velocity (u_min/u_max) and the final action (action_min/action_max).\nContinuity: checks that the shift operation maintains continuity in the action space, preventing jumps during receding horizon updates.\n\n\ntests/test_kmppi.py: Tests for Kernel MPPI (jax_mppi.kmppi).\n\nGoal: Ensure that kernel-based interpolation works correctly and that optimization occurs effectively in the reduced control point space.\nScope:\n\nKernels: Tests the properties of time-domain kernels (e.g., RBFKernel), such as shape and distance decay.\nInterpolation: Verifies that control points (theta) are correctly mapped to full trajectories (U) via _kernel_interpolate, preserving values at control points.\nOptimization: Checks that the MPPI update rule is applied to the control points (theta) rather than the full trajectory.\nSmoothness: Confirms that the resulting trajectories are smooth due to the kernel properties (e.g., by checking second derivatives).\n\n\n\n\n\n\n\ntests/test_pendulum.py: End-to-end integration tests using a Pendulum environment.\n\nGoal: Validate that the algorithms can solve a concrete, non-linear control task.\nScope:\n\nStabilization: Tests if MPPI can stabilize the pendulum at the upright position.\nSwing-up: Tests the more difficult task of swinging up from a hanging position.\nPhysics: Sanity checks the pendulum dynamics and cost functions.\n\n\n\n\n\n\n\ntests/test_autotune.py: Unit tests for the autotuning framework (jax_mppi.autotune).\n\nGoal: Verify the components of the hyperparameter optimization system.\n\ntests/test_autotune_integration.py: Integration tests for autotuning.\n\nGoal: Ensure that the autotuner can successfully improve performance on a benchmark task (finding better parameters than the default).\n\n\n\n\n\n\nWhen adding new features or fixing bugs, please add corresponding tests.\n\nLocate the appropriate test file: If you are modifying mppi.py, add tests to tests/test_mppi.py.\nUse Class-Based Structure: Group related tests into classes (e.g., TestMPPIBasics, TestMPPICommand).\nProperty-Based Testing: Where possible, test properties (e.g., â€œoutput shape depends on input shape in this wayâ€) rather than just hardcoded values.\nIntegration Tests: For significant algorithmic changes, ensure that tests/test_pendulum.py still passes or add a similar simple control task to verify efficacy.\nJAX Compatibility: Ensure tests check that functions can be JIT-compiled if they are intended to be used within jax.jit.\n\n\n\ndef test_new_feature(self):\n    nx, nu = 2, 1\n    config, state = mppi.create(nx=nx, nu=nu, noise_sigma=jnp.eye(nu))\n\n    # ... perform action ...\n    action, new_state = mppi.command(config, state, ...)\n\n    # ... assert expected behavior ...\n    assert action.shape == (nu,)",
    "crumbs": [
      "Home",
      "Development",
      "Testing Guide"
    ]
  },
  {
    "objectID": "testing.html#running-tests",
    "href": "testing.html#running-tests",
    "title": "Testing Guide",
    "section": "",
    "text": "The project uses pytest for running tests. You can run all tests using uv:\nuv run pytest\nTo run a specific test file:\nuv run pytest tests/test_mppi.py\nTo run a specific test case:\nuv run pytest tests/test_mppi.py::TestMPPICommand::test_command_returns_correct_shapes",
    "crumbs": [
      "Home",
      "Development",
      "Testing Guide"
    ]
  },
  {
    "objectID": "testing.html#test-suite-structure",
    "href": "testing.html#test-suite-structure",
    "title": "Testing Guide",
    "section": "",
    "text": "The tests are located in the tests/ directory and mirror the source code structure where appropriate. The test suite is divided into several files, each covering a specific flavor or aspect of the library.\n\n\n\ntests/test_mppi.py: Tests for the base MPPI implementation (jax_mppi.mppi).\n\nGoal: Ensure the correctness of the core algorithm, state management, and configuration options.\nScope:\n\nInitialization: Verifies that create() returns correct shapes and types for config and state.\nCommand Generation: Tests the command() function to ensure it generates valid actions within bounds and correctly updates the state.\nConfiguration Options: Validates various settings like u_per_command (multi-step control), step_dependent_dynamics (time-varying systems), sample_null_action (ensuring baseline inclusion), and u_scale (control authority scaling).\nIntegration: Includes basic convergence tests to verify that the cost decreases over iterations (e.g., TestMPPIIntegration).\n\n\ntests/test_smppi.py: Tests for Smooth MPPI (jax_mppi.smppi).\n\nGoal: Verify that the â€œsmoothâ€ variant correctly operates in the lifted velocity control space and produces continuous action sequences.\nScope:\n\nLifted Space: Checks that the internal state (U) represents control velocity/acceleration, while action_sequence represents the integrated actions.\nSmoothness: Verifies that the smoothness cost penalty (w_action_seq_cost) effectively reduces action variance.\nBounds: Tests that bounds are respected for both the control velocity (u_min/u_max) and the final action (action_min/action_max).\nContinuity: checks that the shift operation maintains continuity in the action space, preventing jumps during receding horizon updates.\n\n\ntests/test_kmppi.py: Tests for Kernel MPPI (jax_mppi.kmppi).\n\nGoal: Ensure that kernel-based interpolation works correctly and that optimization occurs effectively in the reduced control point space.\nScope:\n\nKernels: Tests the properties of time-domain kernels (e.g., RBFKernel), such as shape and distance decay.\nInterpolation: Verifies that control points (theta) are correctly mapped to full trajectories (U) via _kernel_interpolate, preserving values at control points.\nOptimization: Checks that the MPPI update rule is applied to the control points (theta) rather than the full trajectory.\nSmoothness: Confirms that the resulting trajectories are smooth due to the kernel properties (e.g., by checking second derivatives).\n\n\n\n\n\n\n\ntests/test_pendulum.py: End-to-end integration tests using a Pendulum environment.\n\nGoal: Validate that the algorithms can solve a concrete, non-linear control task.\nScope:\n\nStabilization: Tests if MPPI can stabilize the pendulum at the upright position.\nSwing-up: Tests the more difficult task of swinging up from a hanging position.\nPhysics: Sanity checks the pendulum dynamics and cost functions.\n\n\n\n\n\n\n\ntests/test_autotune.py: Unit tests for the autotuning framework (jax_mppi.autotune).\n\nGoal: Verify the components of the hyperparameter optimization system.\n\ntests/test_autotune_integration.py: Integration tests for autotuning.\n\nGoal: Ensure that the autotuner can successfully improve performance on a benchmark task (finding better parameters than the default).",
    "crumbs": [
      "Home",
      "Development",
      "Testing Guide"
    ]
  },
  {
    "objectID": "testing.html#writing-new-tests",
    "href": "testing.html#writing-new-tests",
    "title": "Testing Guide",
    "section": "",
    "text": "When adding new features or fixing bugs, please add corresponding tests.\n\nLocate the appropriate test file: If you are modifying mppi.py, add tests to tests/test_mppi.py.\nUse Class-Based Structure: Group related tests into classes (e.g., TestMPPIBasics, TestMPPICommand).\nProperty-Based Testing: Where possible, test properties (e.g., â€œoutput shape depends on input shape in this wayâ€) rather than just hardcoded values.\nIntegration Tests: For significant algorithmic changes, ensure that tests/test_pendulum.py still passes or add a similar simple control task to verify efficacy.\nJAX Compatibility: Ensure tests check that functions can be JIT-compiled if they are intended to be used within jax.jit.\n\n\n\ndef test_new_feature(self):\n    nx, nu = 2, 1\n    config, state = mppi.create(nx=nx, nu=nu, noise_sigma=jnp.eye(nu))\n\n    # ... perform action ...\n    action, new_state = mppi.command(config, state, ...)\n\n    # ... assert expected behavior ...\n    assert action.shape == (nu,)",
    "crumbs": [
      "Home",
      "Development",
      "Testing Guide"
    ]
  },
  {
    "objectID": "plan/issue_31_visualization_exploration.html",
    "href": "plan/issue_31_visualization_exploration.html",
    "title": "Issue #31: Refactor Visualization and Increase Exploration Incentive",
    "section": "",
    "text": "The current examples/i_mppi/i_mppi_simulation.py has two main issues:\n\nVisualization Overcrowding: 4 plots (2D, 3D, occupancy grid) with overlapping elements\nInsufficient Exploration: Robot visits first info zone then goes straight to goal\n\n\n\n\n\n\nLayer 2 (FSMI Analyzer, ~5 Hz): - info_weight=25.0 - information weight - motion_weight=0.5 - motion cost weight - Ratio: 50:1 (info:motion)\nLayer 3 (Uniform-FSMI, ~50 Hz): - info_weight=5.0 - local information weight\n\n\n\nThe issue is NOT the Layer 2/3 weights alone. Looking at environment.py:146:\ninfo_cost = -10.0 * info_gain\ntarget_cost = 1.0 * dist_target\nThe running_cost function (used for baseline) has -10.0 info multiplier. But informative_running_cost (Layer 3) has info_weight=5.0 which is relatively low.\nKey insight: After exploring Area 1, the info levels deplete (info_levels go to 0), so the controller no longer sees value in nearby zones. The reference trajectory from Layer 2 should be driving exploration, but the target_cost weight of 1.0 is too weak compared to goal attraction.\n\n\n\n\n\n\n\n\nRemove the 3D view (row 1, col 2) - not adding value\nRemove the full occupancy grid heatmap (row 2) - cluttered\nKeep single 2D trajectory plot with:\n\nWalls (gray rectangles)\nInfo zones (yellow rectangles with labels)\nStart/goal markers\nController trajectories (MPPI, KMPPI only - no SMPPI)\n\nAdd optional info zone visit indicators (checkmarks when explored)\n\nFiles to modify: - examples/i_mppi/i_mppi_simulation.py (lines 541-776)\n\n\n\n\nLayer 2 (FSMIConfig):\n\nIncrease info_weight from 25.0 to 50.0 or higher\nDecrease motion_weight from 0.5 to 0.1\nRatio target: ~500:1 (info:motion)\n\nLayer 3 (UniformFSMIConfig):\n\nIncrease info_weight from 5.0 to 15.0-20.0\n\nEnvironment costs (environment.py):\n\nReduce target_cost weight from 1.0 to 0.3-0.5\nThis allows reference trajectory (with info incentive) to override pure goal-seeking\n\n\nFiles to modify: - examples/i_mppi/i_mppi_simulation.py (lines 200-232) - src/jax_mppi/i_mppi/environment.py (line 154, optionally line 231)\n\n\n\n\nRemove SMPPI from controller list (causes issues per issue notes)\nRun only MPPI and KMPPI\nVerify both visit 2+ info zones before goal\n\nFiles to modify: - examples/i_mppi/i_mppi_simulation.py (line 509)\n\n\n\n\nRun simulation and verify:\n\nMPPI trajectory visits multiple info zones\nKMPPI trajectory visits multiple info zones\nVisualization is clean and readable\n\nUpdate output image path and verify saved correctly\n\n\n\n\n\n\nDO NOT RUN SMPPI - causes visualization/computation issues.\nRun command:\nuv run python examples/i_mppi/i_mppi_simulation.py\n\n\n\nVisualization shows 1 clean 2D plot\nBoth MPPI and KMPPI visit 2+ info zones (check final info_levels in output)\nTrajectories clearly show exploration behavior before goal convergence\n\n\n\n\n\n\nIf exploration is still insufficient:\n\n\n\n\n\n\n\n\n\nParameter\nCurrent\nTry\nEffect\n\n\n\n\nLayer 2 info_weight\n25.0\n100.0\nStronger exploration in reference\n\n\nLayer 2 motion_weight\n0.5\n0.05\nAllow longer detours\n\n\nLayer 3 info_weight\n5.0\n25.0\nStronger local info seeking\n\n\ntarget_cost (env)\n1.0\n0.2\nWeaker goal pull\n\n\n\nIf robot gets stuck or oscillates: - Reduce info_weight - Increase motion_weight - Check for collision cost inflation near walls\n\n\n\n\nAfter implementation, add brief explanation in code comments about: - Why SMPPI is excluded - Weight choices for exploration vs.Â goal-seeking trade-off - Visualization design rationale"
  },
  {
    "objectID": "plan/issue_31_visualization_exploration.html#problem-summary",
    "href": "plan/issue_31_visualization_exploration.html#problem-summary",
    "title": "Issue #31: Refactor Visualization and Increase Exploration Incentive",
    "section": "",
    "text": "The current examples/i_mppi/i_mppi_simulation.py has two main issues:\n\nVisualization Overcrowding: 4 plots (2D, 3D, occupancy grid) with overlapping elements\nInsufficient Exploration: Robot visits first info zone then goes straight to goal"
  },
  {
    "objectID": "plan/issue_31_visualization_exploration.html#analysis",
    "href": "plan/issue_31_visualization_exploration.html#analysis",
    "title": "Issue #31: Refactor Visualization and Increase Exploration Incentive",
    "section": "",
    "text": "Layer 2 (FSMI Analyzer, ~5 Hz): - info_weight=25.0 - information weight - motion_weight=0.5 - motion cost weight - Ratio: 50:1 (info:motion)\nLayer 3 (Uniform-FSMI, ~50 Hz): - info_weight=5.0 - local information weight\n\n\n\nThe issue is NOT the Layer 2/3 weights alone. Looking at environment.py:146:\ninfo_cost = -10.0 * info_gain\ntarget_cost = 1.0 * dist_target\nThe running_cost function (used for baseline) has -10.0 info multiplier. But informative_running_cost (Layer 3) has info_weight=5.0 which is relatively low.\nKey insight: After exploring Area 1, the info levels deplete (info_levels go to 0), so the controller no longer sees value in nearby zones. The reference trajectory from Layer 2 should be driving exploration, but the target_cost weight of 1.0 is too weak compared to goal attraction."
  },
  {
    "objectID": "plan/issue_31_visualization_exploration.html#implementation-plan",
    "href": "plan/issue_31_visualization_exploration.html#implementation-plan",
    "title": "Issue #31: Refactor Visualization and Increase Exploration Incentive",
    "section": "",
    "text": "Remove the 3D view (row 1, col 2) - not adding value\nRemove the full occupancy grid heatmap (row 2) - cluttered\nKeep single 2D trajectory plot with:\n\nWalls (gray rectangles)\nInfo zones (yellow rectangles with labels)\nStart/goal markers\nController trajectories (MPPI, KMPPI only - no SMPPI)\n\nAdd optional info zone visit indicators (checkmarks when explored)\n\nFiles to modify: - examples/i_mppi/i_mppi_simulation.py (lines 541-776)\n\n\n\n\nLayer 2 (FSMIConfig):\n\nIncrease info_weight from 25.0 to 50.0 or higher\nDecrease motion_weight from 0.5 to 0.1\nRatio target: ~500:1 (info:motion)\n\nLayer 3 (UniformFSMIConfig):\n\nIncrease info_weight from 5.0 to 15.0-20.0\n\nEnvironment costs (environment.py):\n\nReduce target_cost weight from 1.0 to 0.3-0.5\nThis allows reference trajectory (with info incentive) to override pure goal-seeking\n\n\nFiles to modify: - examples/i_mppi/i_mppi_simulation.py (lines 200-232) - src/jax_mppi/i_mppi/environment.py (line 154, optionally line 231)\n\n\n\n\nRemove SMPPI from controller list (causes issues per issue notes)\nRun only MPPI and KMPPI\nVerify both visit 2+ info zones before goal\n\nFiles to modify: - examples/i_mppi/i_mppi_simulation.py (line 509)\n\n\n\n\nRun simulation and verify:\n\nMPPI trajectory visits multiple info zones\nKMPPI trajectory visits multiple info zones\nVisualization is clean and readable\n\nUpdate output image path and verify saved correctly"
  },
  {
    "objectID": "plan/issue_31_visualization_exploration.html#testing-notes",
    "href": "plan/issue_31_visualization_exploration.html#testing-notes",
    "title": "Issue #31: Refactor Visualization and Increase Exploration Incentive",
    "section": "",
    "text": "DO NOT RUN SMPPI - causes visualization/computation issues.\nRun command:\nuv run python examples/i_mppi/i_mppi_simulation.py\n\n\n\nVisualization shows 1 clean 2D plot\nBoth MPPI and KMPPI visit 2+ info zones (check final info_levels in output)\nTrajectories clearly show exploration behavior before goal convergence"
  },
  {
    "objectID": "plan/issue_31_visualization_exploration.html#weight-tuning-guide",
    "href": "plan/issue_31_visualization_exploration.html#weight-tuning-guide",
    "title": "Issue #31: Refactor Visualization and Increase Exploration Incentive",
    "section": "",
    "text": "If exploration is still insufficient:\n\n\n\n\n\n\n\n\n\nParameter\nCurrent\nTry\nEffect\n\n\n\n\nLayer 2 info_weight\n25.0\n100.0\nStronger exploration in reference\n\n\nLayer 2 motion_weight\n0.5\n0.05\nAllow longer detours\n\n\nLayer 3 info_weight\n5.0\n25.0\nStronger local info seeking\n\n\ntarget_cost (env)\n1.0\n0.2\nWeaker goal pull\n\n\n\nIf robot gets stuck or oscillates: - Reduce info_weight - Increase motion_weight - Check for collision cost inflation near walls"
  },
  {
    "objectID": "plan/issue_31_visualization_exploration.html#documentation",
    "href": "plan/issue_31_visualization_exploration.html#documentation",
    "title": "Issue #31: Refactor Visualization and Increase Exploration Incentive",
    "section": "",
    "text": "After implementation, add brief explanation in code comments about: - Why SMPPI is excluded - Weight choices for exploration vs.Â goal-seeking trade-off - Visualization design rationale"
  },
  {
    "objectID": "plan/fsm_i_exploration.html",
    "href": "plan/fsm_i_exploration.html",
    "title": "FSMI Exploration Plan",
    "section": "",
    "text": "Implement the real FSMI (Fast Shannon Mutual Information) exploration logic to bias exploration toward unexplored areas, running at a lower rate than the MPPI control loop.\nLook at the docs/plan/i_mppi.qmd for the theory behind FSMI.\nThe FSMI module should run at 5 Hz while the MPPI control loop runs at 50 Hz.\n\n\n\n\nAdd FSMI state computation and scoring for exploration targets.\nIntegrate FSMI output as a bias/goal for MPPI, without changing MPPI core control rate.\nBasically the FSMI returns a score for each area to explore correlated with the centroid position of the area to explore.\nEnsure FSMI runs at a lower frequency (e.g., every N MPPI ticks or at a fixed Hz).\n\n\n\n\n\nClarify which map representation is used for â€œexplored vs unexploredâ€ (occupancy grid, TSDF, voxel grid, etc.).\nDefine the FSMI target abstraction (frontiers, waypoints, information gain hotspots).\nDefine how FSMI influences MPPI (goal override, cost shaping, trajectory prior).\n\n\n\n\n\nIdentify and document the current map/coverage representation and available signals for â€œexplored.â€\nDefine the FSMI state structure and scoring function for â€œinformation gainâ€ or â€œunexploredness.â€\nImplement FSMI target selection (frontiers or hotspots) and a target cache.\nAdd a scheduler to run FSMI at lower frequency than MPPI (e.g., every N control steps).\nIntegrate FSMI output into MPPI (cost shaping or dynamic goal update).\nAdd configuration knobs (FSMI rate, scoring weights, frontier thresholds).\nAdd minimal tests or logging to verify FSMI target updates and MPPI biasing.\n\n\n\n\n\nFSMI updates at the configured lower rate and selects targets in unexplored regions.\nMPPI behavior demonstrably biases toward FSMI targets without destabilizing control.\nConfiguration documented and example run validates exploration bias."
  },
  {
    "objectID": "plan/fsm_i_exploration.html#goal",
    "href": "plan/fsm_i_exploration.html#goal",
    "title": "FSMI Exploration Plan",
    "section": "",
    "text": "Implement the real FSMI (Fast Shannon Mutual Information) exploration logic to bias exploration toward unexplored areas, running at a lower rate than the MPPI control loop.\nLook at the docs/plan/i_mppi.qmd for the theory behind FSMI.\nThe FSMI module should run at 5 Hz while the MPPI control loop runs at 50 Hz."
  },
  {
    "objectID": "plan/fsm_i_exploration.html#scope",
    "href": "plan/fsm_i_exploration.html#scope",
    "title": "FSMI Exploration Plan",
    "section": "",
    "text": "Add FSMI state computation and scoring for exploration targets.\nIntegrate FSMI output as a bias/goal for MPPI, without changing MPPI core control rate.\nBasically the FSMI returns a score for each area to explore correlated with the centroid position of the area to explore.\nEnsure FSMI runs at a lower frequency (e.g., every N MPPI ticks or at a fixed Hz)."
  },
  {
    "objectID": "plan/fsm_i_exploration.html#assumptions-open-questions",
    "href": "plan/fsm_i_exploration.html#assumptions-open-questions",
    "title": "FSMI Exploration Plan",
    "section": "",
    "text": "Clarify which map representation is used for â€œexplored vs unexploredâ€ (occupancy grid, TSDF, voxel grid, etc.).\nDefine the FSMI target abstraction (frontiers, waypoints, information gain hotspots).\nDefine how FSMI influences MPPI (goal override, cost shaping, trajectory prior)."
  },
  {
    "objectID": "plan/fsm_i_exploration.html#plan",
    "href": "plan/fsm_i_exploration.html#plan",
    "title": "FSMI Exploration Plan",
    "section": "",
    "text": "Identify and document the current map/coverage representation and available signals for â€œexplored.â€\nDefine the FSMI state structure and scoring function for â€œinformation gainâ€ or â€œunexploredness.â€\nImplement FSMI target selection (frontiers or hotspots) and a target cache.\nAdd a scheduler to run FSMI at lower frequency than MPPI (e.g., every N control steps).\nIntegrate FSMI output into MPPI (cost shaping or dynamic goal update).\nAdd configuration knobs (FSMI rate, scoring weights, frontier thresholds).\nAdd minimal tests or logging to verify FSMI target updates and MPPI biasing."
  },
  {
    "objectID": "plan/fsm_i_exploration.html#completion-criteria",
    "href": "plan/fsm_i_exploration.html#completion-criteria",
    "title": "FSMI Exploration Plan",
    "section": "",
    "text": "FSMI updates at the configured lower rate and selects targets in unexplored regions.\nMPPI behavior demonstrably biases toward FSMI targets without destabilizing control.\nConfiguration documented and example run validates exploration bias."
  },
  {
    "objectID": "plan/example_performance_investigation.html",
    "href": "plan/example_performance_investigation.html",
    "title": "Performance Investigation: Quadrotor Examples",
    "section": "",
    "text": "This document details the findings regarding performance differences between the quadrotor control examples: quadrotor_hover.py, quadrotor_circle.py, and quadrotor_figure8_comparison.py.\n\n\n\nquadrotor_hover.py: Fast (~0.2s/step simulated).\nquadrotor_circle.py: Previously slow (~45x slower). Optimized to use jax.lax.scan for maximum performance.\nquadrotor_figure8_comparison.py: Previously slowest. Optimized to use jax.lax.scan for maximum performance.\n\n\n\n\nThe performance disparity was primarily due to the usage of JAXâ€™s Just-In-Time (JIT) compilation and how cost functions are handled in the control loop.\n\n\nIn this example, the MPPI command function is explicitly JIT-compiled by the user, and the cost function is effectively constant (closed over static parameters).\n\n\n\nOriginally, this example re-created the cost function at every time step to update the reference target. This prevented JIT compilation of the main MPPI loop, forcing it to run in eager execution mode (or incurring massive re-compilation costs).\nOptimization Implemented: The implementation has been refactored to:\n\nUse step_dependent_dynamics=True to allow passing the time step t to the cost function.\nUse jax.lax.scan to wrap the entire simulation loop into a single JIT-compiled kernel. This eliminates Python loop dispatch overhead completely.\nPass the entire reference trajectory to the scan function and use jax.lax.dynamic_slice inside the loop to extract the current horizonâ€™s reference. This allows the cost function to close over dynamic data efficiently without recompilation.\n\nParameter Tuning: To improve tracking performance, the following parameters were tuned:\n\nnum_samples: Increased from 1000 to 2000.\nhorizon: Increased from 30 to 50.\nlambda: Decreased from 1.0 to 0.1 (sharper selection).\nCost weights: Significantly increased position and velocity weights.\n\n\n\n\nThis example shared the same issue as quadrotor_circle.py but for three different controllers (mppi, smppi, kmppi).\nOptimization Implemented: Similar to quadrotor_circle.py, the controllers have been updated to use jax.lax.scan for the simulation loop. This required adapting the update logic for all three variants to be compatible with scan and dynamic reference slicing.\nParameter Tuning: Parameters were similarly tuned to handle the aggressive figure-8 trajectory (samples=2000, horizon=50, lambda=0.1).\n\n\n\n\nWhen implementing tracking controllers with JAX MPPI:\n\nUse jax.lax.scan: For simulation loops, wrapping the entire loop in scan provides the best performance by minimizing Python overhead.\nParametrize the Cost Function: Avoid capturing changing concrete values (like current target) in closures if they prevent JIT.\nUse Data Dependencies: Pass changing targets as arguments (Tracers) to the JIT-compiled function.\nStep-Dependent Dynamics: Use step_dependent_dynamics=True to utilize the relative time index t for looking up references in a passed trajectory slice."
  },
  {
    "objectID": "plan/example_performance_investigation.html#summary",
    "href": "plan/example_performance_investigation.html#summary",
    "title": "Performance Investigation: Quadrotor Examples",
    "section": "",
    "text": "quadrotor_hover.py: Fast (~0.2s/step simulated).\nquadrotor_circle.py: Previously slow (~45x slower). Optimized to use jax.lax.scan for maximum performance.\nquadrotor_figure8_comparison.py: Previously slowest. Optimized to use jax.lax.scan for maximum performance."
  },
  {
    "objectID": "plan/example_performance_investigation.html#root-cause-analysis",
    "href": "plan/example_performance_investigation.html#root-cause-analysis",
    "title": "Performance Investigation: Quadrotor Examples",
    "section": "",
    "text": "The performance disparity was primarily due to the usage of JAXâ€™s Just-In-Time (JIT) compilation and how cost functions are handled in the control loop.\n\n\nIn this example, the MPPI command function is explicitly JIT-compiled by the user, and the cost function is effectively constant (closed over static parameters).\n\n\n\nOriginally, this example re-created the cost function at every time step to update the reference target. This prevented JIT compilation of the main MPPI loop, forcing it to run in eager execution mode (or incurring massive re-compilation costs).\nOptimization Implemented: The implementation has been refactored to:\n\nUse step_dependent_dynamics=True to allow passing the time step t to the cost function.\nUse jax.lax.scan to wrap the entire simulation loop into a single JIT-compiled kernel. This eliminates Python loop dispatch overhead completely.\nPass the entire reference trajectory to the scan function and use jax.lax.dynamic_slice inside the loop to extract the current horizonâ€™s reference. This allows the cost function to close over dynamic data efficiently without recompilation.\n\nParameter Tuning: To improve tracking performance, the following parameters were tuned:\n\nnum_samples: Increased from 1000 to 2000.\nhorizon: Increased from 30 to 50.\nlambda: Decreased from 1.0 to 0.1 (sharper selection).\nCost weights: Significantly increased position and velocity weights.\n\n\n\n\nThis example shared the same issue as quadrotor_circle.py but for three different controllers (mppi, smppi, kmppi).\nOptimization Implemented: Similar to quadrotor_circle.py, the controllers have been updated to use jax.lax.scan for the simulation loop. This required adapting the update logic for all three variants to be compatible with scan and dynamic reference slicing.\nParameter Tuning: Parameters were similarly tuned to handle the aggressive figure-8 trajectory (samples=2000, horizon=50, lambda=0.1)."
  },
  {
    "objectID": "plan/example_performance_investigation.html#recommendation-for-future-reference",
    "href": "plan/example_performance_investigation.html#recommendation-for-future-reference",
    "title": "Performance Investigation: Quadrotor Examples",
    "section": "",
    "text": "When implementing tracking controllers with JAX MPPI:\n\nUse jax.lax.scan: For simulation loops, wrapping the entire loop in scan provides the best performance by minimizing Python overhead.\nParametrize the Cost Function: Avoid capturing changing concrete values (like current target) in closures if they prevent JIT.\nUse Data Dependencies: Pass changing targets as arguments (Tracers) to the JIT-compiled function.\nStep-Dependent Dynamics: Use step_dependent_dynamics=True to utilize the relative time index t for looking up references in a passed trajectory slice."
  },
  {
    "objectID": "plan/completed/evosax_integration.html",
    "href": "plan/completed/evosax_integration.html",
    "title": "Evosax Integration Plan",
    "section": "",
    "text": "Goal: Add evosax as a JAX-native optimization backend for the autotuning framework in jax-mppi.\nStatus: In Progress\n\n\n\nEvosax is a JAX-native library for evolutionary strategies that provides highly efficient, JIT-compiled optimization algorithms. Integrating it into the autotuning framework will:\n\nProvide JAX-native optimization - Full JIT compilation of the entire tuning loop\nEnable GPU acceleration - Evolutionary strategies running entirely on GPU\nAdd diverse algorithms - CMA-ES, OpenES, SNES, Sep-CMA-ES, and more\nImprove performance - Eliminate Python overhead in the optimization loop\nSimplify dependencies - Pure JAX implementation, no external C++ dependencies\n\n\n\n\nPerformance: Fully JIT-compiled ES algorithms vs.Â Python-based cma library\nJAX ecosystem fit: Natural integration with JAX-based MPPI code\nGPU support: Can run entire autotuning on GPU without host-device transfers\nAlgorithm variety: 15+ evolutionary strategies in one package\nMaintained: Active development and well-documented\n\n\n\n\n\n\n\n\nThe current autotuning system has three modules:\n\nautotune.py (656 lines) - Core framework + CMA-ES via cma library\n\nAbstract Optimizer base class\nCMAESOpt using Python cma package\nParameter abstractions: LambdaParameter, NoiseSigmaParameter, MuParameter, HorizonParameter\nAutotune orchestrator class\n\nautotune_global.py (375 lines) - Ray Tune for global search\n\nRayOptimizer for distributed hyperparameter search\nGlobal parameter variants with search spaces\nIntegration with HyperOpt and BayesOpt\n\nautotune_qd.py (218 lines) - CMA-ME quality diversity\n\nCMAMEOpt using ribs library\nArchive-based diversity preservation\n\n\n\n\n\nAll optimizers follow the Optimizer ABC:\nclass Optimizer(abc.ABC):\n    @abc.abstractmethod\n    def setup_optimization(\n        self, initial_params: np.ndarray,\n        evaluate_fn: Callable[[np.ndarray], EvaluationResult]\n    ) -&gt; None:\n        ...\n\n    @abc.abstractmethod\n    def optimize_step(self) -&gt; EvaluationResult:\n        ...\n\n    def optimize_all(self, iterations: int) -&gt; EvaluationResult:\n        ...\n\n\n\n\n\n\n\nFile: pyproject.toml\nChanges:\n\nAdd evosax&gt;=0.1.0 to [project.optional-dependencies.autotuning] section\nAdd to [project.optional-dependencies.dev] section as well\n\nReasoning: Keep evosax optional like other autotuning dependencies, allowing users to install only what they need.\n\n\n\n\nNew File: src/jax_mppi/autotune_evosax.py (~387 lines)\nContents (Implemented):\n\n\nImplements Optimizer ABC with evosax backends:\nclass EvoSaxOptimizer(Optimizer):\n    \"\"\"JAX-native evolutionary strategies using evosax.\n\n    Fully JIT-compiled optimization loop with GPU support.\n\n    Attributes:\n        strategy: evosax strategy name (e.g., \"CMA_ES\", \"OpenES\", \"SNES\")\n        population: Population size\n        num_generations: Number of generations per optimize_step\n        maximize: Whether to maximize objective (default: False for cost minimization)\n    \"\"\"\n\n    def __init__(\n        self,\n        strategy: str = \"CMA_ES\",\n        population: int = 10,\n        num_generations: int = 1,\n        sigma_init: float = 0.1,\n        maximize: bool = False,\n        es_params: dict | None = None,\n    ):\n        ...\nKey features:\n\nStrategy selection from evosaxâ€™s 15+ algorithms\nJIT-compiled ask-evaluate-tell loop\nSupport for both single-step and batch optimization\nConfigurable ES hyperparameters via es_params\n\n\n\n\ndef _create_jax_evaluate_fn(\n    evaluate_fn: Callable[[np.ndarray], EvaluationResult],\n    maximize: bool = False,\n) -&gt; Callable[[jax.Array], float]:\n    \"\"\"Wrap Python evaluation function for JAX compatibility.\n\n    Handles conversion between JAX arrays and numpy arrays,\n    extracts scalar cost from EvaluationResult.\n    \"\"\"\n    ...\nChallenge: The user-provided evaluate_fn may not be JAX-pure (e.g., it might use numpy, modify state, etc.). Need to handle this gracefully.\nSolutions:\n\nOption A: Use jax.pure_callback to call non-pure evaluation functions\nOption B: Require evaluation function to be JAX-pure for evosax optimizer\nOption C: Provide both pure and impure modes\n\nRecommendation: Start with Option C - detect if evaluation is JAX-pure, use direct JIT if yes, use pure_callback if no.\n\n\n\nEvosax can leverage vmap for parallel fitness evaluation:\ndef _batch_evaluate(\n    solutions: jax.Array,  # (population, param_dim)\n    evaluate_fn: Callable,\n) -&gt; jax.Array:  # (population,)\n    \"\"\"Evaluate population in parallel using vmap.\"\"\"\n    return jax.vmap(evaluate_fn)(solutions)\nBenefits:\n\nGPU parallelization of fitness evaluations\nSignificant speedup when dynamics/cost are JIT-compiled\n\nChallenges:\n\nRequires evaluation to be JAX-pure and vmappable\nMay need sequential fallback for non-pure evaluations\n\n\n\n\nProvide convenience classes for common strategies:\nclass CMAESOpt(EvoSaxOptimizer):\n    \"\"\"CMA-ES optimizer (evosax backend).\"\"\"\n    def __init__(self, population: int = 10, sigma: float = 0.1, **kwargs):\n        super().__init__(strategy=\"CMA_ES\", population=population,\n                         sigma_init=sigma, **kwargs)\n\nclass OpenESOpt(EvoSaxOptimizer):\n    \"\"\"OpenAI's Evolution Strategies.\"\"\"\n    def __init__(self, population: int = 100, sigma: float = 0.1, **kwargs):\n        super().__init__(strategy=\"OpenES\", population=population,\n                         sigma_init=sigma, **kwargs)\n\nclass SepCMAESOpt(EvoSaxOptimizer):\n    \"\"\"Separable CMA-ES (faster for high dimensions).\"\"\"\n    def __init__(self, population: int = 10, sigma: float = 0.1, **kwargs):\n        super().__init__(strategy=\"Sep_CMA_ES\", population=population,\n                         sigma_init=sigma, **kwargs)\n\n\n\n\n\nFile: src/jax_mppi/autotune.py\nChanges:\n\nUpdate module docstring to mention evosax as an option\nUpdate examples to show evosax usage\n\nExample addition:\n&gt;&gt;&gt; # With evosax (JAX-native, GPU-accelerated)\n&gt;&gt;&gt; from jax_mppi import autotune_evosax\n&gt;&gt;&gt; tuner = jmppi.autotune.Autotune(\n...     params_to_tune=[...],\n...     evaluate_fn=evaluate,\n...     optimizer=autotune_evosax.CMAESOpt(population=10),\n... )\n\n\n\n\nFile: src/jax_mppi/__init__.py\nChanges:\n# Add conditional import\ntry:\n    from . import autotune_evosax\nexcept ImportError:\n    autotune_evosax = None  # evosax not installed\nReasoning: Keep it optional - donâ€™t break imports if evosax isnâ€™t installed.\n\n\n\n\nNew File: tests/test_autotune_evosax.py (~408 lines)\nTest coverage:\n\nBasic functionality tests\n\nTest EvoSaxOptimizer initialization with various strategies\nTest setup_optimization() creates valid ES state\nTest optimize_step() returns EvaluationResult\nTest optimize_all() finds better solutions\n\nStrategy-specific tests\n\nTest CMAESOpt on simple quadratic function\nTest OpenESOpt convergence\nTest SepCMAESOpt on high-dimensional problem\n\nIntegration tests\n\nTest with actual MPPI parameter tuning (simple 1D system)\nTest with LambdaParameter and NoiseSigmaParameter\nVerify results comparable to CMAESOpt from cma library\n\nJAX-specific tests\n\nTest JIT compilation of optimization loop\nTest with JAX-pure evaluation function\nTest with non-pure evaluation function (using pure_callback)\nTest batched evaluation with vmap\n\nEdge cases\n\nTest with single parameter\nTest with multi-dimensional parameters\nTest parameter bounds enforcement\nTest with invalid strategy name (should raise clear error)\n\n\nTest structure example:\ndef test_evosax_cmaes_simple():\n    \"\"\"Test CMA-ES on simple quadratic objective.\"\"\"\n    # Minimize ||x - target||^2\n    target = np.array([1.0, 2.0, 3.0])\n\n    def evaluate_fn(x: np.ndarray) -&gt; EvaluationResult:\n        cost = float(np.sum((x - target) ** 2))\n        return EvaluationResult(\n            mean_cost=cost,\n            rollouts=jnp.zeros((1, 1, 3)),\n            params={},\n            iteration=0,\n        )\n\n    optimizer = EvoSaxOptimizer(strategy=\"CMA_ES\", population=10)\n    optimizer.setup_optimization(\n        initial_params=np.zeros(3),\n        evaluate_fn=evaluate_fn,\n    )\n\n    best = optimizer.optimize_all(iterations=50)\n\n    # Should converge close to target\n    assert best.mean_cost &lt; 0.1\n\n\n\n\nNew File: examples/autotune_evosax_comparison.py (~307 lines)\nPurpose: Compare evosax vs.Â cma library performance\nContents:\n\nSetup simple pendulum MPPI tuning task\nRun with CMAESOpt from cma library (baseline)\nRun with CMAESOpt from evosax\nRun with other evosax strategies (OpenES, Sep-CMA-ES)\nCompare:\n\nConvergence speed (iterations to threshold)\nWall-clock time\nFinal performance\n\nGenerate comparison plots:\n\nConvergence curves for each optimizer\nTime comparison bar chart\nParameter trajectory plots\n\n\nExpected outcome: Evosax should be faster in wall-clock time due to JIT compilation, especially with GPU.\n\n\n\n\n\n\nAdd evosax to the autotuning section:\n### Autotuning\n\nJAX-MPPI supports automatic hyperparameter tuning with multiple backends:\n\n- **CMA-ES** (via `cma` library) - Classic evolution strategy\n- **CMA-ES** (via `evosax`) - JAX-native, GPU-accelerated  âš¡ **NEW**\n- **Ray Tune** - Distributed hyperparameter search\n- **CMA-ME** (via `ribs`) - Quality diversity optimization\n\nInstall with: `pip install jax-mppi[autotuning] evosax`\n\n\n\nUpdate autotune.py module docstring with evosax example.\n\n\n\nDocument for users switching from cma to evosax:\n## Migrating from cma to evosax\n\n**Before:**\n```python\nfrom jax_mppi.autotune import CMAESOpt\nopt = CMAESOpt(population=10, sigma=0.1)\nAfter:\nfrom jax_mppi.autotune_evosax import CMAESOpt\nopt = CMAESOpt(population=10, sigma=0.1)\nBenefits: 5-10x faster with GPU acceleration\n\n\n\n\n\n\n\n\nThe main challenge is that user evaluation functions may not be JAX-pure.\nStrategy:\ndef _wrap_evaluation(evaluate_fn, maximize):\n    \"\"\"Wrap evaluation function for JAX compatibility.\"\"\"\n\n    # Try to detect if function is JAX-pure\n    # by checking if it uses only JAX operations\n\n    def jax_eval(x: jax.Array) -&gt; float:\n        # Convert to numpy for non-pure functions\n        x_np = np.array(x)\n        result = evaluate_fn(x_np)\n        cost = result.mean_cost\n        return -cost if maximize else cost\n\n    # For non-pure functions, use pure_callback\n    if not _is_jax_pure(evaluate_fn):\n        @jax.jit\n        def wrapped(x):\n            return jax.pure_callback(\n                jax_eval,\n                jax.ShapeDtypeStruct((), jnp.float32),\n                x\n            )\n        return wrapped\n    else:\n        return jax.jit(jax_eval)\n\n\n\nProvide both modes:\nclass EvoSaxOptimizer(Optimizer):\n    def __init__(self, ..., batched_evaluation: bool = False):\n        self.batched_evaluation = batched_evaluation\n\n    def optimize_step(self):\n        solutions = self.es_state.ask()\n\n        if self.batched_evaluation:\n            # Parallel evaluation with vmap\n            fitness = jax.vmap(self.evaluate_fn)(solutions)\n        else:\n            # Sequential evaluation (safer for non-pure functions)\n            fitness = jnp.array([\n                self.evaluate_fn(x) for x in solutions\n            ])\n\n        self.es_state = self.es_state.tell(fitness)\n        ...\n\n\n\nEvosax doesnâ€™t natively handle box constraints. Options:\n\nRejection sampling: Reject invalid samples (wasteful)\nClipping: Clip to bounds after sampling (biases distribution)\nRepair: Project invalid samples to feasible region\nPenalty: Add penalty for constraint violation\n\nRecommendation: Use clipping (Option 2) for simplicity, add note in docs that proper constrained optimization should use constrained ES variants if needed.\ndef _apply_bounds(x, lower, upper):\n    \"\"\"Apply box constraints via clipping.\"\"\"\n    if lower is not None or upper is not None:\n        x = jnp.clip(x, lower, upper)\n    return x\n\n\n\n\n\nStrategies to support (from evosax):\n\n\n\nCMA_ES - Classic Covariance Matrix Adaptation\nSep_CMA_ES - Separable CMA-ES (faster for high-dim)\nIPOP_CMA_ES - Increasing population CMA-ES\nBIPOP_CMA_ES - Bi-population CMA-ES\nOpenES - OpenAIâ€™s Natural Evolution Strategies\nSNES - Separable Natural Evolution Strategies\nxNES - Exponential Natural Evolution Strategies\nSimpleGA - Simple Genetic Algorithm\nPersistentES - Persistent Evolution Strategies\nLES - Learned Evolution Strategies (meta-learned)\n\n\n\n\n\nDefault: CMA_ES (well-tested, robust)\nHigh-dimensional: Sep_CMA_ES (scales better)\nLarge population budget: OpenES (naturally parallelizable)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFeature\ncma library\nevosax\n\n\n\n\nLanguage\nPython + C\nPure JAX\n\n\nJIT compilation\nâŒ\nâœ…\n\n\nGPU acceleration\nâŒ\nâœ…\n\n\nBatched evaluation\nâŒ\nâœ… (via vmap)\n\n\nIntegration with JAX code\nâš ï¸ (numpy conversion)\nâœ… (native)\n\n\nAlgorithm variety\nCMA-ES variants only\n15+ strategies\n\n\nPerformance (CPU)\nGood\nSimilar\n\n\nPerformance (GPU)\nN/A\nExcellent (5-10x)\n\n\n\n\n\n\nUse cma library when:\n\nYou need the original CMA-ES implementation\nYour evaluation function has complex Python dependencies\nYouâ€™re not using GPU\n\nUse evosax when:\n\nYou want GPU acceleration\nYour MPPI code is already JIT-compiled\nYou want to experiment with different ES algorithms\nYou need batched parallel evaluation\n\n\n\n\n\n\n\n\n\nTest each strategy initialization\nTest optimize_step produces valid results\nTest parameter bounds enforcement\nTest with different parameter dimensions\n\n\n\n\n\nCompare convergence to cma library on same problems\nTest with actual MPPI parameter tuning\nVerify GPU execution (if GPU available)\n\n\n\n\n\nCompare wall-clock time vs cma library\nMeasure JIT compilation overhead\nProfile GPU vs CPU performance\n\n\n\n\n\nEnsure results are deterministic with fixed seed\nVerify backward compatibility with existing Optimizer API\n\n\n\n\n\n\n\n\nProblem: First call to evosax optimizer incurs JIT compilation cost.\nSolution:\n\nDocument warmup requirement\nProvide warmup() method that JIT-compiles with dummy data\nConsider pre-compilation for common parameter dimensions\n\n\n\n\nProblem: Most user evaluation functions are not JAX-pure (use numpy, I/O, etc.).\nSolution:\n\nUse jax.pure_callback to wrap impure functions\nProvide clear error messages when incompatible operations are detected\nDocument limitations and workarounds\n\n\n\n\nProblem: GPU memory may be limited for large populations.\nSolution:\n\nAdd memory usage estimates in docs\nProvide chunk-based evaluation for very large populations\nDefault to reasonable population sizes\n\n\n\n\nProblem: JAX PRNG behaves differently than numpy.random.\nSolution:\n\nDocument PRNG handling\nEnsure reproducibility with fixed JAX random keys\nProvide utility to seed evosax optimizer\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStep\nDescription\nEstimated Lines\nTime\n\n\n\n\n1\nAdd dependency to pyproject.toml\n~5\n5 min\n\n\n2\nImplement autotune_evosax.py\n~350\n4-6 hours\n\n\n3\nUpdate autotune.py docs\n~20\n30 min\n\n\n4\nUpdate init.py\n~5\n5 min\n\n\n5\nCreate test_autotune_evosax.py\n~250\n3-4 hours\n\n\n6\nCreate example comparison script\n~200\n2-3 hours\n\n\n7\nUpdate documentation\n~100\n1-2 hours\n\n\nTotal\n\n~930 lines\n11-16 hours\n\n\n\n\n\n\n\n\n\n\nEvoSaxOptimizer implements Optimizer ABC correctly\nAll evosax strategies can be instantiated\nOptimization converges on test problems\nIntegration with existing Autotune class works\nParameter bounds are respected\n\n\n\n\n\nEvosax is faster than cma on GPU (&gt;2x speedup)\nEvosax is competitive with cma on CPU (within 20%)\nJIT compilation overhead is acceptable (&lt;5s for typical problems)\n\n\n\n\n\nAll tests pass (&gt;95% coverage)\nDocumentation is clear and complete\nExamples run without errors\nCode follows existing style conventions\n\n\n\n\n\nWorks with all parameter types (Lambda, NoiseSigma, Mu, Horizon)\nCompatible with existing Autotune orchestrator\nNo breaking changes to existing API\nOptional dependency (doesnâ€™t break install if evosax not available)\n\n\n\n\n\n\n\n\n\nAdd more evosax strategies (GLD, LM-MA-ES, etc.)\nImplement proper constrained optimization variants\nAdd support for multi-objective optimization\nCreate Jupyter notebook tutorial\n\n\n\n\n\nIntegrate with autotune_qd.py for quality diversity\nAdd learned evolution strategies (LES) with meta-learning\nImplement adaptive strategy selection\nAdd visualization of ES state (e.g., covariance ellipsoids)\n\n\n\n\n\nDevelop JAX-native quality diversity framework\nAdd support for multi-fidelity optimization\nImplement distributed evosax with multi-GPU support\nCreate benchmarking suite comparing all optimizers\n\n\n\n\n\n\n\nevosax documentation\nJAX documentation\nCurrent autotuning implementation: src/jax_mppi/autotune.py\nOriginal pytorch_mppi autotune: ../pytorch_mppi/src/pytorch_mppi/autotune.py\n\n\n\n\n\n\nShould we deprecate the cma library backend?\n\nProbably not - keep both for compatibility\nUsers can choose based on their needs\n\nShould batched evaluation be default?\n\nNo - requires JAX-pure evaluation functions\nMake it opt-in with clear documentation\n\nWhich evosax strategies should have convenience classes?\n\nStart with: CMA_ES, Sep_CMA_ES, OpenES\nAdd more based on user feedback\n\nShould we add evosax to core dependencies or keep it optional?\n\nKeep optional - maintains lightweight core\nDocument installation clearly\n\n\n\n\n\n\n\nEvosax is actively maintained by Robert Lange\nCurrent version: 0.1.x (check latest before implementing)\nJAX-native means entire optimization loop can run on GPU\nConsider adding evosax to CI/CD pipeline for testing"
  },
  {
    "objectID": "plan/completed/evosax_integration.html#overview",
    "href": "plan/completed/evosax_integration.html#overview",
    "title": "Evosax Integration Plan",
    "section": "",
    "text": "Evosax is a JAX-native library for evolutionary strategies that provides highly efficient, JIT-compiled optimization algorithms. Integrating it into the autotuning framework will:\n\nProvide JAX-native optimization - Full JIT compilation of the entire tuning loop\nEnable GPU acceleration - Evolutionary strategies running entirely on GPU\nAdd diverse algorithms - CMA-ES, OpenES, SNES, Sep-CMA-ES, and more\nImprove performance - Eliminate Python overhead in the optimization loop\nSimplify dependencies - Pure JAX implementation, no external C++ dependencies\n\n\n\n\nPerformance: Fully JIT-compiled ES algorithms vs.Â Python-based cma library\nJAX ecosystem fit: Natural integration with JAX-based MPPI code\nGPU support: Can run entire autotuning on GPU without host-device transfers\nAlgorithm variety: 15+ evolutionary strategies in one package\nMaintained: Active development and well-documented"
  },
  {
    "objectID": "plan/completed/evosax_integration.html#current-state-analysis",
    "href": "plan/completed/evosax_integration.html#current-state-analysis",
    "title": "Evosax Integration Plan",
    "section": "",
    "text": "The current autotuning system has three modules:\n\nautotune.py (656 lines) - Core framework + CMA-ES via cma library\n\nAbstract Optimizer base class\nCMAESOpt using Python cma package\nParameter abstractions: LambdaParameter, NoiseSigmaParameter, MuParameter, HorizonParameter\nAutotune orchestrator class\n\nautotune_global.py (375 lines) - Ray Tune for global search\n\nRayOptimizer for distributed hyperparameter search\nGlobal parameter variants with search spaces\nIntegration with HyperOpt and BayesOpt\n\nautotune_qd.py (218 lines) - CMA-ME quality diversity\n\nCMAMEOpt using ribs library\nArchive-based diversity preservation\n\n\n\n\n\nAll optimizers follow the Optimizer ABC:\nclass Optimizer(abc.ABC):\n    @abc.abstractmethod\n    def setup_optimization(\n        self, initial_params: np.ndarray,\n        evaluate_fn: Callable[[np.ndarray], EvaluationResult]\n    ) -&gt; None:\n        ...\n\n    @abc.abstractmethod\n    def optimize_step(self) -&gt; EvaluationResult:\n        ...\n\n    def optimize_all(self, iterations: int) -&gt; EvaluationResult:\n        ..."
  },
  {
    "objectID": "plan/completed/evosax_integration.html#implementation-plan",
    "href": "plan/completed/evosax_integration.html#implementation-plan",
    "title": "Evosax Integration Plan",
    "section": "",
    "text": "File: pyproject.toml\nChanges:\n\nAdd evosax&gt;=0.1.0 to [project.optional-dependencies.autotuning] section\nAdd to [project.optional-dependencies.dev] section as well\n\nReasoning: Keep evosax optional like other autotuning dependencies, allowing users to install only what they need.\n\n\n\n\nNew File: src/jax_mppi/autotune_evosax.py (~387 lines)\nContents (Implemented):\n\n\nImplements Optimizer ABC with evosax backends:\nclass EvoSaxOptimizer(Optimizer):\n    \"\"\"JAX-native evolutionary strategies using evosax.\n\n    Fully JIT-compiled optimization loop with GPU support.\n\n    Attributes:\n        strategy: evosax strategy name (e.g., \"CMA_ES\", \"OpenES\", \"SNES\")\n        population: Population size\n        num_generations: Number of generations per optimize_step\n        maximize: Whether to maximize objective (default: False for cost minimization)\n    \"\"\"\n\n    def __init__(\n        self,\n        strategy: str = \"CMA_ES\",\n        population: int = 10,\n        num_generations: int = 1,\n        sigma_init: float = 0.1,\n        maximize: bool = False,\n        es_params: dict | None = None,\n    ):\n        ...\nKey features:\n\nStrategy selection from evosaxâ€™s 15+ algorithms\nJIT-compiled ask-evaluate-tell loop\nSupport for both single-step and batch optimization\nConfigurable ES hyperparameters via es_params\n\n\n\n\ndef _create_jax_evaluate_fn(\n    evaluate_fn: Callable[[np.ndarray], EvaluationResult],\n    maximize: bool = False,\n) -&gt; Callable[[jax.Array], float]:\n    \"\"\"Wrap Python evaluation function for JAX compatibility.\n\n    Handles conversion between JAX arrays and numpy arrays,\n    extracts scalar cost from EvaluationResult.\n    \"\"\"\n    ...\nChallenge: The user-provided evaluate_fn may not be JAX-pure (e.g., it might use numpy, modify state, etc.). Need to handle this gracefully.\nSolutions:\n\nOption A: Use jax.pure_callback to call non-pure evaluation functions\nOption B: Require evaluation function to be JAX-pure for evosax optimizer\nOption C: Provide both pure and impure modes\n\nRecommendation: Start with Option C - detect if evaluation is JAX-pure, use direct JIT if yes, use pure_callback if no.\n\n\n\nEvosax can leverage vmap for parallel fitness evaluation:\ndef _batch_evaluate(\n    solutions: jax.Array,  # (population, param_dim)\n    evaluate_fn: Callable,\n) -&gt; jax.Array:  # (population,)\n    \"\"\"Evaluate population in parallel using vmap.\"\"\"\n    return jax.vmap(evaluate_fn)(solutions)\nBenefits:\n\nGPU parallelization of fitness evaluations\nSignificant speedup when dynamics/cost are JIT-compiled\n\nChallenges:\n\nRequires evaluation to be JAX-pure and vmappable\nMay need sequential fallback for non-pure evaluations\n\n\n\n\nProvide convenience classes for common strategies:\nclass CMAESOpt(EvoSaxOptimizer):\n    \"\"\"CMA-ES optimizer (evosax backend).\"\"\"\n    def __init__(self, population: int = 10, sigma: float = 0.1, **kwargs):\n        super().__init__(strategy=\"CMA_ES\", population=population,\n                         sigma_init=sigma, **kwargs)\n\nclass OpenESOpt(EvoSaxOptimizer):\n    \"\"\"OpenAI's Evolution Strategies.\"\"\"\n    def __init__(self, population: int = 100, sigma: float = 0.1, **kwargs):\n        super().__init__(strategy=\"OpenES\", population=population,\n                         sigma_init=sigma, **kwargs)\n\nclass SepCMAESOpt(EvoSaxOptimizer):\n    \"\"\"Separable CMA-ES (faster for high dimensions).\"\"\"\n    def __init__(self, population: int = 10, sigma: float = 0.1, **kwargs):\n        super().__init__(strategy=\"Sep_CMA_ES\", population=population,\n                         sigma_init=sigma, **kwargs)\n\n\n\n\n\nFile: src/jax_mppi/autotune.py\nChanges:\n\nUpdate module docstring to mention evosax as an option\nUpdate examples to show evosax usage\n\nExample addition:\n&gt;&gt;&gt; # With evosax (JAX-native, GPU-accelerated)\n&gt;&gt;&gt; from jax_mppi import autotune_evosax\n&gt;&gt;&gt; tuner = jmppi.autotune.Autotune(\n...     params_to_tune=[...],\n...     evaluate_fn=evaluate,\n...     optimizer=autotune_evosax.CMAESOpt(population=10),\n... )\n\n\n\n\nFile: src/jax_mppi/__init__.py\nChanges:\n# Add conditional import\ntry:\n    from . import autotune_evosax\nexcept ImportError:\n    autotune_evosax = None  # evosax not installed\nReasoning: Keep it optional - donâ€™t break imports if evosax isnâ€™t installed.\n\n\n\n\nNew File: tests/test_autotune_evosax.py (~408 lines)\nTest coverage:\n\nBasic functionality tests\n\nTest EvoSaxOptimizer initialization with various strategies\nTest setup_optimization() creates valid ES state\nTest optimize_step() returns EvaluationResult\nTest optimize_all() finds better solutions\n\nStrategy-specific tests\n\nTest CMAESOpt on simple quadratic function\nTest OpenESOpt convergence\nTest SepCMAESOpt on high-dimensional problem\n\nIntegration tests\n\nTest with actual MPPI parameter tuning (simple 1D system)\nTest with LambdaParameter and NoiseSigmaParameter\nVerify results comparable to CMAESOpt from cma library\n\nJAX-specific tests\n\nTest JIT compilation of optimization loop\nTest with JAX-pure evaluation function\nTest with non-pure evaluation function (using pure_callback)\nTest batched evaluation with vmap\n\nEdge cases\n\nTest with single parameter\nTest with multi-dimensional parameters\nTest parameter bounds enforcement\nTest with invalid strategy name (should raise clear error)\n\n\nTest structure example:\ndef test_evosax_cmaes_simple():\n    \"\"\"Test CMA-ES on simple quadratic objective.\"\"\"\n    # Minimize ||x - target||^2\n    target = np.array([1.0, 2.0, 3.0])\n\n    def evaluate_fn(x: np.ndarray) -&gt; EvaluationResult:\n        cost = float(np.sum((x - target) ** 2))\n        return EvaluationResult(\n            mean_cost=cost,\n            rollouts=jnp.zeros((1, 1, 3)),\n            params={},\n            iteration=0,\n        )\n\n    optimizer = EvoSaxOptimizer(strategy=\"CMA_ES\", population=10)\n    optimizer.setup_optimization(\n        initial_params=np.zeros(3),\n        evaluate_fn=evaluate_fn,\n    )\n\n    best = optimizer.optimize_all(iterations=50)\n\n    # Should converge close to target\n    assert best.mean_cost &lt; 0.1\n\n\n\n\nNew File: examples/autotune_evosax_comparison.py (~307 lines)\nPurpose: Compare evosax vs.Â cma library performance\nContents:\n\nSetup simple pendulum MPPI tuning task\nRun with CMAESOpt from cma library (baseline)\nRun with CMAESOpt from evosax\nRun with other evosax strategies (OpenES, Sep-CMA-ES)\nCompare:\n\nConvergence speed (iterations to threshold)\nWall-clock time\nFinal performance\n\nGenerate comparison plots:\n\nConvergence curves for each optimizer\nTime comparison bar chart\nParameter trajectory plots\n\n\nExpected outcome: Evosax should be faster in wall-clock time due to JIT compilation, especially with GPU.\n\n\n\n\n\n\nAdd evosax to the autotuning section:\n### Autotuning\n\nJAX-MPPI supports automatic hyperparameter tuning with multiple backends:\n\n- **CMA-ES** (via `cma` library) - Classic evolution strategy\n- **CMA-ES** (via `evosax`) - JAX-native, GPU-accelerated  âš¡ **NEW**\n- **Ray Tune** - Distributed hyperparameter search\n- **CMA-ME** (via `ribs`) - Quality diversity optimization\n\nInstall with: `pip install jax-mppi[autotuning] evosax`\n\n\n\nUpdate autotune.py module docstring with evosax example.\n\n\n\nDocument for users switching from cma to evosax:\n## Migrating from cma to evosax\n\n**Before:**\n```python\nfrom jax_mppi.autotune import CMAESOpt\nopt = CMAESOpt(population=10, sigma=0.1)\nAfter:\nfrom jax_mppi.autotune_evosax import CMAESOpt\nopt = CMAESOpt(population=10, sigma=0.1)\nBenefits: 5-10x faster with GPU acceleration"
  },
  {
    "objectID": "plan/completed/evosax_integration.html#implementation-details",
    "href": "plan/completed/evosax_integration.html#implementation-details",
    "title": "Evosax Integration Plan",
    "section": "",
    "text": "The main challenge is that user evaluation functions may not be JAX-pure.\nStrategy:\ndef _wrap_evaluation(evaluate_fn, maximize):\n    \"\"\"Wrap evaluation function for JAX compatibility.\"\"\"\n\n    # Try to detect if function is JAX-pure\n    # by checking if it uses only JAX operations\n\n    def jax_eval(x: jax.Array) -&gt; float:\n        # Convert to numpy for non-pure functions\n        x_np = np.array(x)\n        result = evaluate_fn(x_np)\n        cost = result.mean_cost\n        return -cost if maximize else cost\n\n    # For non-pure functions, use pure_callback\n    if not _is_jax_pure(evaluate_fn):\n        @jax.jit\n        def wrapped(x):\n            return jax.pure_callback(\n                jax_eval,\n                jax.ShapeDtypeStruct((), jnp.float32),\n                x\n            )\n        return wrapped\n    else:\n        return jax.jit(jax_eval)\n\n\n\nProvide both modes:\nclass EvoSaxOptimizer(Optimizer):\n    def __init__(self, ..., batched_evaluation: bool = False):\n        self.batched_evaluation = batched_evaluation\n\n    def optimize_step(self):\n        solutions = self.es_state.ask()\n\n        if self.batched_evaluation:\n            # Parallel evaluation with vmap\n            fitness = jax.vmap(self.evaluate_fn)(solutions)\n        else:\n            # Sequential evaluation (safer for non-pure functions)\n            fitness = jnp.array([\n                self.evaluate_fn(x) for x in solutions\n            ])\n\n        self.es_state = self.es_state.tell(fitness)\n        ...\n\n\n\nEvosax doesnâ€™t natively handle box constraints. Options:\n\nRejection sampling: Reject invalid samples (wasteful)\nClipping: Clip to bounds after sampling (biases distribution)\nRepair: Project invalid samples to feasible region\nPenalty: Add penalty for constraint violation\n\nRecommendation: Use clipping (Option 2) for simplicity, add note in docs that proper constrained optimization should use constrained ES variants if needed.\ndef _apply_bounds(x, lower, upper):\n    \"\"\"Apply box constraints via clipping.\"\"\"\n    if lower is not None or upper is not None:\n        x = jnp.clip(x, lower, upper)\n    return x"
  },
  {
    "objectID": "plan/completed/evosax_integration.html#available-evosax-strategies",
    "href": "plan/completed/evosax_integration.html#available-evosax-strategies",
    "title": "Evosax Integration Plan",
    "section": "",
    "text": "Strategies to support (from evosax):\n\n\n\nCMA_ES - Classic Covariance Matrix Adaptation\nSep_CMA_ES - Separable CMA-ES (faster for high-dim)\nIPOP_CMA_ES - Increasing population CMA-ES\nBIPOP_CMA_ES - Bi-population CMA-ES\nOpenES - OpenAIâ€™s Natural Evolution Strategies\nSNES - Separable Natural Evolution Strategies\nxNES - Exponential Natural Evolution Strategies\nSimpleGA - Simple Genetic Algorithm\nPersistentES - Persistent Evolution Strategies\nLES - Learned Evolution Strategies (meta-learned)\n\n\n\n\n\nDefault: CMA_ES (well-tested, robust)\nHigh-dimensional: Sep_CMA_ES (scales better)\nLarge population budget: OpenES (naturally parallelizable)"
  },
  {
    "objectID": "plan/completed/evosax_integration.html#migration-from-cma-library",
    "href": "plan/completed/evosax_integration.html#migration-from-cma-library",
    "title": "Evosax Integration Plan",
    "section": "",
    "text": "Feature\ncma library\nevosax\n\n\n\n\nLanguage\nPython + C\nPure JAX\n\n\nJIT compilation\nâŒ\nâœ…\n\n\nGPU acceleration\nâŒ\nâœ…\n\n\nBatched evaluation\nâŒ\nâœ… (via vmap)\n\n\nIntegration with JAX code\nâš ï¸ (numpy conversion)\nâœ… (native)\n\n\nAlgorithm variety\nCMA-ES variants only\n15+ strategies\n\n\nPerformance (CPU)\nGood\nSimilar\n\n\nPerformance (GPU)\nN/A\nExcellent (5-10x)\n\n\n\n\n\n\nUse cma library when:\n\nYou need the original CMA-ES implementation\nYour evaluation function has complex Python dependencies\nYouâ€™re not using GPU\n\nUse evosax when:\n\nYou want GPU acceleration\nYour MPPI code is already JIT-compiled\nYou want to experiment with different ES algorithms\nYou need batched parallel evaluation"
  },
  {
    "objectID": "plan/completed/evosax_integration.html#testing-strategy",
    "href": "plan/completed/evosax_integration.html#testing-strategy",
    "title": "Evosax Integration Plan",
    "section": "",
    "text": "Test each strategy initialization\nTest optimize_step produces valid results\nTest parameter bounds enforcement\nTest with different parameter dimensions\n\n\n\n\n\nCompare convergence to cma library on same problems\nTest with actual MPPI parameter tuning\nVerify GPU execution (if GPU available)\n\n\n\n\n\nCompare wall-clock time vs cma library\nMeasure JIT compilation overhead\nProfile GPU vs CPU performance\n\n\n\n\n\nEnsure results are deterministic with fixed seed\nVerify backward compatibility with existing Optimizer API"
  },
  {
    "objectID": "plan/completed/evosax_integration.html#potential-issues-solutions",
    "href": "plan/completed/evosax_integration.html#potential-issues-solutions",
    "title": "Evosax Integration Plan",
    "section": "",
    "text": "Problem: First call to evosax optimizer incurs JIT compilation cost.\nSolution:\n\nDocument warmup requirement\nProvide warmup() method that JIT-compiles with dummy data\nConsider pre-compilation for common parameter dimensions\n\n\n\n\nProblem: Most user evaluation functions are not JAX-pure (use numpy, I/O, etc.).\nSolution:\n\nUse jax.pure_callback to wrap impure functions\nProvide clear error messages when incompatible operations are detected\nDocument limitations and workarounds\n\n\n\n\nProblem: GPU memory may be limited for large populations.\nSolution:\n\nAdd memory usage estimates in docs\nProvide chunk-based evaluation for very large populations\nDefault to reasonable population sizes\n\n\n\n\nProblem: JAX PRNG behaves differently than numpy.random.\nSolution:\n\nDocument PRNG handling\nEnsure reproducibility with fixed JAX random keys\nProvide utility to seed evosax optimizer"
  },
  {
    "objectID": "plan/completed/evosax_integration.html#timeline-estimate",
    "href": "plan/completed/evosax_integration.html#timeline-estimate",
    "title": "Evosax Integration Plan",
    "section": "",
    "text": "Step\nDescription\nEstimated Lines\nTime\n\n\n\n\n1\nAdd dependency to pyproject.toml\n~5\n5 min\n\n\n2\nImplement autotune_evosax.py\n~350\n4-6 hours\n\n\n3\nUpdate autotune.py docs\n~20\n30 min\n\n\n4\nUpdate init.py\n~5\n5 min\n\n\n5\nCreate test_autotune_evosax.py\n~250\n3-4 hours\n\n\n6\nCreate example comparison script\n~200\n2-3 hours\n\n\n7\nUpdate documentation\n~100\n1-2 hours\n\n\nTotal\n\n~930 lines\n11-16 hours"
  },
  {
    "objectID": "plan/completed/evosax_integration.html#success-criteria",
    "href": "plan/completed/evosax_integration.html#success-criteria",
    "title": "Evosax Integration Plan",
    "section": "",
    "text": "EvoSaxOptimizer implements Optimizer ABC correctly\nAll evosax strategies can be instantiated\nOptimization converges on test problems\nIntegration with existing Autotune class works\nParameter bounds are respected\n\n\n\n\n\nEvosax is faster than cma on GPU (&gt;2x speedup)\nEvosax is competitive with cma on CPU (within 20%)\nJIT compilation overhead is acceptable (&lt;5s for typical problems)\n\n\n\n\n\nAll tests pass (&gt;95% coverage)\nDocumentation is clear and complete\nExamples run without errors\nCode follows existing style conventions\n\n\n\n\n\nWorks with all parameter types (Lambda, NoiseSigma, Mu, Horizon)\nCompatible with existing Autotune orchestrator\nNo breaking changes to existing API\nOptional dependency (doesnâ€™t break install if evosax not available)"
  },
  {
    "objectID": "plan/completed/evosax_integration.html#future-extensions",
    "href": "plan/completed/evosax_integration.html#future-extensions",
    "title": "Evosax Integration Plan",
    "section": "",
    "text": "Add more evosax strategies (GLD, LM-MA-ES, etc.)\nImplement proper constrained optimization variants\nAdd support for multi-objective optimization\nCreate Jupyter notebook tutorial\n\n\n\n\n\nIntegrate with autotune_qd.py for quality diversity\nAdd learned evolution strategies (LES) with meta-learning\nImplement adaptive strategy selection\nAdd visualization of ES state (e.g., covariance ellipsoids)\n\n\n\n\n\nDevelop JAX-native quality diversity framework\nAdd support for multi-fidelity optimization\nImplement distributed evosax with multi-GPU support\nCreate benchmarking suite comparing all optimizers"
  },
  {
    "objectID": "plan/completed/evosax_integration.html#references",
    "href": "plan/completed/evosax_integration.html#references",
    "title": "Evosax Integration Plan",
    "section": "",
    "text": "evosax documentation\nJAX documentation\nCurrent autotuning implementation: src/jax_mppi/autotune.py\nOriginal pytorch_mppi autotune: ../pytorch_mppi/src/pytorch_mppi/autotune.py"
  },
  {
    "objectID": "plan/completed/evosax_integration.html#open-questions",
    "href": "plan/completed/evosax_integration.html#open-questions",
    "title": "Evosax Integration Plan",
    "section": "",
    "text": "Should we deprecate the cma library backend?\n\nProbably not - keep both for compatibility\nUsers can choose based on their needs\n\nShould batched evaluation be default?\n\nNo - requires JAX-pure evaluation functions\nMake it opt-in with clear documentation\n\nWhich evosax strategies should have convenience classes?\n\nStart with: CMA_ES, Sep_CMA_ES, OpenES\nAdd more based on user feedback\n\nShould we add evosax to core dependencies or keep it optional?\n\nKeep optional - maintains lightweight core\nDocument installation clearly"
  },
  {
    "objectID": "plan/completed/evosax_integration.html#notes",
    "href": "plan/completed/evosax_integration.html#notes",
    "title": "Evosax Integration Plan",
    "section": "",
    "text": "Evosax is actively maintained by Robert Lange\nCurrent version: 0.1.x (check latest before implementing)\nJAX-native means entire optimization loop can run on GPU\nConsider adding evosax to CI/CD pipeline for testing"
  },
  {
    "objectID": "plan/completed/cuda_mppi_submodule_plan.html",
    "href": "plan/completed/cuda_mppi_submodule_plan.html",
    "title": "Plan: Add cuda_mppi as git submodule",
    "section": "",
    "text": "Extract the CUDA MPPI implementation from src/cuda_mppi/ into a separate git repository and integrate it as a submodule at third_party/cuda_mppi.\n\n\n\n\nNew repository: riccardo-enr/cuda_mppi\nSubmodule path: third_party/cuda_mppi\nFeature branch: feat/cuda-mppi-submodule\nTrack branch: main (in submodule)\n\n\n\n\n\n\n\nUse gh repo create to create riccardo-enr/cuda_mppi\nSet appropriate description and visibility\nInitialize with README.md\n\n\n\n\n\nClone the new repository locally\nCopy contents from src/cuda_mppi/ to repository root\nCreate proper repository structure:\n\nCMakeLists.txt (standalone build)\nREADME.md (usage and build instructions)\nLICENSE (MIT, matching main project)\n.gitignore\n\nCommit and push initial code\n\n\n\n\n\nCreate branch: feat/cuda-mppi-submodule\nCheckout the new branch\n\n\n\n\n\nCreate third_party/ directory\nRun: git submodule add https://github.com/riccardo-enr/cuda_mppi.git third_party/cuda_mppi\nRemove old src/cuda_mppi/ directory\nCommit submodule addition\n\n\n\n\n\nUpdate root CMakeLists.txt:\n\nChange add_subdirectory(src/cuda_mppi) to add_subdirectory(third_party/cuda_mppi)\n\nVerify pyproject.toml (should work via scikit-build-core automatically)\nCheck for any hardcoded paths in:\n\nPython source files\nCMake files\nDocumentation\n\n\n\n\n\n\nClean build: rm -rf build/ _skbuild/\nTest clone from scratch with submodules\nBuild and install package: uv pip install -e .\nRun test: python examples/test_cuda_mppi.py\nVerify JIT examples work\n\n\n\n\n\nAdd submodule instructions to README.md:\n# Clone with submodules\ngit clone --recursive https://github.com/riccardo-enr/jax_mppi.git\n\n# Or if already cloned\ngit submodule update --init --recursive\nDocument build requirements in both repositories\nUpdate any relevant documentation links\n\n\n\n\n\nCommit all changes with conventional commits\nPush feature branch\nCreate PR referencing issue #23\nMove this plan to completed/ directory\n\n\n\n\n\nIf issues arise, we can:\n\nRemove submodule: git submodule deinit -f third_party/cuda_mppi\nDelete from git: git rm -f third_party/cuda_mppi\nRemove from .gitmodules\nRestore original src/cuda_mppi from git history"
  },
  {
    "objectID": "plan/completed/cuda_mppi_submodule_plan.html#overview",
    "href": "plan/completed/cuda_mppi_submodule_plan.html#overview",
    "title": "Plan: Add cuda_mppi as git submodule",
    "section": "",
    "text": "Extract the CUDA MPPI implementation from src/cuda_mppi/ into a separate git repository and integrate it as a submodule at third_party/cuda_mppi."
  },
  {
    "objectID": "plan/completed/cuda_mppi_submodule_plan.html#decisions-made",
    "href": "plan/completed/cuda_mppi_submodule_plan.html#decisions-made",
    "title": "Plan: Add cuda_mppi as git submodule",
    "section": "",
    "text": "New repository: riccardo-enr/cuda_mppi\nSubmodule path: third_party/cuda_mppi\nFeature branch: feat/cuda-mppi-submodule\nTrack branch: main (in submodule)"
  },
  {
    "objectID": "plan/completed/cuda_mppi_submodule_plan.html#implementation-steps",
    "href": "plan/completed/cuda_mppi_submodule_plan.html#implementation-steps",
    "title": "Plan: Add cuda_mppi as git submodule",
    "section": "",
    "text": "Use gh repo create to create riccardo-enr/cuda_mppi\nSet appropriate description and visibility\nInitialize with README.md\n\n\n\n\n\nClone the new repository locally\nCopy contents from src/cuda_mppi/ to repository root\nCreate proper repository structure:\n\nCMakeLists.txt (standalone build)\nREADME.md (usage and build instructions)\nLICENSE (MIT, matching main project)\n.gitignore\n\nCommit and push initial code\n\n\n\n\n\nCreate branch: feat/cuda-mppi-submodule\nCheckout the new branch\n\n\n\n\n\nCreate third_party/ directory\nRun: git submodule add https://github.com/riccardo-enr/cuda_mppi.git third_party/cuda_mppi\nRemove old src/cuda_mppi/ directory\nCommit submodule addition\n\n\n\n\n\nUpdate root CMakeLists.txt:\n\nChange add_subdirectory(src/cuda_mppi) to add_subdirectory(third_party/cuda_mppi)\n\nVerify pyproject.toml (should work via scikit-build-core automatically)\nCheck for any hardcoded paths in:\n\nPython source files\nCMake files\nDocumentation\n\n\n\n\n\n\nClean build: rm -rf build/ _skbuild/\nTest clone from scratch with submodules\nBuild and install package: uv pip install -e .\nRun test: python examples/test_cuda_mppi.py\nVerify JIT examples work\n\n\n\n\n\nAdd submodule instructions to README.md:\n# Clone with submodules\ngit clone --recursive https://github.com/riccardo-enr/jax_mppi.git\n\n# Or if already cloned\ngit submodule update --init --recursive\nDocument build requirements in both repositories\nUpdate any relevant documentation links\n\n\n\n\n\nCommit all changes with conventional commits\nPush feature branch\nCreate PR referencing issue #23\nMove this plan to completed/ directory"
  },
  {
    "objectID": "plan/completed/cuda_mppi_submodule_plan.html#rollback-plan",
    "href": "plan/completed/cuda_mppi_submodule_plan.html#rollback-plan",
    "title": "Plan: Add cuda_mppi as git submodule",
    "section": "",
    "text": "If issues arise, we can:\n\nRemove submodule: git submodule deinit -f third_party/cuda_mppi\nDelete from git: git rm -f third_party/cuda_mppi\nRemove from .gitmodules\nRestore original src/cuda_mppi from git history"
  },
  {
    "objectID": "plan/i_mppi_architecture_alignment.html",
    "href": "plan/i_mppi_architecture_alignment.html",
    "title": "I-MPPI Architecture Alignment Plan",
    "section": "",
    "text": "The current I-MPPI implementation is missing the informative term in Layer 3 (fast loop). The architecture description specifies a two-layer system:\n\nLayer 2 (FSMI Analyzer): ~5-10 Hz - Full FSMI for reference trajectory generation\nLayer 3 (I-MPPI Controller): ~50 Hz - Fast control with Uniform-FSMI for local reactivity\n\nCurrently, Layer 3 only does trajectory tracking (running_cost), which reduces I-MPPI to standard MPPI with a biased reference. This loses: - Reactive viewpoint maintenance during disturbances - Handling of occlusions detected between Layer 2 updates - True informative control behavior\n\n\n\n\n\nCreate a simplified O(n) FSMI variant for the fast loop:\nclass UniformFSMI:\n    \"\"\"\n    Uniform-FSMI from Zhang et al. (2020) for O(n) computation.\n\n    Simplifications vs full FSMI:\n    - Assumes uniform sensor noise\n    - Uses shorter ray range (local, 2-3m)\n    - Fewer beams\n    - No G_kj matrix computation (biggest speedup)\n    \"\"\"\nKey differences from full FSMI: - Sensor noise is uniform (constant sigma) - Ray range limited to 2-3m (local) - Reduced beam count (4-8 vs 16) - Direct sum without G_kj matrix: MI â‰ˆ sum_j P(e_j) * C_j\n\n\n\nAdd to src/jax_mppi/i_mppi/environment.py:\ndef informative_running_cost(\n    state: jax.Array,\n    action: jax.Array,\n    t: int,\n    target: jax.Array,\n    grid_map: jax.Array,\n    uniform_fsmi: UniformFSMI,\n    info_weight: float = 5.0,\n) -&gt; jax.Array:\n    \"\"\"\n    Cost function with informative term:\n    J = tracking_cost - info_weight * uniform_fsmi(state)\n    \"\"\"\n    tracking = running_cost(state, action, t, target)\n    info_gain = uniform_fsmi.compute(grid_map, state[:2], yaw)\n    return tracking - info_weight * info_gain\n\n\n\nModify examples/i_mppi/i_mppi_simulation.py:\n# Layer 3: Biased I-MPPI with informative cost\ncost_fn = partial(\n    informative_running_cost,\n    target=ref_traj,\n    grid_map=grid_map,\n    uniform_fsmi=uniform_fsmi,\n    info_weight=local_info_weight,\n)\n\n\n\nReorganize examples/i_mppi/ to clearly show the architecture:\nexamples/i_mppi/\nâ”œâ”€â”€ __init__.py\nâ”œâ”€â”€ i_mppi_simulation.py      # Main: Layer 2 (FSMI) + Layer 3 (I-MPPI with Uniform-FSMI)\nâ”œâ”€â”€ i_mppi_simulation_legacy.py  # Legacy: geometric zones\nâ”œâ”€â”€ fsmi_grid_demo.py         # Demo: Full FSMI visualization\nâ”œâ”€â”€ uniform_fsmi_demo.py      # NEW: Demonstrate Uniform-FSMI speedup\nâ””â”€â”€ architecture_comparison.py # NEW: Compare with/without Layer 3 info term\n\n\n\n\n\n\n\nAdd UniformFSMI class to fsmi.py\nImplement O(n) MI computation\nAdd configuration parameters (short_range, few_beams)\nBenchmark vs full FSMI\n\n\n\n\n\nAdd informative_running_cost() to environment.py\nMake grid_map accessible in cost function (via closure or state)\nHandle yaw extraction from state\n\n\n\n\n\nIntegrate Uniform-FSMI into Layer 3 cost\nAdd config parameters for local info weight\nMaintain backward compatibility flag\n\n\n\n\n\nCreate uniform_fsmi_demo.py\nCreate architecture_comparison.py showing the difference\n\n\n\n\n\nUpdate README in examples/i_mppi/\nDocument the two-layer architecture\n\n\n\n\n\n\n\nFSMIConfig(\n    use_grid_fsmi=True,\n    num_beams=16,\n    max_range=5.0,\n    ray_step=0.15,\n    trajectory_subsample_rate=8,\n    info_weight=15.0,\n)\n\n\n\nUniformFSMIConfig(\n    num_beams=6,          # Reduced\n    max_range=2.5,        # Local only\n    ray_step=0.2,         # Coarser\n    info_weight=5.0,      # Lower weight (reactive)\n)\n\n\n\n\n\n\n\nComponent\nRate\nComputation\n\n\n\n\nLayer 2 (Full FSMI)\n5 Hz\n~40-50ms\n\n\nLayer 3 (Uniform-FSMI per sample)\n50 Hz\n~0.5ms\n\n\nTotal control cycle\n50 Hz\n&lt;20ms\n\n\n\n\n\n\n\nReactive Viewpoint Maintenance: During disturbances, Layer 3 locally optimizes viewing angle\nOcclusion Handling: Can detect and respond to occlusions between Layer 2 updates\nTrue I-MPPI: Not just biased trajectory tracking\n\n\n\n\n\nStep 1: Uniform-FSMI implementation (UniformFSMI class in fsmi.py)\nStep 2: Cost function update (informative_running_cost in environment.py)\nStep 3: Simulation integration (i_mppi_simulation.py updated)\nStep 4: Demo examples (optional: architecture_comparison.py)\nStep 5: Documentation (README.md updated)"
  },
  {
    "objectID": "plan/i_mppi_architecture_alignment.html#problem-statement",
    "href": "plan/i_mppi_architecture_alignment.html#problem-statement",
    "title": "I-MPPI Architecture Alignment Plan",
    "section": "",
    "text": "The current I-MPPI implementation is missing the informative term in Layer 3 (fast loop). The architecture description specifies a two-layer system:\n\nLayer 2 (FSMI Analyzer): ~5-10 Hz - Full FSMI for reference trajectory generation\nLayer 3 (I-MPPI Controller): ~50 Hz - Fast control with Uniform-FSMI for local reactivity\n\nCurrently, Layer 3 only does trajectory tracking (running_cost), which reduces I-MPPI to standard MPPI with a biased reference. This loses: - Reactive viewpoint maintenance during disturbances - Handling of occlusions detected between Layer 2 updates - True informative control behavior"
  },
  {
    "objectID": "plan/i_mppi_architecture_alignment.html#required-changes",
    "href": "plan/i_mppi_architecture_alignment.html#required-changes",
    "title": "I-MPPI Architecture Alignment Plan",
    "section": "",
    "text": "Create a simplified O(n) FSMI variant for the fast loop:\nclass UniformFSMI:\n    \"\"\"\n    Uniform-FSMI from Zhang et al. (2020) for O(n) computation.\n\n    Simplifications vs full FSMI:\n    - Assumes uniform sensor noise\n    - Uses shorter ray range (local, 2-3m)\n    - Fewer beams\n    - No G_kj matrix computation (biggest speedup)\n    \"\"\"\nKey differences from full FSMI: - Sensor noise is uniform (constant sigma) - Ray range limited to 2-3m (local) - Reduced beam count (4-8 vs 16) - Direct sum without G_kj matrix: MI â‰ˆ sum_j P(e_j) * C_j\n\n\n\nAdd to src/jax_mppi/i_mppi/environment.py:\ndef informative_running_cost(\n    state: jax.Array,\n    action: jax.Array,\n    t: int,\n    target: jax.Array,\n    grid_map: jax.Array,\n    uniform_fsmi: UniformFSMI,\n    info_weight: float = 5.0,\n) -&gt; jax.Array:\n    \"\"\"\n    Cost function with informative term:\n    J = tracking_cost - info_weight * uniform_fsmi(state)\n    \"\"\"\n    tracking = running_cost(state, action, t, target)\n    info_gain = uniform_fsmi.compute(grid_map, state[:2], yaw)\n    return tracking - info_weight * info_gain\n\n\n\nModify examples/i_mppi/i_mppi_simulation.py:\n# Layer 3: Biased I-MPPI with informative cost\ncost_fn = partial(\n    informative_running_cost,\n    target=ref_traj,\n    grid_map=grid_map,\n    uniform_fsmi=uniform_fsmi,\n    info_weight=local_info_weight,\n)\n\n\n\nReorganize examples/i_mppi/ to clearly show the architecture:\nexamples/i_mppi/\nâ”œâ”€â”€ __init__.py\nâ”œâ”€â”€ i_mppi_simulation.py      # Main: Layer 2 (FSMI) + Layer 3 (I-MPPI with Uniform-FSMI)\nâ”œâ”€â”€ i_mppi_simulation_legacy.py  # Legacy: geometric zones\nâ”œâ”€â”€ fsmi_grid_demo.py         # Demo: Full FSMI visualization\nâ”œâ”€â”€ uniform_fsmi_demo.py      # NEW: Demonstrate Uniform-FSMI speedup\nâ””â”€â”€ architecture_comparison.py # NEW: Compare with/without Layer 3 info term"
  },
  {
    "objectID": "plan/i_mppi_architecture_alignment.html#implementation-steps",
    "href": "plan/i_mppi_architecture_alignment.html#implementation-steps",
    "title": "I-MPPI Architecture Alignment Plan",
    "section": "",
    "text": "Add UniformFSMI class to fsmi.py\nImplement O(n) MI computation\nAdd configuration parameters (short_range, few_beams)\nBenchmark vs full FSMI\n\n\n\n\n\nAdd informative_running_cost() to environment.py\nMake grid_map accessible in cost function (via closure or state)\nHandle yaw extraction from state\n\n\n\n\n\nIntegrate Uniform-FSMI into Layer 3 cost\nAdd config parameters for local info weight\nMaintain backward compatibility flag\n\n\n\n\n\nCreate uniform_fsmi_demo.py\nCreate architecture_comparison.py showing the difference\n\n\n\n\n\nUpdate README in examples/i_mppi/\nDocument the two-layer architecture"
  },
  {
    "objectID": "plan/i_mppi_architecture_alignment.html#configuration-parameters",
    "href": "plan/i_mppi_architecture_alignment.html#configuration-parameters",
    "title": "I-MPPI Architecture Alignment Plan",
    "section": "",
    "text": "FSMIConfig(\n    use_grid_fsmi=True,\n    num_beams=16,\n    max_range=5.0,\n    ray_step=0.15,\n    trajectory_subsample_rate=8,\n    info_weight=15.0,\n)\n\n\n\nUniformFSMIConfig(\n    num_beams=6,          # Reduced\n    max_range=2.5,        # Local only\n    ray_step=0.2,         # Coarser\n    info_weight=5.0,      # Lower weight (reactive)\n)"
  },
  {
    "objectID": "plan/i_mppi_architecture_alignment.html#expected-performance",
    "href": "plan/i_mppi_architecture_alignment.html#expected-performance",
    "title": "I-MPPI Architecture Alignment Plan",
    "section": "",
    "text": "Component\nRate\nComputation\n\n\n\n\nLayer 2 (Full FSMI)\n5 Hz\n~40-50ms\n\n\nLayer 3 (Uniform-FSMI per sample)\n50 Hz\n~0.5ms\n\n\nTotal control cycle\n50 Hz\n&lt;20ms"
  },
  {
    "objectID": "plan/i_mppi_architecture_alignment.html#benefits-of-proper-architecture",
    "href": "plan/i_mppi_architecture_alignment.html#benefits-of-proper-architecture",
    "title": "I-MPPI Architecture Alignment Plan",
    "section": "",
    "text": "Reactive Viewpoint Maintenance: During disturbances, Layer 3 locally optimizes viewing angle\nOcclusion Handling: Can detect and respond to occlusions between Layer 2 updates\nTrue I-MPPI: Not just biased trajectory tracking"
  },
  {
    "objectID": "plan/i_mppi_architecture_alignment.html#status",
    "href": "plan/i_mppi_architecture_alignment.html#status",
    "title": "I-MPPI Architecture Alignment Plan",
    "section": "",
    "text": "Step 1: Uniform-FSMI implementation (UniformFSMI class in fsmi.py)\nStep 2: Cost function update (informative_running_cost in environment.py)\nStep 3: Simulation integration (i_mppi_simulation.py updated)\nStep 4: Demo examples (optional: architecture_comparison.py)\nStep 5: Documentation (README.md updated)"
  },
  {
    "objectID": "theory.html",
    "href": "theory.html",
    "title": "Theoretical Background",
    "section": "",
    "text": "This section provides the mathematical foundations for the Model Predictive Path Integral (MPPI) control algorithm and its variants implemented in jax_mppi.\n\n\nModel Predictive Path Integral (MPPI) control is a sampling-based model predictive control algorithm derived from information-theoretic principles. It solves the stochastic optimal control problem by simulating multiple trajectories and updating the control policy based on their costs.\n\n\nWe consider a discrete-time dynamical system with dynamics:\n[ _{t+1} = f(_t, _t) + _t ]\nwhere \\(\\mathbf{x}_t \\in \\mathbb{R}^{n_x}\\) is the state, \\(\\mathbf{u}_t \\in \\mathbb{R}^{n_u}\\) is the control input, and \\(\\mathbf{v}_t \\sim \\mathcal{N}(0, \\Sigma)\\) is Gaussian noise.\nThe objective is to find the control sequence \\(U = \\{\\mathbf{u}_0, \\dots, \\mathbf{u}_{T-1}\\}\\) that minimizes the expected cost:\n[ J(U) = ]\nwhere \\(\\phi(\\mathbf{x}_T)\\) is the terminal cost and \\(q(\\mathbf{x}_t)\\) is the state-dependent running cost. The term \\(\\frac{1}{2} \\mathbf{u}_t^T \\Sigma^{-1} \\mathbf{u}_t\\) represents the control effort cost.\n\n\n\nMPPI relies on the duality between free energy and relative entropy (KL divergence). The optimal control distribution \\(p^*\\) is proportional to the exponential of the trajectory cost:\n[ p^*() (- S()) ]\nwhere \\(S(\\tau)\\) is the cost of a trajectory \\(\\tau\\) and \\(\\lambda\\) is a temperature parameter.\n\n\n\nIn practice, we approximate the optimal control by sampling \\(K\\) trajectories around a nominal control sequence \\(\\mathbf{u}_{nom}\\). For each sample \\(k\\), we apply a perturbation \\(\\epsilon_k \\sim \\mathcal{N}(0, \\Sigma)\\):\n[ {t, k} = {nom, t} + _{t, k} ]\nThe cost for the \\(k\\)-th trajectory is computed as:\n[ S_k = ({T, k}) + {t=0}^{T-1} ( q({t, k}) + {nom, t}^T ^{-1} _{t, k} ) ]\nThe weights for each trajectory are computed using the softmax function:\n[ w_k = ]\nwhere \\(\\beta = \\min_k S_k\\) for numerical stability.\nThe control sequence is then updated by computing the weighted average of the perturbations:\n[ {new, t} = {nom, t} + {k=1}^K w_k {t, k} ]\n\n\n\n\nStandard MPPI assumes the control inputs are independent across time steps, which can lead to jerky or non-smooth control signals. Smooth MPPI (SMPPI) addresses this by lifting the control problem to a higher-order space (e.g., controlling acceleration instead of velocity).\n\n\nIn SMPPI, the nominal trajectory \\(U\\) represents the derivative of the actual action (e.g., acceleration). The actual action \\(\\mathbf{a}_t\\) is part of the state or computed by integrating \\(U\\).\nLet \\(\\mathbf{u}_t\\) be the command at time \\(t\\) (from the optimizer). The action applied to the system is \\(\\mathbf{a}_t\\), updated as:\n[ _{t+1} = _t + _t t ]\n\n\n\nSMPPI explicitly penalizes changes in the action sequence to encourage smoothness. The cost function includes a term for the magnitude of the command \\(\\mathbf{u}_t\\) (which corresponds to the change in action):\n[ J_{smooth} = _{t=0}^{T-1} ||t||^2 = {t=0}^{T-1} ||||^2 ]\nThis formulation ensures that the generated trajectories are smooth and feasible for systems with actuation limits or bandwidth constraints.\n\n\n\n\nKernel MPPI (KMPPI) parameterizes the control trajectory using a set of basis functions or kernels, rather than optimizing the control input at every time step independently. This reduces the dimensionality of the optimization problem and implicitly enforces smoothness.\n\n\nWe assume the control trajectory \\(\\mathbf{u}(t)\\) lies in a Reproducing Kernel Hilbert Space (RKHS) defined by a kernel \\(k(t, t')\\). The control is represented as a linear combination of basis functions centered at support points \\(t_i\\):\n[ (t) = _{i=1}^{M} _i k(t, t_i) ]\nwhere \\(M\\) is the number of support points (often \\(M &lt; T\\)), and \\(\\alpha_i\\) are the weights (parameters) to be optimized.\n\n\n\nInstead of perturbing the control inputs \\(\\mathbf{u}_t\\) directly, KMPPI perturbs the parameters \\(\\alpha_i\\) (or equivalent control points).\nLet \\(\\theta\\) represent the parameters. We sample perturbations \\(\\delta \\theta_k \\sim \\mathcal{N}(0, \\Sigma_\\theta)\\). The corresponding control trajectory is:\n[ _k(t) = (+ _k) ]\nThe update rule is applied to \\(\\theta\\):\n[ {new} = {nom} + _{k=1}^K w_k _k ]\nBy choosing an appropriate kernel (e.g., RBF kernel), we can control the smoothness and frequency content of the resulting trajectories.",
    "crumbs": [
      "Home",
      "Introduction",
      "Theoretical Background"
    ]
  },
  {
    "objectID": "theory.html#standard-mppi",
    "href": "theory.html#standard-mppi",
    "title": "Theoretical Background",
    "section": "",
    "text": "Model Predictive Path Integral (MPPI) control is a sampling-based model predictive control algorithm derived from information-theoretic principles. It solves the stochastic optimal control problem by simulating multiple trajectories and updating the control policy based on their costs.\n\n\nWe consider a discrete-time dynamical system with dynamics:\n[ _{t+1} = f(_t, _t) + _t ]\nwhere \\(\\mathbf{x}_t \\in \\mathbb{R}^{n_x}\\) is the state, \\(\\mathbf{u}_t \\in \\mathbb{R}^{n_u}\\) is the control input, and \\(\\mathbf{v}_t \\sim \\mathcal{N}(0, \\Sigma)\\) is Gaussian noise.\nThe objective is to find the control sequence \\(U = \\{\\mathbf{u}_0, \\dots, \\mathbf{u}_{T-1}\\}\\) that minimizes the expected cost:\n[ J(U) = ]\nwhere \\(\\phi(\\mathbf{x}_T)\\) is the terminal cost and \\(q(\\mathbf{x}_t)\\) is the state-dependent running cost. The term \\(\\frac{1}{2} \\mathbf{u}_t^T \\Sigma^{-1} \\mathbf{u}_t\\) represents the control effort cost.\n\n\n\nMPPI relies on the duality between free energy and relative entropy (KL divergence). The optimal control distribution \\(p^*\\) is proportional to the exponential of the trajectory cost:\n[ p^*() (- S()) ]\nwhere \\(S(\\tau)\\) is the cost of a trajectory \\(\\tau\\) and \\(\\lambda\\) is a temperature parameter.\n\n\n\nIn practice, we approximate the optimal control by sampling \\(K\\) trajectories around a nominal control sequence \\(\\mathbf{u}_{nom}\\). For each sample \\(k\\), we apply a perturbation \\(\\epsilon_k \\sim \\mathcal{N}(0, \\Sigma)\\):\n[ {t, k} = {nom, t} + _{t, k} ]\nThe cost for the \\(k\\)-th trajectory is computed as:\n[ S_k = ({T, k}) + {t=0}^{T-1} ( q({t, k}) + {nom, t}^T ^{-1} _{t, k} ) ]\nThe weights for each trajectory are computed using the softmax function:\n[ w_k = ]\nwhere \\(\\beta = \\min_k S_k\\) for numerical stability.\nThe control sequence is then updated by computing the weighted average of the perturbations:\n[ {new, t} = {nom, t} + {k=1}^K w_k {t, k} ]",
    "crumbs": [
      "Home",
      "Introduction",
      "Theoretical Background"
    ]
  },
  {
    "objectID": "theory.html#smooth-mppi-smppi",
    "href": "theory.html#smooth-mppi-smppi",
    "title": "Theoretical Background",
    "section": "",
    "text": "Standard MPPI assumes the control inputs are independent across time steps, which can lead to jerky or non-smooth control signals. Smooth MPPI (SMPPI) addresses this by lifting the control problem to a higher-order space (e.g., controlling acceleration instead of velocity).\n\n\nIn SMPPI, the nominal trajectory \\(U\\) represents the derivative of the actual action (e.g., acceleration). The actual action \\(\\mathbf{a}_t\\) is part of the state or computed by integrating \\(U\\).\nLet \\(\\mathbf{u}_t\\) be the command at time \\(t\\) (from the optimizer). The action applied to the system is \\(\\mathbf{a}_t\\), updated as:\n[ _{t+1} = _t + _t t ]\n\n\n\nSMPPI explicitly penalizes changes in the action sequence to encourage smoothness. The cost function includes a term for the magnitude of the command \\(\\mathbf{u}_t\\) (which corresponds to the change in action):\n[ J_{smooth} = _{t=0}^{T-1} ||t||^2 = {t=0}^{T-1} ||||^2 ]\nThis formulation ensures that the generated trajectories are smooth and feasible for systems with actuation limits or bandwidth constraints.",
    "crumbs": [
      "Home",
      "Introduction",
      "Theoretical Background"
    ]
  },
  {
    "objectID": "theory.html#kernel-mppi-kmppi",
    "href": "theory.html#kernel-mppi-kmppi",
    "title": "Theoretical Background",
    "section": "",
    "text": "Kernel MPPI (KMPPI) parameterizes the control trajectory using a set of basis functions or kernels, rather than optimizing the control input at every time step independently. This reduces the dimensionality of the optimization problem and implicitly enforces smoothness.\n\n\nWe assume the control trajectory \\(\\mathbf{u}(t)\\) lies in a Reproducing Kernel Hilbert Space (RKHS) defined by a kernel \\(k(t, t')\\). The control is represented as a linear combination of basis functions centered at support points \\(t_i\\):\n[ (t) = _{i=1}^{M} _i k(t, t_i) ]\nwhere \\(M\\) is the number of support points (often \\(M &lt; T\\)), and \\(\\alpha_i\\) are the weights (parameters) to be optimized.\n\n\n\nInstead of perturbing the control inputs \\(\\mathbf{u}_t\\) directly, KMPPI perturbs the parameters \\(\\alpha_i\\) (or equivalent control points).\nLet \\(\\theta\\) represent the parameters. We sample perturbations \\(\\delta \\theta_k \\sim \\mathcal{N}(0, \\Sigma_\\theta)\\). The corresponding control trajectory is:\n[ _k(t) = (+ _k) ]\nThe update rule is applied to \\(\\theta\\):\n[ {new} = {nom} + _{k=1}^K w_k _k ]\nBy choosing an appropriate kernel (e.g., RBF kernel), we can control the smoothness and frequency content of the resulting trajectories.",
    "crumbs": [
      "Home",
      "Introduction",
      "Theoretical Background"
    ]
  }
]