---
title: "Quadrotor Control Examples"
format:
  html:
    code-fold: false
    toc: true
    toc-depth: 3
---

JAX-MPPI includes comprehensive quadrotor control examples demonstrating trajectory tracking with nonlinear 6-DOF dynamics. These examples showcase the performance of standard MPPI, Smooth MPPI (SMPPI), and Kernel MPPI (KMPPI) on challenging maneuvers.

## Overview

The quadrotor examples demonstrate:

1.  **Nonlinear Dynamics**: Full quaternion-based attitude representation with NED (North-East-Down) frame conventions.
2.  **Trajectory Tracking**: Tracking of various reference trajectories (hover, circle, figure-8).
3.  **Variant Comparison**: Side-by-side performance analysis of MPPI, SMPPI, and KMPPI.
4.  **Real-time Control**: High-frequency control loops (~50 Hz) enabled by JAX JIT compilation.

## Available Examples

The examples are located in `examples/quadrotor/`.

### 1. Hover Stabilization (`hover.py`)

Stabilizes the quadrotor at a fixed position $[0, 0, -1]$ m. This is the simplest test case, useful for verifying dynamics and basic controller tuning.

```bash
python examples/quadrotor/hover.py
```

### 2. Circular Trajectory (`circle.py`)

Tracks a circular path of radius 1m at a constant altitude and speed.

```bash
python examples/quadrotor/circle.py
```

### 3. Waypoint Navigation (`custom_trajectory.py`)

Follows a custom trajectory defined by a sequence of 3D waypoints. The reference trajectory is generated using cubic Hermite spline interpolation for smooth derivatives.

```bash
python examples/quadrotor/custom_trajectory.py
```

### 4. Variant Comparison (`figure8_comparison.py`)

Runs MPPI, SMPPI, and KMPPI on an aggressive figure-8 trajectory and plots a comparative analysis of tracking error and control smoothness.

```bash
python examples/quadrotor/figure8_comparison.py
```

**Key Insight**: SMPPI typically achieves 30-40% smoother control (lower jerk) compared to standard MPPI while maintaining similar tracking accuracy, making it superior for real-world hardware.

## Dynamics Model

The quadrotor dynamics are modeled with 12 state variables and 4 control inputs:

-   **State** $\mathbf{x} \in \mathbb{R}^{12}$:
    -   Position $[x, y, z]$ (NED frame)
    -   Velocity $[v_x, v_y, v_z]$ (Body frame)
    -   Attitude Quaternion $[q_w, q_x, q_y, q_z]$
    -   Angular Rates $[\omega_x, \omega_y, \omega_z]$

-   **Control** $\mathbf{u} \in \mathbb{R}^4$:
    -   Motor thrusts $[T_1, T_2, T_3, T_4]$ (normalized 0-1 or raw force)

:::{.callout-note}
## Coordinate System
The implementation uses the **NED (North-East-Down)** coordinate system for position and **FRD (Front-Right-Down)** for body-frame vectors, consistent with PX4 and standard aeronautical conventions.
:::

## MPPI Configuration

Typical configuration for quadrotor control:

```python
config, mppi_state = mppi.create(
    nx=12,
    nu=4,
    horizon=40,              # 0.8s lookahead at 50Hz
    num_samples=1500,        # Number of trajectories
    noise_sigma=jnp.diag(...), # Exploration noise
    lambda_=0.1,             # Temperature
    u_min=jnp.zeros(4),      # Minimum thrust
    u_max=jnp.ones(4)        # Maximum thrust
)
```

## Results Analysis

The examples produce plots visualizing:
-   **3D Trajectory**: Reference path vs. actual path.
-   **State Tracking**: Position, velocity, and attitude over time.
-   **Control Inputs**: Motor commands, highlighting chatter or saturation.
-   **Performance Metrics**: RMS error and average control effort.

To compare controllers quantitatively, run `figure8_comparison.py` which generates a combined report.
