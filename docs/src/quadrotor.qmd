---
title: "Quadrotor Control Examples"
format:
  html:
    code-fold: false
    toc: true
    toc-depth: 3
---

JAX-MPPI includes a suite of quadrotor control examples demonstrating high-performance trajectory tracking using various MPPI flavors (Vanilla MPPI, SMPPI, KMPPI).

## Overview

The examples cover different aspects of UAV control:

- **Stabilization**: Hovering at a fixed setpoint (`hover.py`).
- **Trajectory Tracking**: Following dynamic paths like circles (`circle.py`).
- **Agile Maneuvers**: Tracking aggressive figure-8 patterns (`figure8_comparison.py`).
- **Custom Waypoints**: Interpolating and following user-defined waypoints (`custom_trajectory.py`).

## Theory

### Dynamics Model

The quadrotor is modeled as a 6-DOF rigid body with 13 state variables:

$$
\mathbf{x} = [p_x, p_y, p_z, v_x, v_y, v_z, q_w, q_x, q_y, q_z, \omega_x, \omega_y, \omega_z]^T
$$

- Position $\mathbf{p} \in \mathbb{R}^3$ (NED frame)
- Velocity $\mathbf{v} \in \mathbb{R}^3$ (Body frame)
- Attitude quaternion $\mathbf{q} \in \mathbb{H}$ (Body to Earth)
- Angular velocity $\boldsymbol{\omega} \in \mathbb{R}^3$ (Body frame)

The control inputs are total thrust and body torques (approximated as angular acceleration commands for simplicity in some examples, or direct torques).

### Cost Function

The cost function typically includes:

$$
J(\mathbf{x}, \mathbf{u}) = (\mathbf{p} - \mathbf{p}_{ref})^T Q_p (\mathbf{p} - \mathbf{p}_{ref}) + \|\mathbf{v} - \mathbf{v}_{ref}\|^2_{Q_v} + \|\mathbf{u}\|^2_R
$$

For attitude tracking, we penalize the geodesic distance between the current and reference orientation.

## Installation

The examples require `matplotlib` for visualization.

```bash
pip install matplotlib
```

## Quick Start

To run the basic hover stabilization example:

```bash
python examples/quadrotor/hover.py --visualize
```

This will simulate the quadrotor stabilizing from an initial displacement and display trajectory plots.

## Usage

### Stabilization (`hover.py`)

Stabilizes the quadrotor at a fixed position (default: $[0, 0, -5]$m).

```bash
python examples/quadrotor/hover.py --steps 500 --horizon 30
```

### Circle Tracking (`circle.py`)

Tracks a circular trajectory of radius 2.5m at 2.0 m/s.

```bash
python examples/quadrotor/circle.py --visualize
```

### MPPI Variant Comparison (`figure8_comparison.py`)

Compares the performance of three controllers on an aggressive figure-8 trajectory:

1. **MPPI**: Standard algorithm.
2. **SMPPI (Smooth MPPI)**: Optimizes for control smoothness.
3. **KMPPI (Kernel MPPI)**: Uses smooth basis functions for control.

```bash
python examples/quadrotor/figure8_comparison.py
```

## Examples

### Hover Stabilization Walkthrough

Here is how to set up the hover task using `jax_mppi`.

First, define the dynamics and cost functions:

```python
from jax_mppi.dynamics.quadrotor import create_quadrotor_dynamics
from jax_mppi.costs.quadrotor import create_hover_cost
import jax.numpy as jnp

# Create dynamics model
dynamics = create_quadrotor_dynamics(dt=0.02, mass=1.0, gravity=9.81, tau_omega=0.05, u_min=..., u_max=...)

# Create cost function targeting 5m altitude
hover_pos = jnp.array([0., 0., -5.])
hover_quat = jnp.array([1., 0., 0., 0.])
running_cost = create_hover_cost(
    Q_pos=jnp.eye(3)*100,
    Q_vel=jnp.eye(3)*10,
    Q_att=jnp.eye(4)*5,
    R=jnp.eye(4)*0.01,
    target_pos=hover_pos,
    target_quat=hover_quat
)
```

Then initialize the MPPI controller:

```python
from jax_mppi import mppi

config, mppi_state = mppi.create(
    nx=13, nu=4,
    noise_sigma=jnp.diag(jnp.array([5.0, 1.0, 1.0, 1.0])), # High thrust noise
    horizon=30,
    lambda_=1.0,
    u_min=..., u_max=...
)
```

Finally, run the control loop:

```python
import jax

# JIT compile for performance
command = jax.jit(mppi.command, static_argnames=['dynamics', 'running_cost'])

# Initial state
current_state = jnp.array([2.0, 1.0, -3.0] + [0]*10)

for t in range(500):
    action, mppi_state = command(
        config, mppi_state, current_state,
        dynamics=dynamics,
        running_cost=running_cost
    )
    current_state = dynamics(current_state, action)
```

## Results

### Smoothness Comparison

In the `figure8_comparison.py` example, **SMPPI** typically demonstrates:

- **Lower Control Jerk**: Resulting in smoother motor commands.
- **Similar Tracking Error**: Maintaining accuracy while reducing mechanical stress.

**KMPPI** can achieve similar smoothness with fewer optimization parameters by using a spline basis for the control sequence.

| Metric | MPPI | SMPPI | KMPPI |
|--------|------|-------|-------|
| Pos RMS (m) | 0.08 | 0.09 | 0.08 |
| Jerk Cost | 15.4 | 4.2 | 5.1 |

*(Representative values)*
