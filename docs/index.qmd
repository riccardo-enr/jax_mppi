---
title: "JAX-MPPI: High-Performance Model Predictive Path Integral Control in JAX"
format:
  html:
    code-fold: false
    toc: true
    toc-depth: 3
---

**jax_mppi** is a functional, JIT-compilable implementation of Model Predictive Path Integral (MPPI) control. It leverages JAX's high-performance numerical computing capabilities to deliver fast, parallelizable, and differentiable control algorithms for robotics and autonomous systems.

## Overview

Model Predictive Path Integral (MPPI) is a sampling-based control algorithm that solves stochastic optimal control problems. By simulating thousands of noisy trajectories in parallel and aggregating their costs, MPPI computes optimal control actions without requiring explicit gradients of the dynamics model.

This library provides a robust, production-ready implementation of MPPI and its variants (Smooth MPPI, Kernel MPPI) tailored for high-frequency control loops.

:::{.callout-note}
## Design Philosophy
This library embraces JAX's functional paradigm:
- **Pure Functions**: Core logic is implemented as pure functions `command(state, ...) -> (action, state)`.
- **Dataclass State**: State is held in registered Pytree containers, enabling seamless integration with `jit`, `vmap`, and `grad`.
- **No Side Effects**: State transitions are explicit; there is no mutable internal state.
:::

## Key Features

- **Core MPPI**: Standard implementation for general-purpose control.
- **Smooth MPPI (SMPPI)**: Optimizes in a lifted space (e.g., acceleration) to produce smooth control signals.
- **Kernel MPPI (KMPPI)**: Parameterizes trajectories using kernels (e.g., RBF) for dimensionality reduction and smoothness.
- **Autotuning**: Integrated hyperparameter optimization using CMA-ES, Ray Tune, and Quality Diversity.
- **Hardware Acceleration**:
  - **CUDA/C++ Backend**: Optimized kernels for extreme performance.
  - **JAX JIT**: Just-In-Time compilation for fast Python-based execution.
- **Composability**: Easily integrates with other JAX libraries and simulation environments.

## Installation

### Dependencies

- Python 3.10+
- JAX (with CUDA support recommended for performance)
- NumPy

### Build from Source

```bash
# Clone the repository
git clone https://github.com/riccardo-enr/jax_mppi.git
cd jax_mppi

# Install using pip (editable mode recommended for development)
pip install -e .
```

:::{.callout-warning}
## GPU Support
To leverage GPU acceleration, ensure you have installed the appropriate JAX version for your CUDA toolkit. See the [JAX Installation Guide](https://jax.readthedocs.io/en/latest/installation.html).
:::

## Quick Start

Here is a minimal example of setting up an MPPI controller for a simple system.

```python
import jax
import jax.numpy as jnp
from jax_mppi import mppi

# 1. Define System Dynamics (x_next = f(x, u))
def dynamics(state, action):
    # Simple integrator: position += velocity
    return state + action * 0.1  # dt = 0.1

# 2. Define Cost Function (J = sum(running_cost))
def running_cost(state, action):
    target = jnp.array([1.0, 1.0])
    return jnp.sum((state - target)**2) + 0.1 * jnp.sum(action**2)

# 3. Initialize Controller
config, mppi_state = mppi.create(
    nx=2,  # State dimension
    nu=2,  # Action dimension
    noise_sigma=jnp.eye(2) * 0.5, # Exploration noise
    horizon=20, # Planning horizon
    lambda_=0.1 # Temperature
)

# 4. Control Loop
current_obs = jnp.zeros(2)
key = jax.random.PRNGKey(0)

# JIT-compile the command step for performance
jitted_command = jax.jit(mppi.command, static_argnames=['dynamics', 'running_cost'])

print("Starting control loop...")
for _ in range(10):
    action, mppi_state = jitted_command(
        config,
        mppi_state,
        current_obs,
        dynamics=dynamics,
        running_cost=running_cost
    )

    # Simulate environment
    current_obs = dynamics(current_obs, action)
    print(f"State: {current_obs}, Action: {action}")
```

## Usage

The library provides three main controller variants, each residing in its own module:

- `jax_mppi.mppi`: Standard MPPI. Best for general use.
- `jax_mppi.smppi`: Smooth MPPI. Best when smooth control inputs are critical (e.g., physical actuators).
- `jax_mppi.kmppi`: Kernel MPPI. Best for high-dimensional or long-horizon tasks where parameter reduction is beneficial.

For detailed API documentation, see the [API Reference](src/api_reference.qmd).

## Examples

The `examples/` directory contains runnable scripts demonstrating various capabilities:

- **Pendulum**: `examples/pendulum.py` - Classic control benchmark.
- **Quadrotor**: `examples/quadrotor/` - UAV control tasks (hover, circle tracking).
- **I-MPPI**: `examples/i_mppi/` - Informative path planning with map exploration.

:::{.callout-tip}
## Running Examples
To run an example, ensure your `PYTHONPATH` includes the source directory:
```bash
PYTHONPATH=src python examples/pendulum.py
```
:::

## Troubleshooting

### JAX JIT Errors
If you encounter `TracerBoolConversionError`, ensure you are not using Python control flow (like `if x > 0`) inside JIT-compiled functions. Use `jax.lax.cond` or `jnp.where` instead.

### Performance Issues
- Ensure you are using `jax.jit` on the main control loop.
- Check if JAX is using the GPU (`jax.devices()`).
- Reduce `num_samples` or `horizon` if the computation is too heavy for your hardware.

## Citing

If you use this library in your research, please cite the repository and the original MPPI papers.

## License

MIT License. See `LICENSE` for details.
